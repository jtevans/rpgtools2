
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function () {
	'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var react = {exports: {}};

	var react_production = {};

	/**
	 * @license React
	 * react.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReact_production;

	function requireReact_production () {
		if (hasRequiredReact_production) return react_production;
		hasRequiredReact_production = 1;
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		  REACT_MEMO_TYPE = Symbol.for("react.memo"),
		  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
		  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
		function getIteratorFn(maybeIterable) {
		  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		  maybeIterable =
		    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		    maybeIterable["@@iterator"];
		  return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		var ReactNoopUpdateQueue = {
		    isMounted: function () {
		      return false;
		    },
		    enqueueForceUpdate: function () {},
		    enqueueReplaceState: function () {},
		    enqueueSetState: function () {}
		  },
		  assign = Object.assign,
		  emptyObject = {};
		function Component(props, context, updater) {
		  this.props = props;
		  this.context = context;
		  this.refs = emptyObject;
		  this.updater = updater || ReactNoopUpdateQueue;
		}
		Component.prototype.isReactComponent = {};
		Component.prototype.setState = function (partialState, callback) {
		  if (
		    "object" !== typeof partialState &&
		    "function" !== typeof partialState &&
		    null != partialState
		  )
		    throw Error(
		      "takes an object of state variables to update or a function which returns an object of state variables."
		    );
		  this.updater.enqueueSetState(this, partialState, callback, "setState");
		};
		Component.prototype.forceUpdate = function (callback) {
		  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
		};
		function ComponentDummy() {}
		ComponentDummy.prototype = Component.prototype;
		function PureComponent(props, context, updater) {
		  this.props = props;
		  this.context = context;
		  this.refs = emptyObject;
		  this.updater = updater || ReactNoopUpdateQueue;
		}
		var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
		pureComponentPrototype.constructor = PureComponent;
		assign(pureComponentPrototype, Component.prototype);
		pureComponentPrototype.isPureReactComponent = true;
		var isArrayImpl = Array.isArray,
		  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },
		  hasOwnProperty = Object.prototype.hasOwnProperty;
		function ReactElement(type, key, self, source, owner, props) {
		  self = props.ref;
		  return {
		    $$typeof: REACT_ELEMENT_TYPE,
		    type: type,
		    key: key,
		    ref: void 0 !== self ? self : null,
		    props: props
		  };
		}
		function cloneAndReplaceKey(oldElement, newKey) {
		  return ReactElement(
		    oldElement.type,
		    newKey,
		    void 0,
		    void 0,
		    void 0,
		    oldElement.props
		  );
		}
		function isValidElement(object) {
		  return (
		    "object" === typeof object &&
		    null !== object &&
		    object.$$typeof === REACT_ELEMENT_TYPE
		  );
		}
		function escape(key) {
		  var escaperLookup = { "=": "=0", ":": "=2" };
		  return (
		    "$" +
		    key.replace(/[=:]/g, function (match) {
		      return escaperLookup[match];
		    })
		  );
		}
		var userProvidedKeyEscapeRegex = /\/+/g;
		function getElementKey(element, index) {
		  return "object" === typeof element && null !== element && null != element.key
		    ? escape("" + element.key)
		    : index.toString(36);
		}
		function noop$1() {}
		function resolveThenable(thenable) {
		  switch (thenable.status) {
		    case "fulfilled":
		      return thenable.value;
		    case "rejected":
		      throw thenable.reason;
		    default:
		      switch (
		        ("string" === typeof thenable.status
		          ? thenable.then(noop$1, noop$1)
		          : ((thenable.status = "pending"),
		            thenable.then(
		              function (fulfilledValue) {
		                "pending" === thenable.status &&
		                  ((thenable.status = "fulfilled"),
		                  (thenable.value = fulfilledValue));
		              },
		              function (error) {
		                "pending" === thenable.status &&
		                  ((thenable.status = "rejected"), (thenable.reason = error));
		              }
		            )),
		        thenable.status)
		      ) {
		        case "fulfilled":
		          return thenable.value;
		        case "rejected":
		          throw thenable.reason;
		      }
		  }
		  throw thenable;
		}
		function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
		  var type = typeof children;
		  if ("undefined" === type || "boolean" === type) children = null;
		  var invokeCallback = false;
		  if (null === children) invokeCallback = true;
		  else
		    switch (type) {
		      case "bigint":
		      case "string":
		      case "number":
		        invokeCallback = true;
		        break;
		      case "object":
		        switch (children.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		          case REACT_PORTAL_TYPE:
		            invokeCallback = true;
		            break;
		          case REACT_LAZY_TYPE:
		            return (
		              (invokeCallback = children._init),
		              mapIntoArray(
		                invokeCallback(children._payload),
		                array,
		                escapedPrefix,
		                nameSoFar,
		                callback
		              )
		            );
		        }
		    }
		  if (invokeCallback)
		    return (
		      (callback = callback(children)),
		      (invokeCallback =
		        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
		      isArrayImpl(callback)
		        ? ((escapedPrefix = ""),
		          null != invokeCallback &&
		            (escapedPrefix =
		              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
		          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
		            return c;
		          }))
		        : null != callback &&
		          (isValidElement(callback) &&
		            (callback = cloneAndReplaceKey(
		              callback,
		              escapedPrefix +
		                (null == callback.key ||
		                (children && children.key === callback.key)
		                  ? ""
		                  : ("" + callback.key).replace(
		                      userProvidedKeyEscapeRegex,
		                      "$&/"
		                    ) + "/") +
		                invokeCallback
		            )),
		          array.push(callback)),
		      1
		    );
		  invokeCallback = 0;
		  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
		  if (isArrayImpl(children))
		    for (var i = 0; i < children.length; i++)
		      (nameSoFar = children[i]),
		        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
		        (invokeCallback += mapIntoArray(
		          nameSoFar,
		          array,
		          escapedPrefix,
		          type,
		          callback
		        ));
		  else if (((i = getIteratorFn(children)), "function" === typeof i))
		    for (
		      children = i.call(children), i = 0;
		      !(nameSoFar = children.next()).done;

		    )
		      (nameSoFar = nameSoFar.value),
		        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
		        (invokeCallback += mapIntoArray(
		          nameSoFar,
		          array,
		          escapedPrefix,
		          type,
		          callback
		        ));
		  else if ("object" === type) {
		    if ("function" === typeof children.then)
		      return mapIntoArray(
		        resolveThenable(children),
		        array,
		        escapedPrefix,
		        nameSoFar,
		        callback
		      );
		    array = String(children);
		    throw Error(
		      "Objects are not valid as a React child (found: " +
		        ("[object Object]" === array
		          ? "object with keys {" + Object.keys(children).join(", ") + "}"
		          : array) +
		        "). If you meant to render a collection of children, use an array instead."
		    );
		  }
		  return invokeCallback;
		}
		function mapChildren(children, func, context) {
		  if (null == children) return children;
		  var result = [],
		    count = 0;
		  mapIntoArray(children, result, "", "", function (child) {
		    return func.call(context, child, count++);
		  });
		  return result;
		}
		function lazyInitializer(payload) {
		  if (-1 === payload._status) {
		    var ctor = payload._result;
		    ctor = ctor();
		    ctor.then(
		      function (moduleObject) {
		        if (0 === payload._status || -1 === payload._status)
		          (payload._status = 1), (payload._result = moduleObject);
		      },
		      function (error) {
		        if (0 === payload._status || -1 === payload._status)
		          (payload._status = 2), (payload._result = error);
		      }
		    );
		    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
		  }
		  if (1 === payload._status) return payload._result.default;
		  throw payload._result;
		}
		var reportGlobalError =
		  "function" === typeof reportError
		    ? reportError
		    : function (error) {
		        if (
		          "object" === typeof window &&
		          "function" === typeof window.ErrorEvent
		        ) {
		          var event = new window.ErrorEvent("error", {
		            bubbles: true,
		            cancelable: true,
		            message:
		              "object" === typeof error &&
		              null !== error &&
		              "string" === typeof error.message
		                ? String(error.message)
		                : String(error),
		            error: error
		          });
		          if (!window.dispatchEvent(event)) return;
		        } else if (
		          "object" === typeof process &&
		          "function" === typeof process.emit
		        ) {
		          process.emit("uncaughtException", error);
		          return;
		        }
		        console.error(error);
		      };
		function noop() {}
		react_production.Children = {
		  map: mapChildren,
		  forEach: function (children, forEachFunc, forEachContext) {
		    mapChildren(
		      children,
		      function () {
		        forEachFunc.apply(this, arguments);
		      },
		      forEachContext
		    );
		  },
		  count: function (children) {
		    var n = 0;
		    mapChildren(children, function () {
		      n++;
		    });
		    return n;
		  },
		  toArray: function (children) {
		    return (
		      mapChildren(children, function (child) {
		        return child;
		      }) || []
		    );
		  },
		  only: function (children) {
		    if (!isValidElement(children))
		      throw Error(
		        "React.Children.only expected to receive a single React element child."
		      );
		    return children;
		  }
		};
		react_production.Component = Component;
		react_production.Fragment = REACT_FRAGMENT_TYPE;
		react_production.Profiler = REACT_PROFILER_TYPE;
		react_production.PureComponent = PureComponent;
		react_production.StrictMode = REACT_STRICT_MODE_TYPE;
		react_production.Suspense = REACT_SUSPENSE_TYPE;
		react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
		  ReactSharedInternals;
		react_production.__COMPILER_RUNTIME = {
		  __proto__: null,
		  c: function (size) {
		    return ReactSharedInternals.H.useMemoCache(size);
		  }
		};
		react_production.cache = function (fn) {
		  return function () {
		    return fn.apply(null, arguments);
		  };
		};
		react_production.cloneElement = function (element, config, children) {
		  if (null === element || void 0 === element)
		    throw Error(
		      "The argument must be a React element, but you passed " + element + "."
		    );
		  var props = assign({}, element.props),
		    key = element.key,
		    owner = void 0;
		  if (null != config)
		    for (propName in (void 0 !== config.ref && (owner = void 0),
		    void 0 !== config.key && (key = "" + config.key),
		    config))
		      !hasOwnProperty.call(config, propName) ||
		        "key" === propName ||
		        "__self" === propName ||
		        "__source" === propName ||
		        ("ref" === propName && void 0 === config.ref) ||
		        (props[propName] = config[propName]);
		  var propName = arguments.length - 2;
		  if (1 === propName) props.children = children;
		  else if (1 < propName) {
		    for (var childArray = Array(propName), i = 0; i < propName; i++)
		      childArray[i] = arguments[i + 2];
		    props.children = childArray;
		  }
		  return ReactElement(element.type, key, void 0, void 0, owner, props);
		};
		react_production.createContext = function (defaultValue) {
		  defaultValue = {
		    $$typeof: REACT_CONTEXT_TYPE,
		    _currentValue: defaultValue,
		    _currentValue2: defaultValue,
		    _threadCount: 0,
		    Provider: null,
		    Consumer: null
		  };
		  defaultValue.Provider = defaultValue;
		  defaultValue.Consumer = {
		    $$typeof: REACT_CONSUMER_TYPE,
		    _context: defaultValue
		  };
		  return defaultValue;
		};
		react_production.createElement = function (type, config, children) {
		  var propName,
		    props = {},
		    key = null;
		  if (null != config)
		    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
		      hasOwnProperty.call(config, propName) &&
		        "key" !== propName &&
		        "__self" !== propName &&
		        "__source" !== propName &&
		        (props[propName] = config[propName]);
		  var childrenLength = arguments.length - 2;
		  if (1 === childrenLength) props.children = children;
		  else if (1 < childrenLength) {
		    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
		      childArray[i] = arguments[i + 2];
		    props.children = childArray;
		  }
		  if (type && type.defaultProps)
		    for (propName in ((childrenLength = type.defaultProps), childrenLength))
		      void 0 === props[propName] &&
		        (props[propName] = childrenLength[propName]);
		  return ReactElement(type, key, void 0, void 0, null, props);
		};
		react_production.createRef = function () {
		  return { current: null };
		};
		react_production.forwardRef = function (render) {
		  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
		};
		react_production.isValidElement = isValidElement;
		react_production.lazy = function (ctor) {
		  return {
		    $$typeof: REACT_LAZY_TYPE,
		    _payload: { _status: -1, _result: ctor },
		    _init: lazyInitializer
		  };
		};
		react_production.memo = function (type, compare) {
		  return {
		    $$typeof: REACT_MEMO_TYPE,
		    type: type,
		    compare: void 0 === compare ? null : compare
		  };
		};
		react_production.startTransition = function (scope) {
		  var prevTransition = ReactSharedInternals.T,
		    currentTransition = {};
		  ReactSharedInternals.T = currentTransition;
		  try {
		    var returnValue = scope(),
		      onStartTransitionFinish = ReactSharedInternals.S;
		    null !== onStartTransitionFinish &&
		      onStartTransitionFinish(currentTransition, returnValue);
		    "object" === typeof returnValue &&
		      null !== returnValue &&
		      "function" === typeof returnValue.then &&
		      returnValue.then(noop, reportGlobalError);
		  } catch (error) {
		    reportGlobalError(error);
		  } finally {
		    ReactSharedInternals.T = prevTransition;
		  }
		};
		react_production.unstable_useCacheRefresh = function () {
		  return ReactSharedInternals.H.useCacheRefresh();
		};
		react_production.use = function (usable) {
		  return ReactSharedInternals.H.use(usable);
		};
		react_production.useActionState = function (action, initialState, permalink) {
		  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
		};
		react_production.useCallback = function (callback, deps) {
		  return ReactSharedInternals.H.useCallback(callback, deps);
		};
		react_production.useContext = function (Context) {
		  return ReactSharedInternals.H.useContext(Context);
		};
		react_production.useDebugValue = function () {};
		react_production.useDeferredValue = function (value, initialValue) {
		  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
		};
		react_production.useEffect = function (create, createDeps, update) {
		  var dispatcher = ReactSharedInternals.H;
		  if ("function" === typeof update)
		    throw Error(
		      "useEffect CRUD overload is not enabled in this build of React."
		    );
		  return dispatcher.useEffect(create, createDeps);
		};
		react_production.useId = function () {
		  return ReactSharedInternals.H.useId();
		};
		react_production.useImperativeHandle = function (ref, create, deps) {
		  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
		};
		react_production.useInsertionEffect = function (create, deps) {
		  return ReactSharedInternals.H.useInsertionEffect(create, deps);
		};
		react_production.useLayoutEffect = function (create, deps) {
		  return ReactSharedInternals.H.useLayoutEffect(create, deps);
		};
		react_production.useMemo = function (create, deps) {
		  return ReactSharedInternals.H.useMemo(create, deps);
		};
		react_production.useOptimistic = function (passthrough, reducer) {
		  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
		};
		react_production.useReducer = function (reducer, initialArg, init) {
		  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
		};
		react_production.useRef = function (initialValue) {
		  return ReactSharedInternals.H.useRef(initialValue);
		};
		react_production.useState = function (initialState) {
		  return ReactSharedInternals.H.useState(initialState);
		};
		react_production.useSyncExternalStore = function (
		  subscribe,
		  getSnapshot,
		  getServerSnapshot
		) {
		  return ReactSharedInternals.H.useSyncExternalStore(
		    subscribe,
		    getSnapshot,
		    getServerSnapshot
		  );
		};
		react_production.useTransition = function () {
		  return ReactSharedInternals.H.useTransition();
		};
		react_production.version = "19.1.0";
		return react_production;
	}

	var hasRequiredReact;

	function requireReact () {
		if (hasRequiredReact) return react.exports;
		hasRequiredReact = 1;

		{
		  react.exports = requireReact_production();
		}
		return react.exports;
	}

	var reactExports = requireReact();
	var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

	var React$1 = /*#__PURE__*/_mergeNamespaces({
		__proto__: null,
		default: React
	}, [reactExports]);

	var client = {exports: {}};

	var reactDomClient_production = {};

	var scheduler = {exports: {}};

	var scheduler_production = {};

	/**
	 * @license React
	 * scheduler.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredScheduler_production;

	function requireScheduler_production () {
		if (hasRequiredScheduler_production) return scheduler_production;
		hasRequiredScheduler_production = 1;
		(function (exports) {
			function push(heap, node) {
			  var index = heap.length;
			  heap.push(node);
			  a: for (; 0 < index; ) {
			    var parentIndex = (index - 1) >>> 1,
			      parent = heap[parentIndex];
			    if (0 < compare(parent, node))
			      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
			    else break a;
			  }
			}
			function peek(heap) {
			  return 0 === heap.length ? null : heap[0];
			}
			function pop(heap) {
			  if (0 === heap.length) return null;
			  var first = heap[0],
			    last = heap.pop();
			  if (last !== first) {
			    heap[0] = last;
			    a: for (
			      var index = 0, length = heap.length, halfLength = length >>> 1;
			      index < halfLength;

			    ) {
			      var leftIndex = 2 * (index + 1) - 1,
			        left = heap[leftIndex],
			        rightIndex = leftIndex + 1,
			        right = heap[rightIndex];
			      if (0 > compare(left, last))
			        rightIndex < length && 0 > compare(right, left)
			          ? ((heap[index] = right),
			            (heap[rightIndex] = last),
			            (index = rightIndex))
			          : ((heap[index] = left),
			            (heap[leftIndex] = last),
			            (index = leftIndex));
			      else if (rightIndex < length && 0 > compare(right, last))
			        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
			      else break a;
			    }
			  }
			  return first;
			}
			function compare(a, b) {
			  var diff = a.sortIndex - b.sortIndex;
			  return 0 !== diff ? diff : a.id - b.id;
			}
			exports.unstable_now = void 0;
			if ("object" === typeof performance && "function" === typeof performance.now) {
			  var localPerformance = performance;
			  exports.unstable_now = function () {
			    return localPerformance.now();
			  };
			} else {
			  var localDate = Date,
			    initialTime = localDate.now();
			  exports.unstable_now = function () {
			    return localDate.now() - initialTime;
			  };
			}
			var taskQueue = [],
			  timerQueue = [],
			  taskIdCounter = 1,
			  currentTask = null,
			  currentPriorityLevel = 3,
			  isPerformingWork = false,
			  isHostCallbackScheduled = false,
			  isHostTimeoutScheduled = false,
			  needsPaint = false,
			  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
			  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
			  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
			function advanceTimers(currentTime) {
			  for (var timer = peek(timerQueue); null !== timer; ) {
			    if (null === timer.callback) pop(timerQueue);
			    else if (timer.startTime <= currentTime)
			      pop(timerQueue),
			        (timer.sortIndex = timer.expirationTime),
			        push(taskQueue, timer);
			    else break;
			    timer = peek(timerQueue);
			  }
			}
			function handleTimeout(currentTime) {
			  isHostTimeoutScheduled = false;
			  advanceTimers(currentTime);
			  if (!isHostCallbackScheduled)
			    if (null !== peek(taskQueue))
			      (isHostCallbackScheduled = true),
			        isMessageLoopRunning ||
			          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
			    else {
			      var firstTimer = peek(timerQueue);
			      null !== firstTimer &&
			        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
			    }
			}
			var isMessageLoopRunning = false,
			  taskTimeoutID = -1,
			  frameInterval = 5,
			  startTime = -1;
			function shouldYieldToHost() {
			  return needsPaint
			    ? true
			    : exports.unstable_now() - startTime < frameInterval
			      ? false
			      : true;
			}
			function performWorkUntilDeadline() {
			  needsPaint = false;
			  if (isMessageLoopRunning) {
			    var currentTime = exports.unstable_now();
			    startTime = currentTime;
			    var hasMoreWork = true;
			    try {
			      a: {
			        isHostCallbackScheduled = !1;
			        isHostTimeoutScheduled &&
			          ((isHostTimeoutScheduled = !1),
			          localClearTimeout(taskTimeoutID),
			          (taskTimeoutID = -1));
			        isPerformingWork = !0;
			        var previousPriorityLevel = currentPriorityLevel;
			        try {
			          b: {
			            advanceTimers(currentTime);
			            for (
			              currentTask = peek(taskQueue);
			              null !== currentTask &&
			              !(
			                currentTask.expirationTime > currentTime && shouldYieldToHost()
			              );

			            ) {
			              var callback = currentTask.callback;
			              if ("function" === typeof callback) {
			                currentTask.callback = null;
			                currentPriorityLevel = currentTask.priorityLevel;
			                var continuationCallback = callback(
			                  currentTask.expirationTime <= currentTime
			                );
			                currentTime = exports.unstable_now();
			                if ("function" === typeof continuationCallback) {
			                  currentTask.callback = continuationCallback;
			                  advanceTimers(currentTime);
			                  hasMoreWork = !0;
			                  break b;
			                }
			                currentTask === peek(taskQueue) && pop(taskQueue);
			                advanceTimers(currentTime);
			              } else pop(taskQueue);
			              currentTask = peek(taskQueue);
			            }
			            if (null !== currentTask) hasMoreWork = !0;
			            else {
			              var firstTimer = peek(timerQueue);
			              null !== firstTimer &&
			                requestHostTimeout(
			                  handleTimeout,
			                  firstTimer.startTime - currentTime
			                );
			              hasMoreWork = !1;
			            }
			          }
			          break a;
			        } finally {
			          (currentTask = null),
			            (currentPriorityLevel = previousPriorityLevel),
			            (isPerformingWork = !1);
			        }
			        hasMoreWork = void 0;
			      }
			    } finally {
			      hasMoreWork
			        ? schedulePerformWorkUntilDeadline()
			        : (isMessageLoopRunning = false);
			    }
			  }
			}
			var schedulePerformWorkUntilDeadline;
			if ("function" === typeof localSetImmediate)
			  schedulePerformWorkUntilDeadline = function () {
			    localSetImmediate(performWorkUntilDeadline);
			  };
			else if ("undefined" !== typeof MessageChannel) {
			  var channel = new MessageChannel(),
			    port = channel.port2;
			  channel.port1.onmessage = performWorkUntilDeadline;
			  schedulePerformWorkUntilDeadline = function () {
			    port.postMessage(null);
			  };
			} else
			  schedulePerformWorkUntilDeadline = function () {
			    localSetTimeout(performWorkUntilDeadline, 0);
			  };
			function requestHostTimeout(callback, ms) {
			  taskTimeoutID = localSetTimeout(function () {
			    callback(exports.unstable_now());
			  }, ms);
			}
			exports.unstable_IdlePriority = 5;
			exports.unstable_ImmediatePriority = 1;
			exports.unstable_LowPriority = 4;
			exports.unstable_NormalPriority = 3;
			exports.unstable_Profiling = null;
			exports.unstable_UserBlockingPriority = 2;
			exports.unstable_cancelCallback = function (task) {
			  task.callback = null;
			};
			exports.unstable_forceFrameRate = function (fps) {
			  0 > fps || 125 < fps
			    ? console.error(
			        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
			      )
			    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
			};
			exports.unstable_getCurrentPriorityLevel = function () {
			  return currentPriorityLevel;
			};
			exports.unstable_next = function (eventHandler) {
			  switch (currentPriorityLevel) {
			    case 1:
			    case 2:
			    case 3:
			      var priorityLevel = 3;
			      break;
			    default:
			      priorityLevel = currentPriorityLevel;
			  }
			  var previousPriorityLevel = currentPriorityLevel;
			  currentPriorityLevel = priorityLevel;
			  try {
			    return eventHandler();
			  } finally {
			    currentPriorityLevel = previousPriorityLevel;
			  }
			};
			exports.unstable_requestPaint = function () {
			  needsPaint = true;
			};
			exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
			  switch (priorityLevel) {
			    case 1:
			    case 2:
			    case 3:
			    case 4:
			    case 5:
			      break;
			    default:
			      priorityLevel = 3;
			  }
			  var previousPriorityLevel = currentPriorityLevel;
			  currentPriorityLevel = priorityLevel;
			  try {
			    return eventHandler();
			  } finally {
			    currentPriorityLevel = previousPriorityLevel;
			  }
			};
			exports.unstable_scheduleCallback = function (
			  priorityLevel,
			  callback,
			  options
			) {
			  var currentTime = exports.unstable_now();
			  "object" === typeof options && null !== options
			    ? ((options = options.delay),
			      (options =
			        "number" === typeof options && 0 < options
			          ? currentTime + options
			          : currentTime))
			    : (options = currentTime);
			  switch (priorityLevel) {
			    case 1:
			      var timeout = -1;
			      break;
			    case 2:
			      timeout = 250;
			      break;
			    case 5:
			      timeout = 1073741823;
			      break;
			    case 4:
			      timeout = 1e4;
			      break;
			    default:
			      timeout = 5e3;
			  }
			  timeout = options + timeout;
			  priorityLevel = {
			    id: taskIdCounter++,
			    callback: callback,
			    priorityLevel: priorityLevel,
			    startTime: options,
			    expirationTime: timeout,
			    sortIndex: -1
			  };
			  options > currentTime
			    ? ((priorityLevel.sortIndex = options),
			      push(timerQueue, priorityLevel),
			      null === peek(taskQueue) &&
			        priorityLevel === peek(timerQueue) &&
			        (isHostTimeoutScheduled
			          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
			          : (isHostTimeoutScheduled = true),
			        requestHostTimeout(handleTimeout, options - currentTime)))
			    : ((priorityLevel.sortIndex = timeout),
			      push(taskQueue, priorityLevel),
			      isHostCallbackScheduled ||
			        isPerformingWork ||
			        ((isHostCallbackScheduled = true),
			        isMessageLoopRunning ||
			          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline())));
			  return priorityLevel;
			};
			exports.unstable_shouldYield = shouldYieldToHost;
			exports.unstable_wrapCallback = function (callback) {
			  var parentPriorityLevel = currentPriorityLevel;
			  return function () {
			    var previousPriorityLevel = currentPriorityLevel;
			    currentPriorityLevel = parentPriorityLevel;
			    try {
			      return callback.apply(this, arguments);
			    } finally {
			      currentPriorityLevel = previousPriorityLevel;
			    }
			  };
			}; 
		} (scheduler_production));
		return scheduler_production;
	}

	var hasRequiredScheduler;

	function requireScheduler () {
		if (hasRequiredScheduler) return scheduler.exports;
		hasRequiredScheduler = 1;

		{
		  scheduler.exports = requireScheduler_production();
		}
		return scheduler.exports;
	}

	var reactDom = {exports: {}};

	var reactDom_production = {};

	/**
	 * @license React
	 * react-dom.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactDom_production;

	function requireReactDom_production () {
		if (hasRequiredReactDom_production) return reactDom_production;
		hasRequiredReactDom_production = 1;
		var React = requireReact();
		function formatProdErrorMessage(code) {
		  var url = "https://react.dev/errors/" + code;
		  if (1 < arguments.length) {
		    url += "?args[]=" + encodeURIComponent(arguments[1]);
		    for (var i = 2; i < arguments.length; i++)
		      url += "&args[]=" + encodeURIComponent(arguments[i]);
		  }
		  return (
		    "Minified React error #" +
		    code +
		    "; visit " +
		    url +
		    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
		  );
		}
		function noop() {}
		var Internals = {
		    d: {
		      f: noop,
		      r: function () {
		        throw Error(formatProdErrorMessage(522));
		      },
		      D: noop,
		      C: noop,
		      L: noop,
		      m: noop,
		      X: noop,
		      S: noop,
		      M: noop
		    },
		    p: 0,
		    findDOMNode: null
		  },
		  REACT_PORTAL_TYPE = Symbol.for("react.portal");
		function createPortal$1(children, containerInfo, implementation) {
		  var key =
		    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		  return {
		    $$typeof: REACT_PORTAL_TYPE,
		    key: null == key ? null : "" + key,
		    children: children,
		    containerInfo: containerInfo,
		    implementation: implementation
		  };
		}
		var ReactSharedInternals =
		  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
		function getCrossOriginStringAs(as, input) {
		  if ("font" === as) return "";
		  if ("string" === typeof input)
		    return "use-credentials" === input ? input : "";
		}
		reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
		  Internals;
		reactDom_production.createPortal = function (children, container) {
		  var key =
		    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
		  if (
		    !container ||
		    (1 !== container.nodeType &&
		      9 !== container.nodeType &&
		      11 !== container.nodeType)
		  )
		    throw Error(formatProdErrorMessage(299));
		  return createPortal$1(children, container, null, key);
		};
		reactDom_production.flushSync = function (fn) {
		  var previousTransition = ReactSharedInternals.T,
		    previousUpdatePriority = Internals.p;
		  try {
		    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
		  } finally {
		    (ReactSharedInternals.T = previousTransition),
		      (Internals.p = previousUpdatePriority),
		      Internals.d.f();
		  }
		};
		reactDom_production.preconnect = function (href, options) {
		  "string" === typeof href &&
		    (options
		      ? ((options = options.crossOrigin),
		        (options =
		          "string" === typeof options
		            ? "use-credentials" === options
		              ? options
		              : ""
		            : void 0))
		      : (options = null),
		    Internals.d.C(href, options));
		};
		reactDom_production.prefetchDNS = function (href) {
		  "string" === typeof href && Internals.d.D(href);
		};
		reactDom_production.preinit = function (href, options) {
		  if ("string" === typeof href && options && "string" === typeof options.as) {
		    var as = options.as,
		      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
		      integrity =
		        "string" === typeof options.integrity ? options.integrity : void 0,
		      fetchPriority =
		        "string" === typeof options.fetchPriority
		          ? options.fetchPriority
		          : void 0;
		    "style" === as
		      ? Internals.d.S(
		          href,
		          "string" === typeof options.precedence ? options.precedence : void 0,
		          {
		            crossOrigin: crossOrigin,
		            integrity: integrity,
		            fetchPriority: fetchPriority
		          }
		        )
		      : "script" === as &&
		        Internals.d.X(href, {
		          crossOrigin: crossOrigin,
		          integrity: integrity,
		          fetchPriority: fetchPriority,
		          nonce: "string" === typeof options.nonce ? options.nonce : void 0
		        });
		  }
		};
		reactDom_production.preinitModule = function (href, options) {
		  if ("string" === typeof href)
		    if ("object" === typeof options && null !== options) {
		      if (null == options.as || "script" === options.as) {
		        var crossOrigin = getCrossOriginStringAs(
		          options.as,
		          options.crossOrigin
		        );
		        Internals.d.M(href, {
		          crossOrigin: crossOrigin,
		          integrity:
		            "string" === typeof options.integrity ? options.integrity : void 0,
		          nonce: "string" === typeof options.nonce ? options.nonce : void 0
		        });
		      }
		    } else null == options && Internals.d.M(href);
		};
		reactDom_production.preload = function (href, options) {
		  if (
		    "string" === typeof href &&
		    "object" === typeof options &&
		    null !== options &&
		    "string" === typeof options.as
		  ) {
		    var as = options.as,
		      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
		    Internals.d.L(href, as, {
		      crossOrigin: crossOrigin,
		      integrity:
		        "string" === typeof options.integrity ? options.integrity : void 0,
		      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
		      type: "string" === typeof options.type ? options.type : void 0,
		      fetchPriority:
		        "string" === typeof options.fetchPriority
		          ? options.fetchPriority
		          : void 0,
		      referrerPolicy:
		        "string" === typeof options.referrerPolicy
		          ? options.referrerPolicy
		          : void 0,
		      imageSrcSet:
		        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
		      imageSizes:
		        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
		      media: "string" === typeof options.media ? options.media : void 0
		    });
		  }
		};
		reactDom_production.preloadModule = function (href, options) {
		  if ("string" === typeof href)
		    if (options) {
		      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
		      Internals.d.m(href, {
		        as:
		          "string" === typeof options.as && "script" !== options.as
		            ? options.as
		            : void 0,
		        crossOrigin: crossOrigin,
		        integrity:
		          "string" === typeof options.integrity ? options.integrity : void 0
		      });
		    } else Internals.d.m(href);
		};
		reactDom_production.requestFormReset = function (form) {
		  Internals.d.r(form);
		};
		reactDom_production.unstable_batchedUpdates = function (fn, a) {
		  return fn(a);
		};
		reactDom_production.useFormState = function (action, initialState, permalink) {
		  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
		};
		reactDom_production.useFormStatus = function () {
		  return ReactSharedInternals.H.useHostTransitionStatus();
		};
		reactDom_production.version = "19.1.0";
		return reactDom_production;
	}

	var hasRequiredReactDom;

	function requireReactDom () {
		if (hasRequiredReactDom) return reactDom.exports;
		hasRequiredReactDom = 1;

		function checkDCE() {
		  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		  if (
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
		  ) {
		    return;
		  }
		  try {
		    // Verify that the code above has been dead code eliminated (DCE'd).
		    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		  } catch (err) {
		    // DevTools shouldn't crash React, no matter what.
		    // We should still report in case we break this code.
		    console.error(err);
		  }
		}

		{
		  // DCE check should happen before ReactDOM bundle executes so that
		  // DevTools can report bad minification during injection.
		  checkDCE();
		  reactDom.exports = requireReactDom_production();
		}
		return reactDom.exports;
	}

	/**
	 * @license React
	 * react-dom-client.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactDomClient_production;

	function requireReactDomClient_production () {
		if (hasRequiredReactDomClient_production) return reactDomClient_production;
		hasRequiredReactDomClient_production = 1;
		var Scheduler = requireScheduler(),
		  React = requireReact(),
		  ReactDOM = requireReactDom();
		function formatProdErrorMessage(code) {
		  var url = "https://react.dev/errors/" + code;
		  if (1 < arguments.length) {
		    url += "?args[]=" + encodeURIComponent(arguments[1]);
		    for (var i = 2; i < arguments.length; i++)
		      url += "&args[]=" + encodeURIComponent(arguments[i]);
		  }
		  return (
		    "Minified React error #" +
		    code +
		    "; visit " +
		    url +
		    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
		  );
		}
		function isValidContainer(node) {
		  return !(
		    !node ||
		    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
		  );
		}
		function getNearestMountedFiber(fiber) {
		  var node = fiber,
		    nearestMounted = fiber;
		  if (fiber.alternate) for (; node.return; ) node = node.return;
		  else {
		    fiber = node;
		    do
		      (node = fiber),
		        0 !== (node.flags & 4098) && (nearestMounted = node.return),
		        (fiber = node.return);
		    while (fiber);
		  }
		  return 3 === node.tag ? nearestMounted : null;
		}
		function getSuspenseInstanceFromFiber(fiber) {
		  if (13 === fiber.tag) {
		    var suspenseState = fiber.memoizedState;
		    null === suspenseState &&
		      ((fiber = fiber.alternate),
		      null !== fiber && (suspenseState = fiber.memoizedState));
		    if (null !== suspenseState) return suspenseState.dehydrated;
		  }
		  return null;
		}
		function assertIsMounted(fiber) {
		  if (getNearestMountedFiber(fiber) !== fiber)
		    throw Error(formatProdErrorMessage(188));
		}
		function findCurrentFiberUsingSlowPath(fiber) {
		  var alternate = fiber.alternate;
		  if (!alternate) {
		    alternate = getNearestMountedFiber(fiber);
		    if (null === alternate) throw Error(formatProdErrorMessage(188));
		    return alternate !== fiber ? null : fiber;
		  }
		  for (var a = fiber, b = alternate; ; ) {
		    var parentA = a.return;
		    if (null === parentA) break;
		    var parentB = parentA.alternate;
		    if (null === parentB) {
		      b = parentA.return;
		      if (null !== b) {
		        a = b;
		        continue;
		      }
		      break;
		    }
		    if (parentA.child === parentB.child) {
		      for (parentB = parentA.child; parentB; ) {
		        if (parentB === a) return assertIsMounted(parentA), fiber;
		        if (parentB === b) return assertIsMounted(parentA), alternate;
		        parentB = parentB.sibling;
		      }
		      throw Error(formatProdErrorMessage(188));
		    }
		    if (a.return !== b.return) (a = parentA), (b = parentB);
		    else {
		      for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
		        if (child$0 === a) {
		          didFindChild = true;
		          a = parentA;
		          b = parentB;
		          break;
		        }
		        if (child$0 === b) {
		          didFindChild = true;
		          b = parentA;
		          a = parentB;
		          break;
		        }
		        child$0 = child$0.sibling;
		      }
		      if (!didFindChild) {
		        for (child$0 = parentB.child; child$0; ) {
		          if (child$0 === a) {
		            didFindChild = true;
		            a = parentB;
		            b = parentA;
		            break;
		          }
		          if (child$0 === b) {
		            didFindChild = true;
		            b = parentB;
		            a = parentA;
		            break;
		          }
		          child$0 = child$0.sibling;
		        }
		        if (!didFindChild) throw Error(formatProdErrorMessage(189));
		      }
		    }
		    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
		  }
		  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
		  return a.stateNode.current === a ? fiber : alternate;
		}
		function findCurrentHostFiberImpl(node) {
		  var tag = node.tag;
		  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		  for (node = node.child; null !== node; ) {
		    tag = findCurrentHostFiberImpl(node);
		    if (null !== tag) return tag;
		    node = node.sibling;
		  }
		  return null;
		}
		var assign = Object.assign,
		  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
		  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
		  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
		  REACT_MEMO_TYPE = Symbol.for("react.memo"),
		  REACT_LAZY_TYPE = Symbol.for("react.lazy");
		var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
		var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
		var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
		function getIteratorFn(maybeIterable) {
		  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		  maybeIterable =
		    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		    maybeIterable["@@iterator"];
		  return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		function getComponentNameFromType(type) {
		  if (null == type) return null;
		  if ("function" === typeof type)
		    return type.$$typeof === REACT_CLIENT_REFERENCE
		      ? null
		      : type.displayName || type.name || null;
		  if ("string" === typeof type) return type;
		  switch (type) {
		    case REACT_FRAGMENT_TYPE:
		      return "Fragment";
		    case REACT_PROFILER_TYPE:
		      return "Profiler";
		    case REACT_STRICT_MODE_TYPE:
		      return "StrictMode";
		    case REACT_SUSPENSE_TYPE:
		      return "Suspense";
		    case REACT_SUSPENSE_LIST_TYPE:
		      return "SuspenseList";
		    case REACT_ACTIVITY_TYPE:
		      return "Activity";
		  }
		  if ("object" === typeof type)
		    switch (type.$$typeof) {
		      case REACT_PORTAL_TYPE:
		        return "Portal";
		      case REACT_CONTEXT_TYPE:
		        return (type.displayName || "Context") + ".Provider";
		      case REACT_CONSUMER_TYPE:
		        return (type._context.displayName || "Context") + ".Consumer";
		      case REACT_FORWARD_REF_TYPE:
		        var innerType = type.render;
		        type = type.displayName;
		        type ||
		          ((type = innerType.displayName || innerType.name || ""),
		          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
		        return type;
		      case REACT_MEMO_TYPE:
		        return (
		          (innerType = type.displayName || null),
		          null !== innerType
		            ? innerType
		            : getComponentNameFromType(type.type) || "Memo"
		        );
		      case REACT_LAZY_TYPE:
		        innerType = type._payload;
		        type = type._init;
		        try {
		          return getComponentNameFromType(type(innerType));
		        } catch (x) {}
		    }
		  return null;
		}
		var isArrayImpl = Array.isArray,
		  ReactSharedInternals =
		    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		  ReactDOMSharedInternals =
		    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		  sharedNotPendingObject = {
		    pending: false,
		    data: null,
		    method: null,
		    action: null
		  },
		  valueStack = [],
		  index = -1;
		function createCursor(defaultValue) {
		  return { current: defaultValue };
		}
		function pop(cursor) {
		  0 > index ||
		    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
		}
		function push(cursor, value) {
		  index++;
		  valueStack[index] = cursor.current;
		  cursor.current = value;
		}
		var contextStackCursor = createCursor(null),
		  contextFiberStackCursor = createCursor(null),
		  rootInstanceStackCursor = createCursor(null),
		  hostTransitionProviderCursor = createCursor(null);
		function pushHostContainer(fiber, nextRootInstance) {
		  push(rootInstanceStackCursor, nextRootInstance);
		  push(contextFiberStackCursor, fiber);
		  push(contextStackCursor, null);
		  switch (nextRootInstance.nodeType) {
		    case 9:
		    case 11:
		      fiber = (fiber = nextRootInstance.documentElement)
		        ? (fiber = fiber.namespaceURI)
		          ? getOwnHostContext(fiber)
		          : 0
		        : 0;
		      break;
		    default:
		      if (
		        ((fiber = nextRootInstance.tagName),
		        (nextRootInstance = nextRootInstance.namespaceURI))
		      )
		        (nextRootInstance = getOwnHostContext(nextRootInstance)),
		          (fiber = getChildHostContextProd(nextRootInstance, fiber));
		      else
		        switch (fiber) {
		          case "svg":
		            fiber = 1;
		            break;
		          case "math":
		            fiber = 2;
		            break;
		          default:
		            fiber = 0;
		        }
		  }
		  pop(contextStackCursor);
		  push(contextStackCursor, fiber);
		}
		function popHostContainer() {
		  pop(contextStackCursor);
		  pop(contextFiberStackCursor);
		  pop(rootInstanceStackCursor);
		}
		function pushHostContext(fiber) {
		  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
		  var context = contextStackCursor.current;
		  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
		  context !== JSCompiler_inline_result &&
		    (push(contextFiberStackCursor, fiber),
		    push(contextStackCursor, JSCompiler_inline_result));
		}
		function popHostContext(fiber) {
		  contextFiberStackCursor.current === fiber &&
		    (pop(contextStackCursor), pop(contextFiberStackCursor));
		  hostTransitionProviderCursor.current === fiber &&
		    (pop(hostTransitionProviderCursor),
		    (HostTransitionContext._currentValue = sharedNotPendingObject));
		}
		var hasOwnProperty = Object.prototype.hasOwnProperty,
		  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
		  cancelCallback$1 = Scheduler.unstable_cancelCallback,
		  shouldYield = Scheduler.unstable_shouldYield,
		  requestPaint = Scheduler.unstable_requestPaint,
		  now = Scheduler.unstable_now,
		  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
		  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
		  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
		  NormalPriority$1 = Scheduler.unstable_NormalPriority,
		  LowPriority = Scheduler.unstable_LowPriority,
		  IdlePriority = Scheduler.unstable_IdlePriority,
		  log$1 = Scheduler.log,
		  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
		  rendererID = null,
		  injectedHook = null;
		function setIsStrictModeForDevtools(newIsStrictMode) {
		  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
		  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
		    try {
		      injectedHook.setStrictMode(rendererID, newIsStrictMode);
		    } catch (err) {}
		}
		var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
		  log = Math.log,
		  LN2 = Math.LN2;
		function clz32Fallback(x) {
		  x >>>= 0;
		  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
		}
		var nextTransitionLane = 256,
		  nextRetryLane = 4194304;
		function getHighestPriorityLanes(lanes) {
		  var pendingSyncLanes = lanes & 42;
		  if (0 !== pendingSyncLanes) return pendingSyncLanes;
		  switch (lanes & -lanes) {
		    case 1:
		      return 1;
		    case 2:
		      return 2;
		    case 4:
		      return 4;
		    case 8:
		      return 8;
		    case 16:
		      return 16;
		    case 32:
		      return 32;
		    case 64:
		      return 64;
		    case 128:
		      return 128;
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		      return lanes & 4194048;
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      return lanes & 62914560;
		    case 67108864:
		      return 67108864;
		    case 134217728:
		      return 134217728;
		    case 268435456:
		      return 268435456;
		    case 536870912:
		      return 536870912;
		    case 1073741824:
		      return 0;
		    default:
		      return lanes;
		  }
		}
		function getNextLanes(root, wipLanes, rootHasPendingCommit) {
		  var pendingLanes = root.pendingLanes;
		  if (0 === pendingLanes) return 0;
		  var nextLanes = 0,
		    suspendedLanes = root.suspendedLanes,
		    pingedLanes = root.pingedLanes;
		  root = root.warmLanes;
		  var nonIdlePendingLanes = pendingLanes & 134217727;
		  0 !== nonIdlePendingLanes
		    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
		      0 !== pendingLanes
		        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
		        : ((pingedLanes &= nonIdlePendingLanes),
		          0 !== pingedLanes
		            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		            : rootHasPendingCommit ||
		              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
		              0 !== rootHasPendingCommit &&
		                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
		    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
		      0 !== nonIdlePendingLanes
		        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
		        : 0 !== pingedLanes
		          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		          : rootHasPendingCommit ||
		            ((rootHasPendingCommit = pendingLanes & ~root),
		            0 !== rootHasPendingCommit &&
		              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
		  return 0 === nextLanes
		    ? 0
		    : 0 !== wipLanes &&
		        wipLanes !== nextLanes &&
		        0 === (wipLanes & suspendedLanes) &&
		        ((suspendedLanes = nextLanes & -nextLanes),
		        (rootHasPendingCommit = wipLanes & -wipLanes),
		        suspendedLanes >= rootHasPendingCommit ||
		          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
		      ? wipLanes
		      : nextLanes;
		}
		function checkIfRootIsPrerendering(root, renderLanes) {
		  return (
		    0 ===
		    (root.pendingLanes &
		      ~(root.suspendedLanes & ~root.pingedLanes) &
		      renderLanes)
		  );
		}
		function computeExpirationTime(lane, currentTime) {
		  switch (lane) {
		    case 1:
		    case 2:
		    case 4:
		    case 8:
		    case 64:
		      return currentTime + 250;
		    case 16:
		    case 32:
		    case 128:
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		      return currentTime + 5e3;
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      return -1;
		    case 67108864:
		    case 134217728:
		    case 268435456:
		    case 536870912:
		    case 1073741824:
		      return -1;
		    default:
		      return -1;
		  }
		}
		function claimNextTransitionLane() {
		  var lane = nextTransitionLane;
		  nextTransitionLane <<= 1;
		  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
		  return lane;
		}
		function claimNextRetryLane() {
		  var lane = nextRetryLane;
		  nextRetryLane <<= 1;
		  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		  return lane;
		}
		function createLaneMap(initial) {
		  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		  return laneMap;
		}
		function markRootUpdated$1(root, updateLane) {
		  root.pendingLanes |= updateLane;
		  268435456 !== updateLane &&
		    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
		}
		function markRootFinished(
		  root,
		  finishedLanes,
		  remainingLanes,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes
		) {
		  var previouslyPendingLanes = root.pendingLanes;
		  root.pendingLanes = remainingLanes;
		  root.suspendedLanes = 0;
		  root.pingedLanes = 0;
		  root.warmLanes = 0;
		  root.expiredLanes &= remainingLanes;
		  root.entangledLanes &= remainingLanes;
		  root.errorRecoveryDisabledLanes &= remainingLanes;
		  root.shellSuspendCounter = 0;
		  var entanglements = root.entanglements,
		    expirationTimes = root.expirationTimes,
		    hiddenUpdates = root.hiddenUpdates;
		  for (
		    remainingLanes = previouslyPendingLanes & ~remainingLanes;
		    0 < remainingLanes;

		  ) {
		    var index$5 = 31 - clz32(remainingLanes),
		      lane = 1 << index$5;
		    entanglements[index$5] = 0;
		    expirationTimes[index$5] = -1;
		    var hiddenUpdatesForLane = hiddenUpdates[index$5];
		    if (null !== hiddenUpdatesForLane)
		      for (
		        hiddenUpdates[index$5] = null, index$5 = 0;
		        index$5 < hiddenUpdatesForLane.length;
		        index$5++
		      ) {
		        var update = hiddenUpdatesForLane[index$5];
		        null !== update && (update.lane &= -536870913);
		      }
		    remainingLanes &= ~lane;
		  }
		  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
		  0 !== suspendedRetryLanes &&
		    0 === updatedLanes &&
		    0 !== root.tag &&
		    (root.suspendedLanes |=
		      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
		}
		function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
		  root.pendingLanes |= spawnedLane;
		  root.suspendedLanes &= ~spawnedLane;
		  var spawnedLaneIndex = 31 - clz32(spawnedLane);
		  root.entangledLanes |= spawnedLane;
		  root.entanglements[spawnedLaneIndex] =
		    root.entanglements[spawnedLaneIndex] |
		    1073741824 |
		    (entangledLanes & 4194090);
		}
		function markRootEntangled(root, entangledLanes) {
		  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
		  for (root = root.entanglements; rootEntangledLanes; ) {
		    var index$6 = 31 - clz32(rootEntangledLanes),
		      lane = 1 << index$6;
		    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&
		      (root[index$6] |= entangledLanes);
		    rootEntangledLanes &= ~lane;
		  }
		}
		function getBumpedLaneForHydrationByLane(lane) {
		  switch (lane) {
		    case 2:
		      lane = 1;
		      break;
		    case 8:
		      lane = 4;
		      break;
		    case 32:
		      lane = 16;
		      break;
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      lane = 128;
		      break;
		    case 268435456:
		      lane = 134217728;
		      break;
		    default:
		      lane = 0;
		  }
		  return lane;
		}
		function lanesToEventPriority(lanes) {
		  lanes &= -lanes;
		  return 2 < lanes
		    ? 8 < lanes
		      ? 0 !== (lanes & 134217727)
		        ? 32
		        : 268435456
		      : 8
		    : 2;
		}
		function resolveUpdatePriority() {
		  var updatePriority = ReactDOMSharedInternals.p;
		  if (0 !== updatePriority) return updatePriority;
		  updatePriority = window.event;
		  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
		}
		function runWithPriority(priority, fn) {
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    return (ReactDOMSharedInternals.p = priority), fn();
		  } finally {
		    ReactDOMSharedInternals.p = previousPriority;
		  }
		}
		var randomKey = Math.random().toString(36).slice(2),
		  internalInstanceKey = "__reactFiber$" + randomKey,
		  internalPropsKey = "__reactProps$" + randomKey,
		  internalContainerInstanceKey = "__reactContainer$" + randomKey,
		  internalEventHandlersKey = "__reactEvents$" + randomKey,
		  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
		  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
		  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
		  internalHoistableMarker = "__reactMarker$" + randomKey;
		function detachDeletedInstance(node) {
		  delete node[internalInstanceKey];
		  delete node[internalPropsKey];
		  delete node[internalEventHandlersKey];
		  delete node[internalEventHandlerListenersKey];
		  delete node[internalEventHandlesSetKey];
		}
		function getClosestInstanceFromNode(targetNode) {
		  var targetInst = targetNode[internalInstanceKey];
		  if (targetInst) return targetInst;
		  for (var parentNode = targetNode.parentNode; parentNode; ) {
		    if (
		      (targetInst =
		        parentNode[internalContainerInstanceKey] ||
		        parentNode[internalInstanceKey])
		    ) {
		      parentNode = targetInst.alternate;
		      if (
		        null !== targetInst.child ||
		        (null !== parentNode && null !== parentNode.child)
		      )
		        for (
		          targetNode = getParentSuspenseInstance(targetNode);
		          null !== targetNode;

		        ) {
		          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
		          targetNode = getParentSuspenseInstance(targetNode);
		        }
		      return targetInst;
		    }
		    targetNode = parentNode;
		    parentNode = targetNode.parentNode;
		  }
		  return null;
		}
		function getInstanceFromNode(node) {
		  if (
		    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
		  ) {
		    var tag = node.tag;
		    if (
		      5 === tag ||
		      6 === tag ||
		      13 === tag ||
		      26 === tag ||
		      27 === tag ||
		      3 === tag
		    )
		      return node;
		  }
		  return null;
		}
		function getNodeFromInstance(inst) {
		  var tag = inst.tag;
		  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
		  throw Error(formatProdErrorMessage(33));
		}
		function getResourcesFromRoot(root) {
		  var resources = root[internalRootNodeResourcesKey];
		  resources ||
		    (resources = root[internalRootNodeResourcesKey] =
		      { hoistableStyles: new Map(), hoistableScripts: new Map() });
		  return resources;
		}
		function markNodeAsHoistable(node) {
		  node[internalHoistableMarker] = true;
		}
		var allNativeEvents = new Set(),
		  registrationNameDependencies = {};
		function registerTwoPhaseEvent(registrationName, dependencies) {
		  registerDirectEvent(registrationName, dependencies);
		  registerDirectEvent(registrationName + "Capture", dependencies);
		}
		function registerDirectEvent(registrationName, dependencies) {
		  registrationNameDependencies[registrationName] = dependencies;
		  for (
		    registrationName = 0;
		    registrationName < dependencies.length;
		    registrationName++
		  )
		    allNativeEvents.add(dependencies[registrationName]);
		}
		var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
		    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
		  ),
		  illegalAttributeNameCache = {},
		  validatedAttributeNameCache = {};
		function isAttributeNameSafe(attributeName) {
		  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
		    return true;
		  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
		  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
		    return (validatedAttributeNameCache[attributeName] = true);
		  illegalAttributeNameCache[attributeName] = true;
		  return false;
		}
		function setValueForAttribute(node, name, value) {
		  if (isAttributeNameSafe(name))
		    if (null === value) node.removeAttribute(name);
		    else {
		      switch (typeof value) {
		        case "undefined":
		        case "function":
		        case "symbol":
		          node.removeAttribute(name);
		          return;
		        case "boolean":
		          var prefix$8 = name.toLowerCase().slice(0, 5);
		          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
		            node.removeAttribute(name);
		            return;
		          }
		      }
		      node.setAttribute(name, "" + value);
		    }
		}
		function setValueForKnownAttribute(node, name, value) {
		  if (null === value) node.removeAttribute(name);
		  else {
		    switch (typeof value) {
		      case "undefined":
		      case "function":
		      case "symbol":
		      case "boolean":
		        node.removeAttribute(name);
		        return;
		    }
		    node.setAttribute(name, "" + value);
		  }
		}
		function setValueForNamespacedAttribute(node, namespace, name, value) {
		  if (null === value) node.removeAttribute(name);
		  else {
		    switch (typeof value) {
		      case "undefined":
		      case "function":
		      case "symbol":
		      case "boolean":
		        node.removeAttribute(name);
		        return;
		    }
		    node.setAttributeNS(namespace, name, "" + value);
		  }
		}
		var prefix, suffix;
		function describeBuiltInComponentFrame(name) {
		  if (void 0 === prefix)
		    try {
		      throw Error();
		    } catch (x) {
		      var match = x.stack.trim().match(/\n( *(at )?)/);
		      prefix = (match && match[1]) || "";
		      suffix =
		        -1 < x.stack.indexOf("\n    at")
		          ? " (<anonymous>)"
		          : -1 < x.stack.indexOf("@")
		            ? "@unknown:0:0"
		            : "";
		    }
		  return "\n" + prefix + name + suffix;
		}
		var reentry = false;
		function describeNativeComponentFrame(fn, construct) {
		  if (!fn || reentry) return "";
		  reentry = true;
		  var previousPrepareStackTrace = Error.prepareStackTrace;
		  Error.prepareStackTrace = void 0;
		  try {
		    var RunInRootFrame = {
		      DetermineComponentFrameRoot: function () {
		        try {
		          if (construct) {
		            var Fake = function () {
		              throw Error();
		            };
		            Object.defineProperty(Fake.prototype, "props", {
		              set: function () {
		                throw Error();
		              }
		            });
		            if ("object" === typeof Reflect && Reflect.construct) {
		              try {
		                Reflect.construct(Fake, []);
		              } catch (x) {
		                var control = x;
		              }
		              Reflect.construct(fn, [], Fake);
		            } else {
		              try {
		                Fake.call();
		              } catch (x$9) {
		                control = x$9;
		              }
		              fn.call(Fake.prototype);
		            }
		          } else {
		            try {
		              throw Error();
		            } catch (x$10) {
		              control = x$10;
		            }
		            (Fake = fn()) &&
		              "function" === typeof Fake.catch &&
		              Fake.catch(function () {});
		          }
		        } catch (sample) {
		          if (sample && control && "string" === typeof sample.stack)
		            return [sample.stack, control.stack];
		        }
		        return [null, null];
		      }
		    };
		    RunInRootFrame.DetermineComponentFrameRoot.displayName =
		      "DetermineComponentFrameRoot";
		    var namePropDescriptor = Object.getOwnPropertyDescriptor(
		      RunInRootFrame.DetermineComponentFrameRoot,
		      "name"
		    );
		    namePropDescriptor &&
		      namePropDescriptor.configurable &&
		      Object.defineProperty(
		        RunInRootFrame.DetermineComponentFrameRoot,
		        "name",
		        { value: "DetermineComponentFrameRoot" }
		      );
		    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
		      sampleStack = _RunInRootFrame$Deter[0],
		      controlStack = _RunInRootFrame$Deter[1];
		    if (sampleStack && controlStack) {
		      var sampleLines = sampleStack.split("\n"),
		        controlLines = controlStack.split("\n");
		      for (
		        namePropDescriptor = RunInRootFrame = 0;
		        RunInRootFrame < sampleLines.length &&
		        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

		      )
		        RunInRootFrame++;
		      for (
		        ;
		        namePropDescriptor < controlLines.length &&
		        !controlLines[namePropDescriptor].includes(
		          "DetermineComponentFrameRoot"
		        );

		      )
		        namePropDescriptor++;
		      if (
		        RunInRootFrame === sampleLines.length ||
		        namePropDescriptor === controlLines.length
		      )
		        for (
		          RunInRootFrame = sampleLines.length - 1,
		            namePropDescriptor = controlLines.length - 1;
		          1 <= RunInRootFrame &&
		          0 <= namePropDescriptor &&
		          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

		        )
		          namePropDescriptor--;
		      for (
		        ;
		        1 <= RunInRootFrame && 0 <= namePropDescriptor;
		        RunInRootFrame--, namePropDescriptor--
		      )
		        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
		          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
		            do
		              if (
		                (RunInRootFrame--,
		                namePropDescriptor--,
		                0 > namePropDescriptor ||
		                  sampleLines[RunInRootFrame] !==
		                    controlLines[namePropDescriptor])
		              ) {
		                var frame =
		                  "\n" +
		                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
		                fn.displayName &&
		                  frame.includes("<anonymous>") &&
		                  (frame = frame.replace("<anonymous>", fn.displayName));
		                return frame;
		              }
		            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
		          }
		          break;
		        }
		    }
		  } finally {
		    (reentry = false), (Error.prepareStackTrace = previousPrepareStackTrace);
		  }
		  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
		    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
		    : "";
		}
		function describeFiber(fiber) {
		  switch (fiber.tag) {
		    case 26:
		    case 27:
		    case 5:
		      return describeBuiltInComponentFrame(fiber.type);
		    case 16:
		      return describeBuiltInComponentFrame("Lazy");
		    case 13:
		      return describeBuiltInComponentFrame("Suspense");
		    case 19:
		      return describeBuiltInComponentFrame("SuspenseList");
		    case 0:
		    case 15:
		      return describeNativeComponentFrame(fiber.type, false);
		    case 11:
		      return describeNativeComponentFrame(fiber.type.render, false);
		    case 1:
		      return describeNativeComponentFrame(fiber.type, true);
		    case 31:
		      return describeBuiltInComponentFrame("Activity");
		    default:
		      return "";
		  }
		}
		function getStackByFiberInDevAndProd(workInProgress) {
		  try {
		    var info = "";
		    do
		      (info += describeFiber(workInProgress)),
		        (workInProgress = workInProgress.return);
		    while (workInProgress);
		    return info;
		  } catch (x) {
		    return "\nError generating stack: " + x.message + "\n" + x.stack;
		  }
		}
		function getToStringValue(value) {
		  switch (typeof value) {
		    case "bigint":
		    case "boolean":
		    case "number":
		    case "string":
		    case "undefined":
		      return value;
		    case "object":
		      return value;
		    default:
		      return "";
		  }
		}
		function isCheckable(elem) {
		  var type = elem.type;
		  return (
		    (elem = elem.nodeName) &&
		    "input" === elem.toLowerCase() &&
		    ("checkbox" === type || "radio" === type)
		  );
		}
		function trackValueOnNode(node) {
		  var valueField = isCheckable(node) ? "checked" : "value",
		    descriptor = Object.getOwnPropertyDescriptor(
		      node.constructor.prototype,
		      valueField
		    ),
		    currentValue = "" + node[valueField];
		  if (
		    !node.hasOwnProperty(valueField) &&
		    "undefined" !== typeof descriptor &&
		    "function" === typeof descriptor.get &&
		    "function" === typeof descriptor.set
		  ) {
		    var get = descriptor.get,
		      set = descriptor.set;
		    Object.defineProperty(node, valueField, {
		      configurable: true,
		      get: function () {
		        return get.call(this);
		      },
		      set: function (value) {
		        currentValue = "" + value;
		        set.call(this, value);
		      }
		    });
		    Object.defineProperty(node, valueField, {
		      enumerable: descriptor.enumerable
		    });
		    return {
		      getValue: function () {
		        return currentValue;
		      },
		      setValue: function (value) {
		        currentValue = "" + value;
		      },
		      stopTracking: function () {
		        node._valueTracker = null;
		        delete node[valueField];
		      }
		    };
		  }
		}
		function track(node) {
		  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
		}
		function updateValueIfChanged(node) {
		  if (!node) return false;
		  var tracker = node._valueTracker;
		  if (!tracker) return true;
		  var lastValue = tracker.getValue();
		  var value = "";
		  node &&
		    (value = isCheckable(node)
		      ? node.checked
		        ? "true"
		        : "false"
		      : node.value);
		  node = value;
		  return node !== lastValue ? (tracker.setValue(node), true) : false;
		}
		function getActiveElement(doc) {
		  doc = doc || ("undefined" !== typeof document ? document : void 0);
		  if ("undefined" === typeof doc) return null;
		  try {
		    return doc.activeElement || doc.body;
		  } catch (e) {
		    return doc.body;
		  }
		}
		var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
		function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
		  return value.replace(
		    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
		    function (ch) {
		      return "\\" + ch.charCodeAt(0).toString(16) + " ";
		    }
		  );
		}
		function updateInput(
		  element,
		  value,
		  defaultValue,
		  lastDefaultValue,
		  checked,
		  defaultChecked,
		  type,
		  name
		) {
		  element.name = "";
		  null != type &&
		  "function" !== typeof type &&
		  "symbol" !== typeof type &&
		  "boolean" !== typeof type
		    ? (element.type = type)
		    : element.removeAttribute("type");
		  if (null != value)
		    if ("number" === type) {
		      if ((0 === value && "" === element.value) || element.value != value)
		        element.value = "" + getToStringValue(value);
		    } else
		      element.value !== "" + getToStringValue(value) &&
		        (element.value = "" + getToStringValue(value));
		  else
		    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
		  null != value
		    ? setDefaultValue(element, type, getToStringValue(value))
		    : null != defaultValue
		      ? setDefaultValue(element, type, getToStringValue(defaultValue))
		      : null != lastDefaultValue && element.removeAttribute("value");
		  null == checked &&
		    null != defaultChecked &&
		    (element.defaultChecked = !!defaultChecked);
		  null != checked &&
		    (element.checked =
		      checked && "function" !== typeof checked && "symbol" !== typeof checked);
		  null != name &&
		  "function" !== typeof name &&
		  "symbol" !== typeof name &&
		  "boolean" !== typeof name
		    ? (element.name = "" + getToStringValue(name))
		    : element.removeAttribute("name");
		}
		function initInput(
		  element,
		  value,
		  defaultValue,
		  checked,
		  defaultChecked,
		  type,
		  name,
		  isHydrating
		) {
		  null != type &&
		    "function" !== typeof type &&
		    "symbol" !== typeof type &&
		    "boolean" !== typeof type &&
		    (element.type = type);
		  if (null != value || null != defaultValue) {
		    if (
		      !(
		        ("submit" !== type && "reset" !== type) ||
		        (void 0 !== value && null !== value)
		      )
		    )
		      return;
		    defaultValue =
		      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
		    value = null != value ? "" + getToStringValue(value) : defaultValue;
		    isHydrating || value === element.value || (element.value = value);
		    element.defaultValue = value;
		  }
		  checked = null != checked ? checked : defaultChecked;
		  checked =
		    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
		  element.checked = isHydrating ? element.checked : !!checked;
		  element.defaultChecked = !!checked;
		  null != name &&
		    "function" !== typeof name &&
		    "symbol" !== typeof name &&
		    "boolean" !== typeof name &&
		    (element.name = name);
		}
		function setDefaultValue(node, type, value) {
		  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
		    node.defaultValue === "" + value ||
		    (node.defaultValue = "" + value);
		}
		function updateOptions(node, multiple, propValue, setDefaultSelected) {
		  node = node.options;
		  if (multiple) {
		    multiple = {};
		    for (var i = 0; i < propValue.length; i++)
		      multiple["$" + propValue[i]] = true;
		    for (propValue = 0; propValue < node.length; propValue++)
		      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
		        node[propValue].selected !== i && (node[propValue].selected = i),
		        i && setDefaultSelected && (node[propValue].defaultSelected = true);
		  } else {
		    propValue = "" + getToStringValue(propValue);
		    multiple = null;
		    for (i = 0; i < node.length; i++) {
		      if (node[i].value === propValue) {
		        node[i].selected = true;
		        setDefaultSelected && (node[i].defaultSelected = true);
		        return;
		      }
		      null !== multiple || node[i].disabled || (multiple = node[i]);
		    }
		    null !== multiple && (multiple.selected = true);
		  }
		}
		function updateTextarea(element, value, defaultValue) {
		  if (
		    null != value &&
		    ((value = "" + getToStringValue(value)),
		    value !== element.value && (element.value = value),
		    null == defaultValue)
		  ) {
		    element.defaultValue !== value && (element.defaultValue = value);
		    return;
		  }
		  element.defaultValue =
		    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
		}
		function initTextarea(element, value, defaultValue, children) {
		  if (null == value) {
		    if (null != children) {
		      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
		      if (isArrayImpl(children)) {
		        if (1 < children.length) throw Error(formatProdErrorMessage(93));
		        children = children[0];
		      }
		      defaultValue = children;
		    }
		    null == defaultValue && (defaultValue = "");
		    value = defaultValue;
		  }
		  defaultValue = getToStringValue(value);
		  element.defaultValue = defaultValue;
		  children = element.textContent;
		  children === defaultValue &&
		    "" !== children &&
		    null !== children &&
		    (element.value = children);
		}
		function setTextContent(node, text) {
		  if (text) {
		    var firstChild = node.firstChild;
		    if (
		      firstChild &&
		      firstChild === node.lastChild &&
		      3 === firstChild.nodeType
		    ) {
		      firstChild.nodeValue = text;
		      return;
		    }
		  }
		  node.textContent = text;
		}
		var unitlessNumbers = new Set(
		  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
		    " "
		  )
		);
		function setValueForStyle(style, styleName, value) {
		  var isCustomProperty = 0 === styleName.indexOf("--");
		  null == value || "boolean" === typeof value || "" === value
		    ? isCustomProperty
		      ? style.setProperty(styleName, "")
		      : "float" === styleName
		        ? (style.cssFloat = "")
		        : (style[styleName] = "")
		    : isCustomProperty
		      ? style.setProperty(styleName, value)
		      : "number" !== typeof value ||
		          0 === value ||
		          unitlessNumbers.has(styleName)
		        ? "float" === styleName
		          ? (style.cssFloat = value)
		          : (style[styleName] = ("" + value).trim())
		        : (style[styleName] = value + "px");
		}
		function setValueForStyles(node, styles, prevStyles) {
		  if (null != styles && "object" !== typeof styles)
		    throw Error(formatProdErrorMessage(62));
		  node = node.style;
		  if (null != prevStyles) {
		    for (var styleName in prevStyles)
		      !prevStyles.hasOwnProperty(styleName) ||
		        (null != styles && styles.hasOwnProperty(styleName)) ||
		        (0 === styleName.indexOf("--")
		          ? node.setProperty(styleName, "")
		          : "float" === styleName
		            ? (node.cssFloat = "")
		            : (node[styleName] = ""));
		    for (var styleName$16 in styles)
		      (styleName = styles[styleName$16]),
		        styles.hasOwnProperty(styleName$16) &&
		          prevStyles[styleName$16] !== styleName &&
		          setValueForStyle(node, styleName$16, styleName);
		  } else
		    for (var styleName$17 in styles)
		      styles.hasOwnProperty(styleName$17) &&
		        setValueForStyle(node, styleName$17, styles[styleName$17]);
		}
		function isCustomElement(tagName) {
		  if (-1 === tagName.indexOf("-")) return false;
		  switch (tagName) {
		    case "annotation-xml":
		    case "color-profile":
		    case "font-face":
		    case "font-face-src":
		    case "font-face-uri":
		    case "font-face-format":
		    case "font-face-name":
		    case "missing-glyph":
		      return false;
		    default:
		      return true;
		  }
		}
		var aliases = new Map([
		    ["acceptCharset", "accept-charset"],
		    ["htmlFor", "for"],
		    ["httpEquiv", "http-equiv"],
		    ["crossOrigin", "crossorigin"],
		    ["accentHeight", "accent-height"],
		    ["alignmentBaseline", "alignment-baseline"],
		    ["arabicForm", "arabic-form"],
		    ["baselineShift", "baseline-shift"],
		    ["capHeight", "cap-height"],
		    ["clipPath", "clip-path"],
		    ["clipRule", "clip-rule"],
		    ["colorInterpolation", "color-interpolation"],
		    ["colorInterpolationFilters", "color-interpolation-filters"],
		    ["colorProfile", "color-profile"],
		    ["colorRendering", "color-rendering"],
		    ["dominantBaseline", "dominant-baseline"],
		    ["enableBackground", "enable-background"],
		    ["fillOpacity", "fill-opacity"],
		    ["fillRule", "fill-rule"],
		    ["floodColor", "flood-color"],
		    ["floodOpacity", "flood-opacity"],
		    ["fontFamily", "font-family"],
		    ["fontSize", "font-size"],
		    ["fontSizeAdjust", "font-size-adjust"],
		    ["fontStretch", "font-stretch"],
		    ["fontStyle", "font-style"],
		    ["fontVariant", "font-variant"],
		    ["fontWeight", "font-weight"],
		    ["glyphName", "glyph-name"],
		    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		    ["glyphOrientationVertical", "glyph-orientation-vertical"],
		    ["horizAdvX", "horiz-adv-x"],
		    ["horizOriginX", "horiz-origin-x"],
		    ["imageRendering", "image-rendering"],
		    ["letterSpacing", "letter-spacing"],
		    ["lightingColor", "lighting-color"],
		    ["markerEnd", "marker-end"],
		    ["markerMid", "marker-mid"],
		    ["markerStart", "marker-start"],
		    ["overlinePosition", "overline-position"],
		    ["overlineThickness", "overline-thickness"],
		    ["paintOrder", "paint-order"],
		    ["panose-1", "panose-1"],
		    ["pointerEvents", "pointer-events"],
		    ["renderingIntent", "rendering-intent"],
		    ["shapeRendering", "shape-rendering"],
		    ["stopColor", "stop-color"],
		    ["stopOpacity", "stop-opacity"],
		    ["strikethroughPosition", "strikethrough-position"],
		    ["strikethroughThickness", "strikethrough-thickness"],
		    ["strokeDasharray", "stroke-dasharray"],
		    ["strokeDashoffset", "stroke-dashoffset"],
		    ["strokeLinecap", "stroke-linecap"],
		    ["strokeLinejoin", "stroke-linejoin"],
		    ["strokeMiterlimit", "stroke-miterlimit"],
		    ["strokeOpacity", "stroke-opacity"],
		    ["strokeWidth", "stroke-width"],
		    ["textAnchor", "text-anchor"],
		    ["textDecoration", "text-decoration"],
		    ["textRendering", "text-rendering"],
		    ["transformOrigin", "transform-origin"],
		    ["underlinePosition", "underline-position"],
		    ["underlineThickness", "underline-thickness"],
		    ["unicodeBidi", "unicode-bidi"],
		    ["unicodeRange", "unicode-range"],
		    ["unitsPerEm", "units-per-em"],
		    ["vAlphabetic", "v-alphabetic"],
		    ["vHanging", "v-hanging"],
		    ["vIdeographic", "v-ideographic"],
		    ["vMathematical", "v-mathematical"],
		    ["vectorEffect", "vector-effect"],
		    ["vertAdvY", "vert-adv-y"],
		    ["vertOriginX", "vert-origin-x"],
		    ["vertOriginY", "vert-origin-y"],
		    ["wordSpacing", "word-spacing"],
		    ["writingMode", "writing-mode"],
		    ["xmlnsXlink", "xmlns:xlink"],
		    ["xHeight", "x-height"]
		  ]),
		  isJavaScriptProtocol =
		    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
		function sanitizeURL(url) {
		  return isJavaScriptProtocol.test("" + url)
		    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
		    : url;
		}
		var currentReplayingEvent = null;
		function getEventTarget(nativeEvent) {
		  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
		  nativeEvent.correspondingUseElement &&
		    (nativeEvent = nativeEvent.correspondingUseElement);
		  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
		}
		var restoreTarget = null,
		  restoreQueue = null;
		function restoreStateOfTarget(target) {
		  var internalInstance = getInstanceFromNode(target);
		  if (internalInstance && (target = internalInstance.stateNode)) {
		    var props = target[internalPropsKey] || null;
		    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
		      case "input":
		        updateInput(
		          target,
		          props.value,
		          props.defaultValue,
		          props.defaultValue,
		          props.checked,
		          props.defaultChecked,
		          props.type,
		          props.name
		        );
		        internalInstance = props.name;
		        if ("radio" === props.type && null != internalInstance) {
		          for (props = target; props.parentNode; ) props = props.parentNode;
		          props = props.querySelectorAll(
		            'input[name="' +
		              escapeSelectorAttributeValueInsideDoubleQuotes(
		                "" + internalInstance
		              ) +
		              '"][type="radio"]'
		          );
		          for (
		            internalInstance = 0;
		            internalInstance < props.length;
		            internalInstance++
		          ) {
		            var otherNode = props[internalInstance];
		            if (otherNode !== target && otherNode.form === target.form) {
		              var otherProps = otherNode[internalPropsKey] || null;
		              if (!otherProps) throw Error(formatProdErrorMessage(90));
		              updateInput(
		                otherNode,
		                otherProps.value,
		                otherProps.defaultValue,
		                otherProps.defaultValue,
		                otherProps.checked,
		                otherProps.defaultChecked,
		                otherProps.type,
		                otherProps.name
		              );
		            }
		          }
		          for (
		            internalInstance = 0;
		            internalInstance < props.length;
		            internalInstance++
		          )
		            (otherNode = props[internalInstance]),
		              otherNode.form === target.form && updateValueIfChanged(otherNode);
		        }
		        break a;
		      case "textarea":
		        updateTextarea(target, props.value, props.defaultValue);
		        break a;
		      case "select":
		        (internalInstance = props.value),
		          null != internalInstance &&
		            updateOptions(target, !!props.multiple, internalInstance, false);
		    }
		  }
		}
		var isInsideEventHandler = false;
		function batchedUpdates$1(fn, a, b) {
		  if (isInsideEventHandler) return fn(a, b);
		  isInsideEventHandler = true;
		  try {
		    var JSCompiler_inline_result = fn(a);
		    return JSCompiler_inline_result;
		  } finally {
		    if (
		      ((isInsideEventHandler = false),
		      null !== restoreTarget || null !== restoreQueue)
		    )
		      if (
		        (flushSyncWork$1(),
		        restoreTarget &&
		          ((a = restoreTarget),
		          (fn = restoreQueue),
		          (restoreQueue = restoreTarget = null),
		          restoreStateOfTarget(a),
		          fn))
		      )
		        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
		  }
		}
		function getListener(inst, registrationName) {
		  var stateNode = inst.stateNode;
		  if (null === stateNode) return null;
		  var props = stateNode[internalPropsKey] || null;
		  if (null === props) return null;
		  stateNode = props[registrationName];
		  a: switch (registrationName) {
		    case "onClick":
		    case "onClickCapture":
		    case "onDoubleClick":
		    case "onDoubleClickCapture":
		    case "onMouseDown":
		    case "onMouseDownCapture":
		    case "onMouseMove":
		    case "onMouseMoveCapture":
		    case "onMouseUp":
		    case "onMouseUpCapture":
		    case "onMouseEnter":
		      (props = !props.disabled) ||
		        ((inst = inst.type),
		        (props = !(
		          "button" === inst ||
		          "input" === inst ||
		          "select" === inst ||
		          "textarea" === inst
		        )));
		      inst = !props;
		      break a;
		    default:
		      inst = false;
		  }
		  if (inst) return null;
		  if (stateNode && "function" !== typeof stateNode)
		    throw Error(
		      formatProdErrorMessage(231, registrationName, typeof stateNode)
		    );
		  return stateNode;
		}
		var canUseDOM = !(
		    "undefined" === typeof window ||
		    "undefined" === typeof window.document ||
		    "undefined" === typeof window.document.createElement
		  ),
		  passiveBrowserEventsSupported = false;
		if (canUseDOM)
		  try {
		    var options = {};
		    Object.defineProperty(options, "passive", {
		      get: function () {
		        passiveBrowserEventsSupported = !0;
		      }
		    });
		    window.addEventListener("test", options, options);
		    window.removeEventListener("test", options, options);
		  } catch (e) {
		    passiveBrowserEventsSupported = false;
		  }
		var root = null,
		  startText = null,
		  fallbackText = null;
		function getData() {
		  if (fallbackText) return fallbackText;
		  var start,
		    startValue = startText,
		    startLength = startValue.length,
		    end,
		    endValue = "value" in root ? root.value : root.textContent,
		    endLength = endValue.length;
		  for (
		    start = 0;
		    start < startLength && startValue[start] === endValue[start];
		    start++
		  );
		  var minEnd = startLength - start;
		  for (
		    end = 1;
		    end <= minEnd &&
		    startValue[startLength - end] === endValue[endLength - end];
		    end++
		  );
		  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
		}
		function getEventCharCode(nativeEvent) {
		  var keyCode = nativeEvent.keyCode;
		  "charCode" in nativeEvent
		    ? ((nativeEvent = nativeEvent.charCode),
		      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
		    : (nativeEvent = keyCode);
		  10 === nativeEvent && (nativeEvent = 13);
		  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
		}
		function functionThatReturnsTrue() {
		  return true;
		}
		function functionThatReturnsFalse() {
		  return false;
		}
		function createSyntheticEvent(Interface) {
		  function SyntheticBaseEvent(
		    reactName,
		    reactEventType,
		    targetInst,
		    nativeEvent,
		    nativeEventTarget
		  ) {
		    this._reactName = reactName;
		    this._targetInst = targetInst;
		    this.type = reactEventType;
		    this.nativeEvent = nativeEvent;
		    this.target = nativeEventTarget;
		    this.currentTarget = null;
		    for (var propName in Interface)
		      Interface.hasOwnProperty(propName) &&
		        ((reactName = Interface[propName]),
		        (this[propName] = reactName
		          ? reactName(nativeEvent)
		          : nativeEvent[propName]));
		    this.isDefaultPrevented = (
		      null != nativeEvent.defaultPrevented
		        ? nativeEvent.defaultPrevented
		        : false === nativeEvent.returnValue
		    )
		      ? functionThatReturnsTrue
		      : functionThatReturnsFalse;
		    this.isPropagationStopped = functionThatReturnsFalse;
		    return this;
		  }
		  assign(SyntheticBaseEvent.prototype, {
		    preventDefault: function () {
		      this.defaultPrevented = true;
		      var event = this.nativeEvent;
		      event &&
		        (event.preventDefault
		          ? event.preventDefault()
		          : "unknown" !== typeof event.returnValue && (event.returnValue = false),
		        (this.isDefaultPrevented = functionThatReturnsTrue));
		    },
		    stopPropagation: function () {
		      var event = this.nativeEvent;
		      event &&
		        (event.stopPropagation
		          ? event.stopPropagation()
		          : "unknown" !== typeof event.cancelBubble &&
		            (event.cancelBubble = true),
		        (this.isPropagationStopped = functionThatReturnsTrue));
		    },
		    persist: function () {},
		    isPersistent: functionThatReturnsTrue
		  });
		  return SyntheticBaseEvent;
		}
		var EventInterface = {
		    eventPhase: 0,
		    bubbles: 0,
		    cancelable: 0,
		    timeStamp: function (event) {
		      return event.timeStamp || Date.now();
		    },
		    defaultPrevented: 0,
		    isTrusted: 0
		  },
		  SyntheticEvent = createSyntheticEvent(EventInterface),
		  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
		  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
		  lastMovementX,
		  lastMovementY,
		  lastMouseEvent,
		  MouseEventInterface = assign({}, UIEventInterface, {
		    screenX: 0,
		    screenY: 0,
		    clientX: 0,
		    clientY: 0,
		    pageX: 0,
		    pageY: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    altKey: 0,
		    metaKey: 0,
		    getModifierState: getEventModifierState,
		    button: 0,
		    buttons: 0,
		    relatedTarget: function (event) {
		      return void 0 === event.relatedTarget
		        ? event.fromElement === event.srcElement
		          ? event.toElement
		          : event.fromElement
		        : event.relatedTarget;
		    },
		    movementX: function (event) {
		      if ("movementX" in event) return event.movementX;
		      event !== lastMouseEvent &&
		        (lastMouseEvent && "mousemove" === event.type
		          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
		            (lastMovementY = event.screenY - lastMouseEvent.screenY))
		          : (lastMovementY = lastMovementX = 0),
		        (lastMouseEvent = event));
		      return lastMovementX;
		    },
		    movementY: function (event) {
		      return "movementY" in event ? event.movementY : lastMovementY;
		    }
		  }),
		  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
		  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
		  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
		  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
		  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
		  AnimationEventInterface = assign({}, EventInterface, {
		    animationName: 0,
		    elapsedTime: 0,
		    pseudoElement: 0
		  }),
		  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
		  ClipboardEventInterface = assign({}, EventInterface, {
		    clipboardData: function (event) {
		      return "clipboardData" in event
		        ? event.clipboardData
		        : window.clipboardData;
		    }
		  }),
		  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
		  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
		  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
		  normalizeKey = {
		    Esc: "Escape",
		    Spacebar: " ",
		    Left: "ArrowLeft",
		    Up: "ArrowUp",
		    Right: "ArrowRight",
		    Down: "ArrowDown",
		    Del: "Delete",
		    Win: "OS",
		    Menu: "ContextMenu",
		    Apps: "ContextMenu",
		    Scroll: "ScrollLock",
		    MozPrintableKey: "Unidentified"
		  },
		  translateToKey = {
		    8: "Backspace",
		    9: "Tab",
		    12: "Clear",
		    13: "Enter",
		    16: "Shift",
		    17: "Control",
		    18: "Alt",
		    19: "Pause",
		    20: "CapsLock",
		    27: "Escape",
		    32: " ",
		    33: "PageUp",
		    34: "PageDown",
		    35: "End",
		    36: "Home",
		    37: "ArrowLeft",
		    38: "ArrowUp",
		    39: "ArrowRight",
		    40: "ArrowDown",
		    45: "Insert",
		    46: "Delete",
		    112: "F1",
		    113: "F2",
		    114: "F3",
		    115: "F4",
		    116: "F5",
		    117: "F6",
		    118: "F7",
		    119: "F8",
		    120: "F9",
		    121: "F10",
		    122: "F11",
		    123: "F12",
		    144: "NumLock",
		    145: "ScrollLock",
		    224: "Meta"
		  },
		  modifierKeyToProp = {
		    Alt: "altKey",
		    Control: "ctrlKey",
		    Meta: "metaKey",
		    Shift: "shiftKey"
		  };
		function modifierStateGetter(keyArg) {
		  var nativeEvent = this.nativeEvent;
		  return nativeEvent.getModifierState
		    ? nativeEvent.getModifierState(keyArg)
		    : (keyArg = modifierKeyToProp[keyArg])
		      ? !!nativeEvent[keyArg]
		      : false;
		}
		function getEventModifierState() {
		  return modifierStateGetter;
		}
		var KeyboardEventInterface = assign({}, UIEventInterface, {
		    key: function (nativeEvent) {
		      if (nativeEvent.key) {
		        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
		        if ("Unidentified" !== key) return key;
		      }
		      return "keypress" === nativeEvent.type
		        ? ((nativeEvent = getEventCharCode(nativeEvent)),
		          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
		        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
		          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
		          : "";
		    },
		    code: 0,
		    location: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    altKey: 0,
		    metaKey: 0,
		    repeat: 0,
		    locale: 0,
		    getModifierState: getEventModifierState,
		    charCode: function (event) {
		      return "keypress" === event.type ? getEventCharCode(event) : 0;
		    },
		    keyCode: function (event) {
		      return "keydown" === event.type || "keyup" === event.type
		        ? event.keyCode
		        : 0;
		    },
		    which: function (event) {
		      return "keypress" === event.type
		        ? getEventCharCode(event)
		        : "keydown" === event.type || "keyup" === event.type
		          ? event.keyCode
		          : 0;
		    }
		  }),
		  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
		  PointerEventInterface = assign({}, MouseEventInterface, {
		    pointerId: 0,
		    width: 0,
		    height: 0,
		    pressure: 0,
		    tangentialPressure: 0,
		    tiltX: 0,
		    tiltY: 0,
		    twist: 0,
		    pointerType: 0,
		    isPrimary: 0
		  }),
		  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
		  TouchEventInterface = assign({}, UIEventInterface, {
		    touches: 0,
		    targetTouches: 0,
		    changedTouches: 0,
		    altKey: 0,
		    metaKey: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    getModifierState: getEventModifierState
		  }),
		  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
		  TransitionEventInterface = assign({}, EventInterface, {
		    propertyName: 0,
		    elapsedTime: 0,
		    pseudoElement: 0
		  }),
		  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
		  WheelEventInterface = assign({}, MouseEventInterface, {
		    deltaX: function (event) {
		      return "deltaX" in event
		        ? event.deltaX
		        : "wheelDeltaX" in event
		          ? -event.wheelDeltaX
		          : 0;
		    },
		    deltaY: function (event) {
		      return "deltaY" in event
		        ? event.deltaY
		        : "wheelDeltaY" in event
		          ? -event.wheelDeltaY
		          : "wheelDelta" in event
		            ? -event.wheelDelta
		            : 0;
		    },
		    deltaZ: 0,
		    deltaMode: 0
		  }),
		  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
		  ToggleEventInterface = assign({}, EventInterface, {
		    newState: 0,
		    oldState: 0
		  }),
		  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
		  END_KEYCODES = [9, 13, 27, 32],
		  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
		  documentMode = null;
		canUseDOM &&
		  "documentMode" in document &&
		  (documentMode = document.documentMode);
		var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
		  useFallbackCompositionData =
		    canUseDOM &&
		    (!canUseCompositionEvent ||
		      (documentMode && 8 < documentMode && 11 >= documentMode)),
		  SPACEBAR_CHAR = String.fromCharCode(32),
		  hasSpaceKeypress = false;
		function isFallbackCompositionEnd(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "keyup":
		      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
		    case "keydown":
		      return 229 !== nativeEvent.keyCode;
		    case "keypress":
		    case "mousedown":
		    case "focusout":
		      return true;
		    default:
		      return false;
		  }
		}
		function getDataFromCustomEvent(nativeEvent) {
		  nativeEvent = nativeEvent.detail;
		  return "object" === typeof nativeEvent && "data" in nativeEvent
		    ? nativeEvent.data
		    : null;
		}
		var isComposing = false;
		function getNativeBeforeInputChars(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "compositionend":
		      return getDataFromCustomEvent(nativeEvent);
		    case "keypress":
		      if (32 !== nativeEvent.which) return null;
		      hasSpaceKeypress = true;
		      return SPACEBAR_CHAR;
		    case "textInput":
		      return (
		        (domEventName = nativeEvent.data),
		        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
		      );
		    default:
		      return null;
		  }
		}
		function getFallbackBeforeInputChars(domEventName, nativeEvent) {
		  if (isComposing)
		    return "compositionend" === domEventName ||
		      (!canUseCompositionEvent &&
		        isFallbackCompositionEnd(domEventName, nativeEvent))
		      ? ((domEventName = getData()),
		        (fallbackText = startText = root = null),
		        (isComposing = false),
		        domEventName)
		      : null;
		  switch (domEventName) {
		    case "paste":
		      return null;
		    case "keypress":
		      if (
		        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
		        (nativeEvent.ctrlKey && nativeEvent.altKey)
		      ) {
		        if (nativeEvent.char && 1 < nativeEvent.char.length)
		          return nativeEvent.char;
		        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
		      }
		      return null;
		    case "compositionend":
		      return useFallbackCompositionData && "ko" !== nativeEvent.locale
		        ? null
		        : nativeEvent.data;
		    default:
		      return null;
		  }
		}
		var supportedInputTypes = {
		  color: true,
		  date: true,
		  datetime: true,
		  "datetime-local": true,
		  email: true,
		  month: true,
		  number: true,
		  password: true,
		  range: true,
		  search: true,
		  tel: true,
		  text: true,
		  time: true,
		  url: true,
		  week: true
		};
		function isTextInputElement(elem) {
		  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		  return "input" === nodeName
		    ? !!supportedInputTypes[elem.type]
		    : "textarea" === nodeName
		      ? true
		      : false;
		}
		function createAndAccumulateChangeEvent(
		  dispatchQueue,
		  inst,
		  nativeEvent,
		  target
		) {
		  restoreTarget
		    ? restoreQueue
		      ? restoreQueue.push(target)
		      : (restoreQueue = [target])
		    : (restoreTarget = target);
		  inst = accumulateTwoPhaseListeners(inst, "onChange");
		  0 < inst.length &&
		    ((nativeEvent = new SyntheticEvent(
		      "onChange",
		      "change",
		      null,
		      nativeEvent,
		      target
		    )),
		    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
		}
		var activeElement$1 = null,
		  activeElementInst$1 = null;
		function runEventInBatch(dispatchQueue) {
		  processDispatchQueue(dispatchQueue, 0);
		}
		function getInstIfValueChanged(targetInst) {
		  var targetNode = getNodeFromInstance(targetInst);
		  if (updateValueIfChanged(targetNode)) return targetInst;
		}
		function getTargetInstForChangeEvent(domEventName, targetInst) {
		  if ("change" === domEventName) return targetInst;
		}
		var isInputEventSupported = false;
		if (canUseDOM) {
		  var JSCompiler_inline_result$jscomp$282;
		  if (canUseDOM) {
		    var isSupported$jscomp$inline_417 = "oninput" in document;
		    if (!isSupported$jscomp$inline_417) {
		      var element$jscomp$inline_418 = document.createElement("div");
		      element$jscomp$inline_418.setAttribute("oninput", "return;");
		      isSupported$jscomp$inline_417 =
		        "function" === typeof element$jscomp$inline_418.oninput;
		    }
		    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
		  } else JSCompiler_inline_result$jscomp$282 = false;
		  isInputEventSupported =
		    JSCompiler_inline_result$jscomp$282 &&
		    (!document.documentMode || 9 < document.documentMode);
		}
		function stopWatchingForValueChange() {
		  activeElement$1 &&
		    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
		    (activeElementInst$1 = activeElement$1 = null));
		}
		function handlePropertyChange(nativeEvent) {
		  if (
		    "value" === nativeEvent.propertyName &&
		    getInstIfValueChanged(activeElementInst$1)
		  ) {
		    var dispatchQueue = [];
		    createAndAccumulateChangeEvent(
		      dispatchQueue,
		      activeElementInst$1,
		      nativeEvent,
		      getEventTarget(nativeEvent)
		    );
		    batchedUpdates$1(runEventInBatch, dispatchQueue);
		  }
		}
		function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
		  "focusin" === domEventName
		    ? (stopWatchingForValueChange(),
		      (activeElement$1 = target),
		      (activeElementInst$1 = targetInst),
		      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
		    : "focusout" === domEventName && stopWatchingForValueChange();
		}
		function getTargetInstForInputEventPolyfill(domEventName) {
		  if (
		    "selectionchange" === domEventName ||
		    "keyup" === domEventName ||
		    "keydown" === domEventName
		  )
		    return getInstIfValueChanged(activeElementInst$1);
		}
		function getTargetInstForClickEvent(domEventName, targetInst) {
		  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
		}
		function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
		  if ("input" === domEventName || "change" === domEventName)
		    return getInstIfValueChanged(targetInst);
		}
		function is(x, y) {
		  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
		}
		var objectIs = "function" === typeof Object.is ? Object.is : is;
		function shallowEqual(objA, objB) {
		  if (objectIs(objA, objB)) return true;
		  if (
		    "object" !== typeof objA ||
		    null === objA ||
		    "object" !== typeof objB ||
		    null === objB
		  )
		    return false;
		  var keysA = Object.keys(objA),
		    keysB = Object.keys(objB);
		  if (keysA.length !== keysB.length) return false;
		  for (keysB = 0; keysB < keysA.length; keysB++) {
		    var currentKey = keysA[keysB];
		    if (
		      !hasOwnProperty.call(objB, currentKey) ||
		      !objectIs(objA[currentKey], objB[currentKey])
		    )
		      return false;
		  }
		  return true;
		}
		function getLeafNode(node) {
		  for (; node && node.firstChild; ) node = node.firstChild;
		  return node;
		}
		function getNodeForCharacterOffset(root, offset) {
		  var node = getLeafNode(root);
		  root = 0;
		  for (var nodeEnd; node; ) {
		    if (3 === node.nodeType) {
		      nodeEnd = root + node.textContent.length;
		      if (root <= offset && nodeEnd >= offset)
		        return { node: node, offset: offset - root };
		      root = nodeEnd;
		    }
		    a: {
		      for (; node; ) {
		        if (node.nextSibling) {
		          node = node.nextSibling;
		          break a;
		        }
		        node = node.parentNode;
		      }
		      node = void 0;
		    }
		    node = getLeafNode(node);
		  }
		}
		function containsNode(outerNode, innerNode) {
		  return outerNode && innerNode
		    ? outerNode === innerNode
		      ? true
		      : outerNode && 3 === outerNode.nodeType
		        ? false
		        : innerNode && 3 === innerNode.nodeType
		          ? containsNode(outerNode, innerNode.parentNode)
		          : "contains" in outerNode
		            ? outerNode.contains(innerNode)
		            : outerNode.compareDocumentPosition
		              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
		              : false
		    : false;
		}
		function getActiveElementDeep(containerInfo) {
		  containerInfo =
		    null != containerInfo &&
		    null != containerInfo.ownerDocument &&
		    null != containerInfo.ownerDocument.defaultView
		      ? containerInfo.ownerDocument.defaultView
		      : window;
		  for (
		    var element = getActiveElement(containerInfo.document);
		    element instanceof containerInfo.HTMLIFrameElement;

		  ) {
		    try {
		      var JSCompiler_inline_result =
		        "string" === typeof element.contentWindow.location.href;
		    } catch (err) {
		      JSCompiler_inline_result = false;
		    }
		    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
		    else break;
		    element = getActiveElement(containerInfo.document);
		  }
		  return element;
		}
		function hasSelectionCapabilities(elem) {
		  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		  return (
		    nodeName &&
		    (("input" === nodeName &&
		      ("text" === elem.type ||
		        "search" === elem.type ||
		        "tel" === elem.type ||
		        "url" === elem.type ||
		        "password" === elem.type)) ||
		      "textarea" === nodeName ||
		      "true" === elem.contentEditable)
		  );
		}
		var skipSelectionChangeEvent =
		    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
		  activeElement = null,
		  activeElementInst = null,
		  lastSelection = null,
		  mouseDown = false;
		function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
		  var doc =
		    nativeEventTarget.window === nativeEventTarget
		      ? nativeEventTarget.document
		      : 9 === nativeEventTarget.nodeType
		        ? nativeEventTarget
		        : nativeEventTarget.ownerDocument;
		  mouseDown ||
		    null == activeElement ||
		    activeElement !== getActiveElement(doc) ||
		    ((doc = activeElement),
		    "selectionStart" in doc && hasSelectionCapabilities(doc)
		      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
		      : ((doc = (
		          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
		          window
		        ).getSelection()),
		        (doc = {
		          anchorNode: doc.anchorNode,
		          anchorOffset: doc.anchorOffset,
		          focusNode: doc.focusNode,
		          focusOffset: doc.focusOffset
		        })),
		    (lastSelection && shallowEqual(lastSelection, doc)) ||
		      ((lastSelection = doc),
		      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
		      0 < doc.length &&
		        ((nativeEvent = new SyntheticEvent(
		          "onSelect",
		          "select",
		          null,
		          nativeEvent,
		          nativeEventTarget
		        )),
		        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
		        (nativeEvent.target = activeElement))));
		}
		function makePrefixMap(styleProp, eventName) {
		  var prefixes = {};
		  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
		  prefixes["Webkit" + styleProp] = "webkit" + eventName;
		  prefixes["Moz" + styleProp] = "moz" + eventName;
		  return prefixes;
		}
		var vendorPrefixes = {
		    animationend: makePrefixMap("Animation", "AnimationEnd"),
		    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
		    animationstart: makePrefixMap("Animation", "AnimationStart"),
		    transitionrun: makePrefixMap("Transition", "TransitionRun"),
		    transitionstart: makePrefixMap("Transition", "TransitionStart"),
		    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
		    transitionend: makePrefixMap("Transition", "TransitionEnd")
		  },
		  prefixedEventNames = {},
		  style = {};
		canUseDOM &&
		  ((style = document.createElement("div").style),
		  "AnimationEvent" in window ||
		    (delete vendorPrefixes.animationend.animation,
		    delete vendorPrefixes.animationiteration.animation,
		    delete vendorPrefixes.animationstart.animation),
		  "TransitionEvent" in window ||
		    delete vendorPrefixes.transitionend.transition);
		function getVendorPrefixedEventName(eventName) {
		  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
		  if (!vendorPrefixes[eventName]) return eventName;
		  var prefixMap = vendorPrefixes[eventName],
		    styleProp;
		  for (styleProp in prefixMap)
		    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
		      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
		  return eventName;
		}
		var ANIMATION_END = getVendorPrefixedEventName("animationend"),
		  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
		  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
		  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
		  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
		  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
		  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
		  topLevelEventsToReactNames = new Map(),
		  simpleEventPluginEvents =
		    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
		      " "
		    );
		simpleEventPluginEvents.push("scrollEnd");
		function registerSimpleEvent(domEventName, reactName) {
		  topLevelEventsToReactNames.set(domEventName, reactName);
		  registerTwoPhaseEvent(reactName, [domEventName]);
		}
		var CapturedStacks = new WeakMap();
		function createCapturedValueAtFiber(value, source) {
		  if ("object" === typeof value && null !== value) {
		    var existing = CapturedStacks.get(value);
		    if (void 0 !== existing) return existing;
		    source = {
		      value: value,
		      source: source,
		      stack: getStackByFiberInDevAndProd(source)
		    };
		    CapturedStacks.set(value, source);
		    return source;
		  }
		  return {
		    value: value,
		    source: source,
		    stack: getStackByFiberInDevAndProd(source)
		  };
		}
		var concurrentQueues = [],
		  concurrentQueuesIndex = 0,
		  concurrentlyUpdatedLanes = 0;
		function finishQueueingConcurrentUpdates() {
		  for (
		    var endIndex = concurrentQueuesIndex,
		      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
		    i < endIndex;

		  ) {
		    var fiber = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var queue = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var update = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var lane = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    if (null !== queue && null !== update) {
		      var pending = queue.pending;
		      null === pending
		        ? (update.next = update)
		        : ((update.next = pending.next), (pending.next = update));
		      queue.pending = update;
		    }
		    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		  }
		}
		function enqueueUpdate$1(fiber, queue, update, lane) {
		  concurrentQueues[concurrentQueuesIndex++] = fiber;
		  concurrentQueues[concurrentQueuesIndex++] = queue;
		  concurrentQueues[concurrentQueuesIndex++] = update;
		  concurrentQueues[concurrentQueuesIndex++] = lane;
		  concurrentlyUpdatedLanes |= lane;
		  fiber.lanes |= lane;
		  fiber = fiber.alternate;
		  null !== fiber && (fiber.lanes |= lane);
		}
		function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		  enqueueUpdate$1(fiber, queue, update, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function enqueueConcurrentRenderForLane(fiber, lane) {
		  enqueueUpdate$1(fiber, null, null, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		  sourceFiber.lanes |= lane;
		  var alternate = sourceFiber.alternate;
		  null !== alternate && (alternate.lanes |= lane);
		  for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
		    (parent.childLanes |= lane),
		      (alternate = parent.alternate),
		      null !== alternate && (alternate.childLanes |= lane),
		      22 === parent.tag &&
		        ((sourceFiber = parent.stateNode),
		        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)),
		      (sourceFiber = parent),
		      (parent = parent.return);
		  return 3 === sourceFiber.tag
		    ? ((parent = sourceFiber.stateNode),
		      isHidden &&
		        null !== update &&
		        ((isHidden = 31 - clz32(lane)),
		        (sourceFiber = parent.hiddenUpdates),
		        (alternate = sourceFiber[isHidden]),
		        null === alternate
		          ? (sourceFiber[isHidden] = [update])
		          : alternate.push(update),
		        (update.lane = lane | 536870912)),
		      parent)
		    : null;
		}
		function getRootForUpdatedFiber(sourceFiber) {
		  if (50 < nestedUpdateCount)
		    throw (
		      ((nestedUpdateCount = 0),
		      (rootWithNestedUpdates = null),
		      Error(formatProdErrorMessage(185)))
		    );
		  for (var parent = sourceFiber.return; null !== parent; )
		    (sourceFiber = parent), (parent = sourceFiber.return);
		  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
		}
		var emptyContextObject = {};
		function FiberNode(tag, pendingProps, key, mode) {
		  this.tag = tag;
		  this.key = key;
		  this.sibling =
		    this.child =
		    this.return =
		    this.stateNode =
		    this.type =
		    this.elementType =
		      null;
		  this.index = 0;
		  this.refCleanup = this.ref = null;
		  this.pendingProps = pendingProps;
		  this.dependencies =
		    this.memoizedState =
		    this.updateQueue =
		    this.memoizedProps =
		      null;
		  this.mode = mode;
		  this.subtreeFlags = this.flags = 0;
		  this.deletions = null;
		  this.childLanes = this.lanes = 0;
		  this.alternate = null;
		}
		function createFiberImplClass(tag, pendingProps, key, mode) {
		  return new FiberNode(tag, pendingProps, key, mode);
		}
		function shouldConstruct(Component) {
		  Component = Component.prototype;
		  return !(!Component || !Component.isReactComponent);
		}
		function createWorkInProgress(current, pendingProps) {
		  var workInProgress = current.alternate;
		  null === workInProgress
		    ? ((workInProgress = createFiberImplClass(
		        current.tag,
		        pendingProps,
		        current.key,
		        current.mode
		      )),
		      (workInProgress.elementType = current.elementType),
		      (workInProgress.type = current.type),
		      (workInProgress.stateNode = current.stateNode),
		      (workInProgress.alternate = current),
		      (current.alternate = workInProgress))
		    : ((workInProgress.pendingProps = pendingProps),
		      (workInProgress.type = current.type),
		      (workInProgress.flags = 0),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.deletions = null));
		  workInProgress.flags = current.flags & 65011712;
		  workInProgress.childLanes = current.childLanes;
		  workInProgress.lanes = current.lanes;
		  workInProgress.child = current.child;
		  workInProgress.memoizedProps = current.memoizedProps;
		  workInProgress.memoizedState = current.memoizedState;
		  workInProgress.updateQueue = current.updateQueue;
		  pendingProps = current.dependencies;
		  workInProgress.dependencies =
		    null === pendingProps
		      ? null
		      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
		  workInProgress.sibling = current.sibling;
		  workInProgress.index = current.index;
		  workInProgress.ref = current.ref;
		  workInProgress.refCleanup = current.refCleanup;
		  return workInProgress;
		}
		function resetWorkInProgress(workInProgress, renderLanes) {
		  workInProgress.flags &= 65011714;
		  var current = workInProgress.alternate;
		  null === current
		    ? ((workInProgress.childLanes = 0),
		      (workInProgress.lanes = renderLanes),
		      (workInProgress.child = null),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.memoizedProps = null),
		      (workInProgress.memoizedState = null),
		      (workInProgress.updateQueue = null),
		      (workInProgress.dependencies = null),
		      (workInProgress.stateNode = null))
		    : ((workInProgress.childLanes = current.childLanes),
		      (workInProgress.lanes = current.lanes),
		      (workInProgress.child = current.child),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.deletions = null),
		      (workInProgress.memoizedProps = current.memoizedProps),
		      (workInProgress.memoizedState = current.memoizedState),
		      (workInProgress.updateQueue = current.updateQueue),
		      (workInProgress.type = current.type),
		      (renderLanes = current.dependencies),
		      (workInProgress.dependencies =
		        null === renderLanes
		          ? null
		          : {
		              lanes: renderLanes.lanes,
		              firstContext: renderLanes.firstContext
		            }));
		  return workInProgress;
		}
		function createFiberFromTypeAndProps(
		  type,
		  key,
		  pendingProps,
		  owner,
		  mode,
		  lanes
		) {
		  var fiberTag = 0;
		  owner = type;
		  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
		  else if ("string" === typeof type)
		    fiberTag = isHostHoistableType(
		      type,
		      pendingProps,
		      contextStackCursor.current
		    )
		      ? 26
		      : "html" === type || "head" === type || "body" === type
		        ? 27
		        : 5;
		  else
		    a: switch (type) {
		      case REACT_ACTIVITY_TYPE:
		        return (
		          (type = createFiberImplClass(31, pendingProps, key, mode)),
		          (type.elementType = REACT_ACTIVITY_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_FRAGMENT_TYPE:
		        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
		      case REACT_STRICT_MODE_TYPE:
		        fiberTag = 8;
		        mode |= 24;
		        break;
		      case REACT_PROFILER_TYPE:
		        return (
		          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
		          (type.elementType = REACT_PROFILER_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_SUSPENSE_TYPE:
		        return (
		          (type = createFiberImplClass(13, pendingProps, key, mode)),
		          (type.elementType = REACT_SUSPENSE_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_SUSPENSE_LIST_TYPE:
		        return (
		          (type = createFiberImplClass(19, pendingProps, key, mode)),
		          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      default:
		        if ("object" === typeof type && null !== type)
		          switch (type.$$typeof) {
		            case REACT_PROVIDER_TYPE:
		            case REACT_CONTEXT_TYPE:
		              fiberTag = 10;
		              break a;
		            case REACT_CONSUMER_TYPE:
		              fiberTag = 9;
		              break a;
		            case REACT_FORWARD_REF_TYPE:
		              fiberTag = 11;
		              break a;
		            case REACT_MEMO_TYPE:
		              fiberTag = 14;
		              break a;
		            case REACT_LAZY_TYPE:
		              fiberTag = 16;
		              owner = null;
		              break a;
		          }
		        fiberTag = 29;
		        pendingProps = Error(
		          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
		        );
		        owner = null;
		    }
		  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
		  key.elementType = type;
		  key.type = owner;
		  key.lanes = lanes;
		  return key;
		}
		function createFiberFromFragment(elements, mode, lanes, key) {
		  elements = createFiberImplClass(7, elements, key, mode);
		  elements.lanes = lanes;
		  return elements;
		}
		function createFiberFromText(content, mode, lanes) {
		  content = createFiberImplClass(6, content, null, mode);
		  content.lanes = lanes;
		  return content;
		}
		function createFiberFromPortal(portal, mode, lanes) {
		  mode = createFiberImplClass(
		    4,
		    null !== portal.children ? portal.children : [],
		    portal.key,
		    mode
		  );
		  mode.lanes = lanes;
		  mode.stateNode = {
		    containerInfo: portal.containerInfo,
		    pendingChildren: null,
		    implementation: portal.implementation
		  };
		  return mode;
		}
		var forkStack = [],
		  forkStackIndex = 0,
		  treeForkProvider = null,
		  treeForkCount = 0,
		  idStack = [],
		  idStackIndex = 0,
		  treeContextProvider = null,
		  treeContextId = 1,
		  treeContextOverflow = "";
		function pushTreeFork(workInProgress, totalChildren) {
		  forkStack[forkStackIndex++] = treeForkCount;
		  forkStack[forkStackIndex++] = treeForkProvider;
		  treeForkProvider = workInProgress;
		  treeForkCount = totalChildren;
		}
		function pushTreeId(workInProgress, totalChildren, index) {
		  idStack[idStackIndex++] = treeContextId;
		  idStack[idStackIndex++] = treeContextOverflow;
		  idStack[idStackIndex++] = treeContextProvider;
		  treeContextProvider = workInProgress;
		  var baseIdWithLeadingBit = treeContextId;
		  workInProgress = treeContextOverflow;
		  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		  baseIdWithLeadingBit &= ~(1 << baseLength);
		  index += 1;
		  var length = 32 - clz32(totalChildren) + baseLength;
		  if (30 < length) {
		    var numberOfOverflowBits = baseLength - (baseLength % 5);
		    length = (
		      baseIdWithLeadingBit &
		      ((1 << numberOfOverflowBits) - 1)
		    ).toString(32);
		    baseIdWithLeadingBit >>= numberOfOverflowBits;
		    baseLength -= numberOfOverflowBits;
		    treeContextId =
		      (1 << (32 - clz32(totalChildren) + baseLength)) |
		      (index << baseLength) |
		      baseIdWithLeadingBit;
		    treeContextOverflow = length + workInProgress;
		  } else
		    (treeContextId =
		      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
		      (treeContextOverflow = workInProgress);
		}
		function pushMaterializedTreeId(workInProgress) {
		  null !== workInProgress.return &&
		    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
		}
		function popTreeContext(workInProgress) {
		  for (; workInProgress === treeForkProvider; )
		    (treeForkProvider = forkStack[--forkStackIndex]),
		      (forkStack[forkStackIndex] = null),
		      (treeForkCount = forkStack[--forkStackIndex]),
		      (forkStack[forkStackIndex] = null);
		  for (; workInProgress === treeContextProvider; )
		    (treeContextProvider = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null),
		      (treeContextOverflow = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null),
		      (treeContextId = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null);
		}
		var hydrationParentFiber = null,
		  nextHydratableInstance = null,
		  isHydrating = false,
		  hydrationErrors = null,
		  rootOrSingletonContext = false,
		  HydrationMismatchException = Error(formatProdErrorMessage(519));
		function throwOnHydrationMismatch(fiber) {
		  var error = Error(formatProdErrorMessage(418, ""));
		  queueHydrationError(createCapturedValueAtFiber(error, fiber));
		  throw HydrationMismatchException;
		}
		function prepareToHydrateHostInstance(fiber) {
		  var instance = fiber.stateNode,
		    type = fiber.type,
		    props = fiber.memoizedProps;
		  instance[internalInstanceKey] = fiber;
		  instance[internalPropsKey] = props;
		  switch (type) {
		    case "dialog":
		      listenToNonDelegatedEvent("cancel", instance);
		      listenToNonDelegatedEvent("close", instance);
		      break;
		    case "iframe":
		    case "object":
		    case "embed":
		      listenToNonDelegatedEvent("load", instance);
		      break;
		    case "video":
		    case "audio":
		      for (type = 0; type < mediaEventTypes.length; type++)
		        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
		      break;
		    case "source":
		      listenToNonDelegatedEvent("error", instance);
		      break;
		    case "img":
		    case "image":
		    case "link":
		      listenToNonDelegatedEvent("error", instance);
		      listenToNonDelegatedEvent("load", instance);
		      break;
		    case "details":
		      listenToNonDelegatedEvent("toggle", instance);
		      break;
		    case "input":
		      listenToNonDelegatedEvent("invalid", instance);
		      initInput(
		        instance,
		        props.value,
		        props.defaultValue,
		        props.checked,
		        props.defaultChecked,
		        props.type,
		        props.name,
		        true
		      );
		      track(instance);
		      break;
		    case "select":
		      listenToNonDelegatedEvent("invalid", instance);
		      break;
		    case "textarea":
		      listenToNonDelegatedEvent("invalid", instance),
		        initTextarea(instance, props.value, props.defaultValue, props.children),
		        track(instance);
		  }
		  type = props.children;
		  ("string" !== typeof type &&
		    "number" !== typeof type &&
		    "bigint" !== typeof type) ||
		  instance.textContent === "" + type ||
		  true === props.suppressHydrationWarning ||
		  checkForUnmatchedText(instance.textContent, type)
		    ? (null != props.popover &&
		        (listenToNonDelegatedEvent("beforetoggle", instance),
		        listenToNonDelegatedEvent("toggle", instance)),
		      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
		      null != props.onScrollEnd &&
		        listenToNonDelegatedEvent("scrollend", instance),
		      null != props.onClick && (instance.onclick = noop$1),
		      (instance = true))
		    : (instance = false);
		  instance || throwOnHydrationMismatch(fiber);
		}
		function popToNextHostParent(fiber) {
		  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
		    switch (hydrationParentFiber.tag) {
		      case 5:
		      case 13:
		        rootOrSingletonContext = false;
		        return;
		      case 27:
		      case 3:
		        rootOrSingletonContext = true;
		        return;
		      default:
		        hydrationParentFiber = hydrationParentFiber.return;
		    }
		}
		function popHydrationState(fiber) {
		  if (fiber !== hydrationParentFiber) return false;
		  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = true), false;
		  var tag = fiber.tag,
		    JSCompiler_temp;
		  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
		    if ((JSCompiler_temp = 5 === tag))
		      (JSCompiler_temp = fiber.type),
		        (JSCompiler_temp =
		          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
		          shouldSetTextContent(fiber.type, fiber.memoizedProps));
		    JSCompiler_temp = !JSCompiler_temp;
		  }
		  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
		  popToNextHostParent(fiber);
		  if (13 === tag) {
		    fiber = fiber.memoizedState;
		    fiber = null !== fiber ? fiber.dehydrated : null;
		    if (!fiber) throw Error(formatProdErrorMessage(317));
		    a: {
		      fiber = fiber.nextSibling;
		      for (tag = 0; fiber; ) {
		        if (8 === fiber.nodeType)
		          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
		            if (0 === tag) {
		              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
		              break a;
		            }
		            tag--;
		          } else
		            ("$" !== JSCompiler_temp &&
		              "$!" !== JSCompiler_temp &&
		              "$?" !== JSCompiler_temp) ||
		              tag++;
		        fiber = fiber.nextSibling;
		      }
		      nextHydratableInstance = null;
		    }
		  } else
		    27 === tag
		      ? ((tag = nextHydratableInstance),
		        isSingletonScope(fiber.type)
		          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
		            (previousHydratableOnEnteringScopedSingleton = null),
		            (nextHydratableInstance = fiber))
		          : (nextHydratableInstance = tag))
		      : (nextHydratableInstance = hydrationParentFiber
		          ? getNextHydratable(fiber.stateNode.nextSibling)
		          : null);
		  return true;
		}
		function resetHydrationState() {
		  nextHydratableInstance = hydrationParentFiber = null;
		  isHydrating = false;
		}
		function upgradeHydrationErrorsToRecoverable() {
		  var queuedErrors = hydrationErrors;
		  null !== queuedErrors &&
		    (null === workInProgressRootRecoverableErrors
		      ? (workInProgressRootRecoverableErrors = queuedErrors)
		      : workInProgressRootRecoverableErrors.push.apply(
		          workInProgressRootRecoverableErrors,
		          queuedErrors
		        ),
		    (hydrationErrors = null));
		  return queuedErrors;
		}
		function queueHydrationError(error) {
		  null === hydrationErrors
		    ? (hydrationErrors = [error])
		    : hydrationErrors.push(error);
		}
		var valueCursor = createCursor(null),
		  currentlyRenderingFiber$1 = null,
		  lastContextDependency = null;
		function pushProvider(providerFiber, context, nextValue) {
		  push(valueCursor, context._currentValue);
		  context._currentValue = nextValue;
		}
		function popProvider(context) {
		  context._currentValue = valueCursor.current;
		  pop(valueCursor);
		}
		function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
		  for (; null !== parent; ) {
		    var alternate = parent.alternate;
		    (parent.childLanes & renderLanes) !== renderLanes
		      ? ((parent.childLanes |= renderLanes),
		        null !== alternate && (alternate.childLanes |= renderLanes))
		      : null !== alternate &&
		        (alternate.childLanes & renderLanes) !== renderLanes &&
		        (alternate.childLanes |= renderLanes);
		    if (parent === propagationRoot) break;
		    parent = parent.return;
		  }
		}
		function propagateContextChanges(
		  workInProgress,
		  contexts,
		  renderLanes,
		  forcePropagateEntireTree
		) {
		  var fiber = workInProgress.child;
		  null !== fiber && (fiber.return = workInProgress);
		  for (; null !== fiber; ) {
		    var list = fiber.dependencies;
		    if (null !== list) {
		      var nextFiber = fiber.child;
		      list = list.firstContext;
		      a: for (; null !== list; ) {
		        var dependency = list;
		        list = fiber;
		        for (var i = 0; i < contexts.length; i++)
		          if (dependency.context === contexts[i]) {
		            list.lanes |= renderLanes;
		            dependency = list.alternate;
		            null !== dependency && (dependency.lanes |= renderLanes);
		            scheduleContextWorkOnParentPath(
		              list.return,
		              renderLanes,
		              workInProgress
		            );
		            forcePropagateEntireTree || (nextFiber = null);
		            break a;
		          }
		        list = dependency.next;
		      }
		    } else if (18 === fiber.tag) {
		      nextFiber = fiber.return;
		      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
		      nextFiber.lanes |= renderLanes;
		      list = nextFiber.alternate;
		      null !== list && (list.lanes |= renderLanes);
		      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
		      nextFiber = null;
		    } else nextFiber = fiber.child;
		    if (null !== nextFiber) nextFiber.return = fiber;
		    else
		      for (nextFiber = fiber; null !== nextFiber; ) {
		        if (nextFiber === workInProgress) {
		          nextFiber = null;
		          break;
		        }
		        fiber = nextFiber.sibling;
		        if (null !== fiber) {
		          fiber.return = nextFiber.return;
		          nextFiber = fiber;
		          break;
		        }
		        nextFiber = nextFiber.return;
		      }
		    fiber = nextFiber;
		  }
		}
		function propagateParentContextChanges(
		  current,
		  workInProgress,
		  renderLanes,
		  forcePropagateEntireTree
		) {
		  current = null;
		  for (
		    var parent = workInProgress, isInsidePropagationBailout = false;
		    null !== parent;

		  ) {
		    if (!isInsidePropagationBailout)
		      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
		      else if (0 !== (parent.flags & 262144)) break;
		    if (10 === parent.tag) {
		      var currentParent = parent.alternate;
		      if (null === currentParent) throw Error(formatProdErrorMessage(387));
		      currentParent = currentParent.memoizedProps;
		      if (null !== currentParent) {
		        var context = parent.type;
		        objectIs(parent.pendingProps.value, currentParent.value) ||
		          (null !== current ? current.push(context) : (current = [context]));
		      }
		    } else if (parent === hostTransitionProviderCursor.current) {
		      currentParent = parent.alternate;
		      if (null === currentParent) throw Error(formatProdErrorMessage(387));
		      currentParent.memoizedState.memoizedState !==
		        parent.memoizedState.memoizedState &&
		        (null !== current
		          ? current.push(HostTransitionContext)
		          : (current = [HostTransitionContext]));
		    }
		    parent = parent.return;
		  }
		  null !== current &&
		    propagateContextChanges(
		      workInProgress,
		      current,
		      renderLanes,
		      forcePropagateEntireTree
		    );
		  workInProgress.flags |= 262144;
		}
		function checkIfContextChanged(currentDependencies) {
		  for (
		    currentDependencies = currentDependencies.firstContext;
		    null !== currentDependencies;

		  ) {
		    if (
		      !objectIs(
		        currentDependencies.context._currentValue,
		        currentDependencies.memoizedValue
		      )
		    )
		      return true;
		    currentDependencies = currentDependencies.next;
		  }
		  return false;
		}
		function prepareToReadContext(workInProgress) {
		  currentlyRenderingFiber$1 = workInProgress;
		  lastContextDependency = null;
		  workInProgress = workInProgress.dependencies;
		  null !== workInProgress && (workInProgress.firstContext = null);
		}
		function readContext(context) {
		  return readContextForConsumer(currentlyRenderingFiber$1, context);
		}
		function readContextDuringReconciliation(consumer, context) {
		  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
		  return readContextForConsumer(consumer, context);
		}
		function readContextForConsumer(consumer, context) {
		  var value = context._currentValue;
		  context = { context: context, memoizedValue: value, next: null };
		  if (null === lastContextDependency) {
		    if (null === consumer) throw Error(formatProdErrorMessage(308));
		    lastContextDependency = context;
		    consumer.dependencies = { lanes: 0, firstContext: context };
		    consumer.flags |= 524288;
		  } else lastContextDependency = lastContextDependency.next = context;
		  return value;
		}
		var AbortControllerLocal =
		    "undefined" !== typeof AbortController
		      ? AbortController
		      : function () {
		          var listeners = [],
		            signal = (this.signal = {
		              aborted: false,
		              addEventListener: function (type, listener) {
		                listeners.push(listener);
		              }
		            });
		          this.abort = function () {
		            signal.aborted = true;
		            listeners.forEach(function (listener) {
		              return listener();
		            });
		          };
		        },
		  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
		  NormalPriority = Scheduler.unstable_NormalPriority,
		  CacheContext = {
		    $$typeof: REACT_CONTEXT_TYPE,
		    Consumer: null,
		    Provider: null,
		    _currentValue: null,
		    _currentValue2: null,
		    _threadCount: 0
		  };
		function createCache() {
		  return {
		    controller: new AbortControllerLocal(),
		    data: new Map(),
		    refCount: 0
		  };
		}
		function releaseCache(cache) {
		  cache.refCount--;
		  0 === cache.refCount &&
		    scheduleCallback$2(NormalPriority, function () {
		      cache.controller.abort();
		    });
		}
		var currentEntangledListeners = null,
		  currentEntangledPendingCount = 0,
		  currentEntangledLane = 0,
		  currentEntangledActionThenable = null;
		function entangleAsyncAction(transition, thenable) {
		  if (null === currentEntangledListeners) {
		    var entangledListeners = (currentEntangledListeners = []);
		    currentEntangledPendingCount = 0;
		    currentEntangledLane = requestTransitionLane();
		    currentEntangledActionThenable = {
		      status: "pending",
		      value: void 0,
		      then: function (resolve) {
		        entangledListeners.push(resolve);
		      }
		    };
		  }
		  currentEntangledPendingCount++;
		  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		  return thenable;
		}
		function pingEngtangledActionScope() {
		  if (
		    0 === --currentEntangledPendingCount &&
		    null !== currentEntangledListeners
		  ) {
		    null !== currentEntangledActionThenable &&
		      (currentEntangledActionThenable.status = "fulfilled");
		    var listeners = currentEntangledListeners;
		    currentEntangledListeners = null;
		    currentEntangledLane = 0;
		    currentEntangledActionThenable = null;
		    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		  }
		}
		function chainThenableValue(thenable, result) {
		  var listeners = [],
		    thenableWithOverride = {
		      status: "pending",
		      value: null,
		      reason: null,
		      then: function (resolve) {
		        listeners.push(resolve);
		      }
		    };
		  thenable.then(
		    function () {
		      thenableWithOverride.status = "fulfilled";
		      thenableWithOverride.value = result;
		      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		    },
		    function (error) {
		      thenableWithOverride.status = "rejected";
		      thenableWithOverride.reason = error;
		      for (error = 0; error < listeners.length; error++)
		        (0, listeners[error])(void 0);
		    }
		  );
		  return thenableWithOverride;
		}
		var prevOnStartTransitionFinish = ReactSharedInternals.S;
		ReactSharedInternals.S = function (transition, returnValue) {
		  "object" === typeof returnValue &&
		    null !== returnValue &&
		    "function" === typeof returnValue.then &&
		    entangleAsyncAction(transition, returnValue);
		  null !== prevOnStartTransitionFinish &&
		    prevOnStartTransitionFinish(transition, returnValue);
		};
		var resumedCache = createCursor(null);
		function peekCacheFromPool() {
		  var cacheResumedFromPreviousRender = resumedCache.current;
		  return null !== cacheResumedFromPreviousRender
		    ? cacheResumedFromPreviousRender
		    : workInProgressRoot.pooledCache;
		}
		function pushTransition(offscreenWorkInProgress, prevCachePool) {
		  null === prevCachePool
		    ? push(resumedCache, resumedCache.current)
		    : push(resumedCache, prevCachePool.pool);
		}
		function getSuspendedCache() {
		  var cacheFromPool = peekCacheFromPool();
		  return null === cacheFromPool
		    ? null
		    : { parent: CacheContext._currentValue, pool: cacheFromPool };
		}
		var SuspenseException = Error(formatProdErrorMessage(460)),
		  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
		  SuspenseActionException = Error(formatProdErrorMessage(542)),
		  noopSuspenseyCommitThenable = { then: function () {} };
		function isThenableResolved(thenable) {
		  thenable = thenable.status;
		  return "fulfilled" === thenable || "rejected" === thenable;
		}
		function noop$3() {}
		function trackUsedThenable(thenableState, thenable, index) {
		  index = thenableState[index];
		  void 0 === index
		    ? thenableState.push(thenable)
		    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
		  switch (thenable.status) {
		    case "fulfilled":
		      return thenable.value;
		    case "rejected":
		      throw (
		        ((thenableState = thenable.reason),
		        checkIfUseWrappedInAsyncCatch(thenableState),
		        thenableState)
		      );
		    default:
		      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
		      else {
		        thenableState = workInProgressRoot;
		        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
		          throw Error(formatProdErrorMessage(482));
		        thenableState = thenable;
		        thenableState.status = "pending";
		        thenableState.then(
		          function (fulfilledValue) {
		            if ("pending" === thenable.status) {
		              var fulfilledThenable = thenable;
		              fulfilledThenable.status = "fulfilled";
		              fulfilledThenable.value = fulfilledValue;
		            }
		          },
		          function (error) {
		            if ("pending" === thenable.status) {
		              var rejectedThenable = thenable;
		              rejectedThenable.status = "rejected";
		              rejectedThenable.reason = error;
		            }
		          }
		        );
		      }
		      switch (thenable.status) {
		        case "fulfilled":
		          return thenable.value;
		        case "rejected":
		          throw (
		            ((thenableState = thenable.reason),
		            checkIfUseWrappedInAsyncCatch(thenableState),
		            thenableState)
		          );
		      }
		      suspendedThenable = thenable;
		      throw SuspenseException;
		  }
		}
		var suspendedThenable = null;
		function getSuspendedThenable() {
		  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
		  var thenable = suspendedThenable;
		  suspendedThenable = null;
		  return thenable;
		}
		function checkIfUseWrappedInAsyncCatch(rejectedReason) {
		  if (
		    rejectedReason === SuspenseException ||
		    rejectedReason === SuspenseActionException
		  )
		    throw Error(formatProdErrorMessage(483));
		}
		var hasForceUpdate = false;
		function initializeUpdateQueue(fiber) {
		  fiber.updateQueue = {
		    baseState: fiber.memoizedState,
		    firstBaseUpdate: null,
		    lastBaseUpdate: null,
		    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
		    callbacks: null
		  };
		}
		function cloneUpdateQueue(current, workInProgress) {
		  current = current.updateQueue;
		  workInProgress.updateQueue === current &&
		    (workInProgress.updateQueue = {
		      baseState: current.baseState,
		      firstBaseUpdate: current.firstBaseUpdate,
		      lastBaseUpdate: current.lastBaseUpdate,
		      shared: current.shared,
		      callbacks: null
		    });
		}
		function createUpdate(lane) {
		  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
		}
		function enqueueUpdate(fiber, update, lane) {
		  var updateQueue = fiber.updateQueue;
		  if (null === updateQueue) return null;
		  updateQueue = updateQueue.shared;
		  if (0 !== (executionContext & 2)) {
		    var pending = updateQueue.pending;
		    null === pending
		      ? (update.next = update)
		      : ((update.next = pending.next), (pending.next = update));
		    updateQueue.pending = update;
		    update = getRootForUpdatedFiber(fiber);
		    markUpdateLaneFromFiberToRoot(fiber, null, lane);
		    return update;
		  }
		  enqueueUpdate$1(fiber, updateQueue, update, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function entangleTransitions(root, fiber, lane) {
		  fiber = fiber.updateQueue;
		  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
		    var queueLanes = fiber.lanes;
		    queueLanes &= root.pendingLanes;
		    lane |= queueLanes;
		    fiber.lanes = lane;
		    markRootEntangled(root, lane);
		  }
		}
		function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
		  var queue = workInProgress.updateQueue,
		    current = workInProgress.alternate;
		  if (
		    null !== current &&
		    ((current = current.updateQueue), queue === current)
		  ) {
		    var newFirst = null,
		      newLast = null;
		    queue = queue.firstBaseUpdate;
		    if (null !== queue) {
		      do {
		        var clone = {
		          lane: queue.lane,
		          tag: queue.tag,
		          payload: queue.payload,
		          callback: null,
		          next: null
		        };
		        null === newLast
		          ? (newFirst = newLast = clone)
		          : (newLast = newLast.next = clone);
		        queue = queue.next;
		      } while (null !== queue);
		      null === newLast
		        ? (newFirst = newLast = capturedUpdate)
		        : (newLast = newLast.next = capturedUpdate);
		    } else newFirst = newLast = capturedUpdate;
		    queue = {
		      baseState: current.baseState,
		      firstBaseUpdate: newFirst,
		      lastBaseUpdate: newLast,
		      shared: current.shared,
		      callbacks: current.callbacks
		    };
		    workInProgress.updateQueue = queue;
		    return;
		  }
		  workInProgress = queue.lastBaseUpdate;
		  null === workInProgress
		    ? (queue.firstBaseUpdate = capturedUpdate)
		    : (workInProgress.next = capturedUpdate);
		  queue.lastBaseUpdate = capturedUpdate;
		}
		var didReadFromEntangledAsyncAction = false;
		function suspendIfUpdateReadFromEntangledAsyncAction() {
		  if (didReadFromEntangledAsyncAction) {
		    var entangledActionThenable = currentEntangledActionThenable;
		    if (null !== entangledActionThenable) throw entangledActionThenable;
		  }
		}
		function processUpdateQueue(
		  workInProgress$jscomp$0,
		  props,
		  instance$jscomp$0,
		  renderLanes
		) {
		  didReadFromEntangledAsyncAction = false;
		  var queue = workInProgress$jscomp$0.updateQueue;
		  hasForceUpdate = false;
		  var firstBaseUpdate = queue.firstBaseUpdate,
		    lastBaseUpdate = queue.lastBaseUpdate,
		    pendingQueue = queue.shared.pending;
		  if (null !== pendingQueue) {
		    queue.shared.pending = null;
		    var lastPendingUpdate = pendingQueue,
		      firstPendingUpdate = lastPendingUpdate.next;
		    lastPendingUpdate.next = null;
		    null === lastBaseUpdate
		      ? (firstBaseUpdate = firstPendingUpdate)
		      : (lastBaseUpdate.next = firstPendingUpdate);
		    lastBaseUpdate = lastPendingUpdate;
		    var current = workInProgress$jscomp$0.alternate;
		    null !== current &&
		      ((current = current.updateQueue),
		      (pendingQueue = current.lastBaseUpdate),
		      pendingQueue !== lastBaseUpdate &&
		        (null === pendingQueue
		          ? (current.firstBaseUpdate = firstPendingUpdate)
		          : (pendingQueue.next = firstPendingUpdate),
		        (current.lastBaseUpdate = lastPendingUpdate)));
		  }
		  if (null !== firstBaseUpdate) {
		    var newState = queue.baseState;
		    lastBaseUpdate = 0;
		    current = firstPendingUpdate = lastPendingUpdate = null;
		    pendingQueue = firstBaseUpdate;
		    do {
		      var updateLane = pendingQueue.lane & -536870913,
		        isHiddenUpdate = updateLane !== pendingQueue.lane;
		      if (
		        isHiddenUpdate
		          ? (workInProgressRootRenderLanes & updateLane) === updateLane
		          : (renderLanes & updateLane) === updateLane
		      ) {
		        0 !== updateLane &&
		          updateLane === currentEntangledLane &&
		          (didReadFromEntangledAsyncAction = true);
		        null !== current &&
		          (current = current.next =
		            {
		              lane: 0,
		              tag: pendingQueue.tag,
		              payload: pendingQueue.payload,
		              callback: null,
		              next: null
		            });
		        a: {
		          var workInProgress = workInProgress$jscomp$0,
		            update = pendingQueue;
		          updateLane = props;
		          var instance = instance$jscomp$0;
		          switch (update.tag) {
		            case 1:
		              workInProgress = update.payload;
		              if ("function" === typeof workInProgress) {
		                newState = workInProgress.call(instance, newState, updateLane);
		                break a;
		              }
		              newState = workInProgress;
		              break a;
		            case 3:
		              workInProgress.flags = (workInProgress.flags & -65537) | 128;
		            case 0:
		              workInProgress = update.payload;
		              updateLane =
		                "function" === typeof workInProgress
		                  ? workInProgress.call(instance, newState, updateLane)
		                  : workInProgress;
		              if (null === updateLane || void 0 === updateLane) break a;
		              newState = assign({}, newState, updateLane);
		              break a;
		            case 2:
		              hasForceUpdate = true;
		          }
		        }
		        updateLane = pendingQueue.callback;
		        null !== updateLane &&
		          ((workInProgress$jscomp$0.flags |= 64),
		          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
		          (isHiddenUpdate = queue.callbacks),
		          null === isHiddenUpdate
		            ? (queue.callbacks = [updateLane])
		            : isHiddenUpdate.push(updateLane));
		      } else
		        (isHiddenUpdate = {
		          lane: updateLane,
		          tag: pendingQueue.tag,
		          payload: pendingQueue.payload,
		          callback: pendingQueue.callback,
		          next: null
		        }),
		          null === current
		            ? ((firstPendingUpdate = current = isHiddenUpdate),
		              (lastPendingUpdate = newState))
		            : (current = current.next = isHiddenUpdate),
		          (lastBaseUpdate |= updateLane);
		      pendingQueue = pendingQueue.next;
		      if (null === pendingQueue)
		        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
		          break;
		        else
		          (isHiddenUpdate = pendingQueue),
		            (pendingQueue = isHiddenUpdate.next),
		            (isHiddenUpdate.next = null),
		            (queue.lastBaseUpdate = isHiddenUpdate),
		            (queue.shared.pending = null);
		    } while (1);
		    null === current && (lastPendingUpdate = newState);
		    queue.baseState = lastPendingUpdate;
		    queue.firstBaseUpdate = firstPendingUpdate;
		    queue.lastBaseUpdate = current;
		    null === firstBaseUpdate && (queue.shared.lanes = 0);
		    workInProgressRootSkippedLanes |= lastBaseUpdate;
		    workInProgress$jscomp$0.lanes = lastBaseUpdate;
		    workInProgress$jscomp$0.memoizedState = newState;
		  }
		}
		function callCallback(callback, context) {
		  if ("function" !== typeof callback)
		    throw Error(formatProdErrorMessage(191, callback));
		  callback.call(context);
		}
		function commitCallbacks(updateQueue, context) {
		  var callbacks = updateQueue.callbacks;
		  if (null !== callbacks)
		    for (
		      updateQueue.callbacks = null, updateQueue = 0;
		      updateQueue < callbacks.length;
		      updateQueue++
		    )
		      callCallback(callbacks[updateQueue], context);
		}
		var currentTreeHiddenStackCursor = createCursor(null),
		  prevEntangledRenderLanesCursor = createCursor(0);
		function pushHiddenContext(fiber, context) {
		  fiber = entangledRenderLanes;
		  push(prevEntangledRenderLanesCursor, fiber);
		  push(currentTreeHiddenStackCursor, context);
		  entangledRenderLanes = fiber | context.baseLanes;
		}
		function reuseHiddenContextOnStack() {
		  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
		  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
		}
		function popHiddenContext() {
		  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		  pop(currentTreeHiddenStackCursor);
		  pop(prevEntangledRenderLanesCursor);
		}
		var renderLanes = 0,
		  currentlyRenderingFiber = null,
		  currentHook = null,
		  workInProgressHook = null,
		  didScheduleRenderPhaseUpdate = false,
		  didScheduleRenderPhaseUpdateDuringThisPass = false,
		  shouldDoubleInvokeUserFnsInHooksDEV = false,
		  localIdCounter = 0,
		  thenableIndexCounter$1 = 0,
		  thenableState$1 = null,
		  globalClientIdCounter = 0;
		function throwInvalidHookError() {
		  throw Error(formatProdErrorMessage(321));
		}
		function areHookInputsEqual(nextDeps, prevDeps) {
		  if (null === prevDeps) return false;
		  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
		    if (!objectIs(nextDeps[i], prevDeps[i])) return false;
		  return true;
		}
		function renderWithHooks(
		  current,
		  workInProgress,
		  Component,
		  props,
		  secondArg,
		  nextRenderLanes
		) {
		  renderLanes = nextRenderLanes;
		  currentlyRenderingFiber = workInProgress;
		  workInProgress.memoizedState = null;
		  workInProgress.updateQueue = null;
		  workInProgress.lanes = 0;
		  ReactSharedInternals.H =
		    null === current || null === current.memoizedState
		      ? HooksDispatcherOnMount
		      : HooksDispatcherOnUpdate;
		  shouldDoubleInvokeUserFnsInHooksDEV = false;
		  nextRenderLanes = Component(props, secondArg);
		  shouldDoubleInvokeUserFnsInHooksDEV = false;
		  didScheduleRenderPhaseUpdateDuringThisPass &&
		    (nextRenderLanes = renderWithHooksAgain(
		      workInProgress,
		      Component,
		      props,
		      secondArg
		    ));
		  finishRenderingHooks(current);
		  return nextRenderLanes;
		}
		function finishRenderingHooks(current) {
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
		  renderLanes = 0;
		  workInProgressHook = currentHook = currentlyRenderingFiber = null;
		  didScheduleRenderPhaseUpdate = false;
		  thenableIndexCounter$1 = 0;
		  thenableState$1 = null;
		  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
		  null === current ||
		    didReceiveUpdate ||
		    ((current = current.dependencies),
		    null !== current &&
		      checkIfContextChanged(current) &&
		      (didReceiveUpdate = true));
		}
		function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
		  currentlyRenderingFiber = workInProgress;
		  var numberOfReRenders = 0;
		  do {
		    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
		    thenableIndexCounter$1 = 0;
		    didScheduleRenderPhaseUpdateDuringThisPass = false;
		    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
		    numberOfReRenders += 1;
		    workInProgressHook = currentHook = null;
		    if (null != workInProgress.updateQueue) {
		      var children = workInProgress.updateQueue;
		      children.lastEffect = null;
		      children.events = null;
		      children.stores = null;
		      null != children.memoCache && (children.memoCache.index = 0);
		    }
		    ReactSharedInternals.H = HooksDispatcherOnRerender;
		    children = Component(props, secondArg);
		  } while (didScheduleRenderPhaseUpdateDuringThisPass);
		  return children;
		}
		function TransitionAwareHostComponent() {
		  var dispatcher = ReactSharedInternals.H,
		    maybeThenable = dispatcher.useState()[0];
		  maybeThenable =
		    "function" === typeof maybeThenable.then
		      ? useThenable(maybeThenable)
		      : maybeThenable;
		  dispatcher = dispatcher.useState()[0];
		  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
		    (currentlyRenderingFiber.flags |= 1024);
		  return maybeThenable;
		}
		function checkDidRenderIdHook() {
		  var didRenderIdHook = 0 !== localIdCounter;
		  localIdCounter = 0;
		  return didRenderIdHook;
		}
		function bailoutHooks(current, workInProgress, lanes) {
		  workInProgress.updateQueue = current.updateQueue;
		  workInProgress.flags &= -2053;
		  current.lanes &= ~lanes;
		}
		function resetHooksOnUnwind(workInProgress) {
		  if (didScheduleRenderPhaseUpdate) {
		    for (
		      workInProgress = workInProgress.memoizedState;
		      null !== workInProgress;

		    ) {
		      var queue = workInProgress.queue;
		      null !== queue && (queue.pending = null);
		      workInProgress = workInProgress.next;
		    }
		    didScheduleRenderPhaseUpdate = false;
		  }
		  renderLanes = 0;
		  workInProgressHook = currentHook = currentlyRenderingFiber = null;
		  didScheduleRenderPhaseUpdateDuringThisPass = false;
		  thenableIndexCounter$1 = localIdCounter = 0;
		  thenableState$1 = null;
		}
		function mountWorkInProgressHook() {
		  var hook = {
		    memoizedState: null,
		    baseState: null,
		    baseQueue: null,
		    queue: null,
		    next: null
		  };
		  null === workInProgressHook
		    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
		    : (workInProgressHook = workInProgressHook.next = hook);
		  return workInProgressHook;
		}
		function updateWorkInProgressHook() {
		  if (null === currentHook) {
		    var nextCurrentHook = currentlyRenderingFiber.alternate;
		    nextCurrentHook =
		      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		  } else nextCurrentHook = currentHook.next;
		  var nextWorkInProgressHook =
		    null === workInProgressHook
		      ? currentlyRenderingFiber.memoizedState
		      : workInProgressHook.next;
		  if (null !== nextWorkInProgressHook)
		    (workInProgressHook = nextWorkInProgressHook),
		      (currentHook = nextCurrentHook);
		  else {
		    if (null === nextCurrentHook) {
		      if (null === currentlyRenderingFiber.alternate)
		        throw Error(formatProdErrorMessage(467));
		      throw Error(formatProdErrorMessage(310));
		    }
		    currentHook = nextCurrentHook;
		    nextCurrentHook = {
		      memoizedState: currentHook.memoizedState,
		      baseState: currentHook.baseState,
		      baseQueue: currentHook.baseQueue,
		      queue: currentHook.queue,
		      next: null
		    };
		    null === workInProgressHook
		      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
		          nextCurrentHook)
		      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
		  }
		  return workInProgressHook;
		}
		function createFunctionComponentUpdateQueue() {
		  return { lastEffect: null, events: null, stores: null, memoCache: null };
		}
		function useThenable(thenable) {
		  var index = thenableIndexCounter$1;
		  thenableIndexCounter$1 += 1;
		  null === thenableState$1 && (thenableState$1 = []);
		  thenable = trackUsedThenable(thenableState$1, thenable, index);
		  index = currentlyRenderingFiber;
		  null ===
		    (null === workInProgressHook
		      ? index.memoizedState
		      : workInProgressHook.next) &&
		    ((index = index.alternate),
		    (ReactSharedInternals.H =
		      null === index || null === index.memoizedState
		        ? HooksDispatcherOnMount
		        : HooksDispatcherOnUpdate));
		  return thenable;
		}
		function use(usable) {
		  if (null !== usable && "object" === typeof usable) {
		    if ("function" === typeof usable.then) return useThenable(usable);
		    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		  }
		  throw Error(formatProdErrorMessage(438, String(usable)));
		}
		function useMemoCache(size) {
		  var memoCache = null,
		    updateQueue = currentlyRenderingFiber.updateQueue;
		  null !== updateQueue && (memoCache = updateQueue.memoCache);
		  if (null == memoCache) {
		    var current = currentlyRenderingFiber.alternate;
		    null !== current &&
		      ((current = current.updateQueue),
		      null !== current &&
		        ((current = current.memoCache),
		        null != current &&
		          (memoCache = {
		            data: current.data.map(function (array) {
		              return array.slice();
		            }),
		            index: 0
		          })));
		  }
		  null == memoCache && (memoCache = { data: [], index: 0 });
		  null === updateQueue &&
		    ((updateQueue = createFunctionComponentUpdateQueue()),
		    (currentlyRenderingFiber.updateQueue = updateQueue));
		  updateQueue.memoCache = memoCache;
		  updateQueue = memoCache.data[memoCache.index];
		  if (void 0 === updateQueue)
		    for (
		      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
		      current < size;
		      current++
		    )
		      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		  memoCache.index++;
		  return updateQueue;
		}
		function basicStateReducer(state, action) {
		  return "function" === typeof action ? action(state) : action;
		}
		function updateReducer(reducer) {
		  var hook = updateWorkInProgressHook();
		  return updateReducerImpl(hook, currentHook, reducer);
		}
		function updateReducerImpl(hook, current, reducer) {
		  var queue = hook.queue;
		  if (null === queue) throw Error(formatProdErrorMessage(311));
		  queue.lastRenderedReducer = reducer;
		  var baseQueue = hook.baseQueue,
		    pendingQueue = queue.pending;
		  if (null !== pendingQueue) {
		    if (null !== baseQueue) {
		      var baseFirst = baseQueue.next;
		      baseQueue.next = pendingQueue.next;
		      pendingQueue.next = baseFirst;
		    }
		    current.baseQueue = baseQueue = pendingQueue;
		    queue.pending = null;
		  }
		  pendingQueue = hook.baseState;
		  if (null === baseQueue) hook.memoizedState = pendingQueue;
		  else {
		    current = baseQueue.next;
		    var newBaseQueueFirst = (baseFirst = null),
		      newBaseQueueLast = null,
		      update = current,
		      didReadFromEntangledAsyncAction$32 = false;
		    do {
		      var updateLane = update.lane & -536870913;
		      if (
		        updateLane !== update.lane
		          ? (workInProgressRootRenderLanes & updateLane) === updateLane
		          : (renderLanes & updateLane) === updateLane
		      ) {
		        var revertLane = update.revertLane;
		        if (0 === revertLane)
		          null !== newBaseQueueLast &&
		            (newBaseQueueLast = newBaseQueueLast.next =
		              {
		                lane: 0,
		                revertLane: 0,
		                action: update.action,
		                hasEagerState: update.hasEagerState,
		                eagerState: update.eagerState,
		                next: null
		              }),
		            updateLane === currentEntangledLane &&
		              (didReadFromEntangledAsyncAction$32 = true);
		        else if ((renderLanes & revertLane) === revertLane) {
		          update = update.next;
		          revertLane === currentEntangledLane &&
		            (didReadFromEntangledAsyncAction$32 = true);
		          continue;
		        } else
		          (updateLane = {
		            lane: 0,
		            revertLane: update.revertLane,
		            action: update.action,
		            hasEagerState: update.hasEagerState,
		            eagerState: update.eagerState,
		            next: null
		          }),
		            null === newBaseQueueLast
		              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
		                (baseFirst = pendingQueue))
		              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
		            (currentlyRenderingFiber.lanes |= revertLane),
		            (workInProgressRootSkippedLanes |= revertLane);
		        updateLane = update.action;
		        shouldDoubleInvokeUserFnsInHooksDEV &&
		          reducer(pendingQueue, updateLane);
		        pendingQueue = update.hasEagerState
		          ? update.eagerState
		          : reducer(pendingQueue, updateLane);
		      } else
		        (revertLane = {
		          lane: updateLane,
		          revertLane: update.revertLane,
		          action: update.action,
		          hasEagerState: update.hasEagerState,
		          eagerState: update.eagerState,
		          next: null
		        }),
		          null === newBaseQueueLast
		            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
		              (baseFirst = pendingQueue))
		            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
		          (currentlyRenderingFiber.lanes |= updateLane),
		          (workInProgressRootSkippedLanes |= updateLane);
		      update = update.next;
		    } while (null !== update && update !== current);
		    null === newBaseQueueLast
		      ? (baseFirst = pendingQueue)
		      : (newBaseQueueLast.next = newBaseQueueFirst);
		    if (
		      !objectIs(pendingQueue, hook.memoizedState) &&
		      ((didReceiveUpdate = true),
		      didReadFromEntangledAsyncAction$32 &&
		        ((reducer = currentEntangledActionThenable), null !== reducer))
		    )
		      throw reducer;
		    hook.memoizedState = pendingQueue;
		    hook.baseState = baseFirst;
		    hook.baseQueue = newBaseQueueLast;
		    queue.lastRenderedState = pendingQueue;
		  }
		  null === baseQueue && (queue.lanes = 0);
		  return [hook.memoizedState, queue.dispatch];
		}
		function rerenderReducer(reducer) {
		  var hook = updateWorkInProgressHook(),
		    queue = hook.queue;
		  if (null === queue) throw Error(formatProdErrorMessage(311));
		  queue.lastRenderedReducer = reducer;
		  var dispatch = queue.dispatch,
		    lastRenderPhaseUpdate = queue.pending,
		    newState = hook.memoizedState;
		  if (null !== lastRenderPhaseUpdate) {
		    queue.pending = null;
		    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
		    do (newState = reducer(newState, update.action)), (update = update.next);
		    while (update !== lastRenderPhaseUpdate);
		    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
		    hook.memoizedState = newState;
		    null === hook.baseQueue && (hook.baseState = newState);
		    queue.lastRenderedState = newState;
		  }
		  return [newState, dispatch];
		}
		function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		  var fiber = currentlyRenderingFiber,
		    hook = updateWorkInProgressHook(),
		    isHydrating$jscomp$0 = isHydrating;
		  if (isHydrating$jscomp$0) {
		    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
		    getServerSnapshot = getServerSnapshot();
		  } else getServerSnapshot = getSnapshot();
		  var snapshotChanged = !objectIs(
		    (currentHook || hook).memoizedState,
		    getServerSnapshot
		  );
		  snapshotChanged &&
		    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true));
		  hook = hook.queue;
		  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
		  updateEffectImpl(2048, 8, create, [subscribe]);
		  if (
		    hook.getSnapshot !== getSnapshot ||
		    snapshotChanged ||
		    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
		  ) {
		    fiber.flags |= 2048;
		    pushSimpleEffect(
		      9,
		      createEffectInstance(),
		      updateStoreInstance.bind(
		        null,
		        fiber,
		        hook,
		        getServerSnapshot,
		        getSnapshot
		      ),
		      null
		    );
		    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
		    isHydrating$jscomp$0 ||
		      0 !== (renderLanes & 124) ||
		      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		  }
		  return getServerSnapshot;
		}
		function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		  fiber.flags |= 16384;
		  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
		  getSnapshot = currentlyRenderingFiber.updateQueue;
		  null === getSnapshot
		    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
		      (currentlyRenderingFiber.updateQueue = getSnapshot),
		      (getSnapshot.stores = [fiber]))
		    : ((renderedSnapshot = getSnapshot.stores),
		      null === renderedSnapshot
		        ? (getSnapshot.stores = [fiber])
		        : renderedSnapshot.push(fiber));
		}
		function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		  inst.value = nextSnapshot;
		  inst.getSnapshot = getSnapshot;
		  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		}
		function subscribeToStore(fiber, inst, subscribe) {
		  return subscribe(function () {
		    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		  });
		}
		function checkIfSnapshotChanged(inst) {
		  var latestGetSnapshot = inst.getSnapshot;
		  inst = inst.value;
		  try {
		    var nextValue = latestGetSnapshot();
		    return !objectIs(inst, nextValue);
		  } catch (error) {
		    return true;
		  }
		}
		function forceStoreRerender(fiber) {
		  var root = enqueueConcurrentRenderForLane(fiber, 2);
		  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		}
		function mountStateImpl(initialState) {
		  var hook = mountWorkInProgressHook();
		  if ("function" === typeof initialState) {
		    var initialStateInitializer = initialState;
		    initialState = initialStateInitializer();
		    if (shouldDoubleInvokeUserFnsInHooksDEV) {
		      setIsStrictModeForDevtools(true);
		      try {
		        initialStateInitializer();
		      } finally {
		        setIsStrictModeForDevtools(false);
		      }
		    }
		  }
		  hook.memoizedState = hook.baseState = initialState;
		  hook.queue = {
		    pending: null,
		    lanes: 0,
		    dispatch: null,
		    lastRenderedReducer: basicStateReducer,
		    lastRenderedState: initialState
		  };
		  return hook;
		}
		function updateOptimisticImpl(hook, current, passthrough, reducer) {
		  hook.baseState = passthrough;
		  return updateReducerImpl(
		    hook,
		    currentHook,
		    "function" === typeof reducer ? reducer : basicStateReducer
		  );
		}
		function dispatchActionState(
		  fiber,
		  actionQueue,
		  setPendingState,
		  setState,
		  payload
		) {
		  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
		  fiber = actionQueue.action;
		  if (null !== fiber) {
		    var actionNode = {
		      payload: payload,
		      action: fiber,
		      next: null,
		      isTransition: true,
		      status: "pending",
		      value: null,
		      reason: null,
		      listeners: [],
		      then: function (listener) {
		        actionNode.listeners.push(listener);
		      }
		    };
		    null !== ReactSharedInternals.T
		      ? setPendingState(true)
		      : (actionNode.isTransition = false);
		    setState(actionNode);
		    setPendingState = actionQueue.pending;
		    null === setPendingState
		      ? ((actionNode.next = actionQueue.pending = actionNode),
		        runActionStateAction(actionQueue, actionNode))
		      : ((actionNode.next = setPendingState.next),
		        (actionQueue.pending = setPendingState.next = actionNode));
		  }
		}
		function runActionStateAction(actionQueue, node) {
		  var action = node.action,
		    payload = node.payload,
		    prevState = actionQueue.state;
		  if (node.isTransition) {
		    var prevTransition = ReactSharedInternals.T,
		      currentTransition = {};
		    ReactSharedInternals.T = currentTransition;
		    try {
		      var returnValue = action(prevState, payload),
		        onStartTransitionFinish = ReactSharedInternals.S;
		      null !== onStartTransitionFinish &&
		        onStartTransitionFinish(currentTransition, returnValue);
		      handleActionReturnValue(actionQueue, node, returnValue);
		    } catch (error) {
		      onActionError(actionQueue, node, error);
		    } finally {
		      ReactSharedInternals.T = prevTransition;
		    }
		  } else
		    try {
		      (prevTransition = action(prevState, payload)),
		        handleActionReturnValue(actionQueue, node, prevTransition);
		    } catch (error$38) {
		      onActionError(actionQueue, node, error$38);
		    }
		}
		function handleActionReturnValue(actionQueue, node, returnValue) {
		  null !== returnValue &&
		  "object" === typeof returnValue &&
		  "function" === typeof returnValue.then
		    ? returnValue.then(
		        function (nextState) {
		          onActionSuccess(actionQueue, node, nextState);
		        },
		        function (error) {
		          return onActionError(actionQueue, node, error);
		        }
		      )
		    : onActionSuccess(actionQueue, node, returnValue);
		}
		function onActionSuccess(actionQueue, actionNode, nextState) {
		  actionNode.status = "fulfilled";
		  actionNode.value = nextState;
		  notifyActionListeners(actionNode);
		  actionQueue.state = nextState;
		  actionNode = actionQueue.pending;
		  null !== actionNode &&
		    ((nextState = actionNode.next),
		    nextState === actionNode
		      ? (actionQueue.pending = null)
		      : ((nextState = nextState.next),
		        (actionNode.next = nextState),
		        runActionStateAction(actionQueue, nextState)));
		}
		function onActionError(actionQueue, actionNode, error) {
		  var last = actionQueue.pending;
		  actionQueue.pending = null;
		  if (null !== last) {
		    last = last.next;
		    do
		      (actionNode.status = "rejected"),
		        (actionNode.reason = error),
		        notifyActionListeners(actionNode),
		        (actionNode = actionNode.next);
		    while (actionNode !== last);
		  }
		  actionQueue.action = null;
		}
		function notifyActionListeners(actionNode) {
		  actionNode = actionNode.listeners;
		  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
		}
		function actionStateReducer(oldState, newState) {
		  return newState;
		}
		function mountActionState(action, initialStateProp) {
		  if (isHydrating) {
		    var ssrFormState = workInProgressRoot.formState;
		    if (null !== ssrFormState) {
		      a: {
		        var JSCompiler_inline_result = currentlyRenderingFiber;
		        if (isHydrating) {
		          if (nextHydratableInstance) {
		            b: {
		              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
		              for (
		                var inRootOrSingleton = rootOrSingletonContext;
		                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

		              ) {
		                if (!inRootOrSingleton) {
		                  JSCompiler_inline_result$jscomp$0 = null;
		                  break b;
		                }
		                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
		                  JSCompiler_inline_result$jscomp$0.nextSibling
		                );
		                if (null === JSCompiler_inline_result$jscomp$0) {
		                  JSCompiler_inline_result$jscomp$0 = null;
		                  break b;
		                }
		              }
		              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
		              JSCompiler_inline_result$jscomp$0 =
		                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
		                  ? JSCompiler_inline_result$jscomp$0
		                  : null;
		            }
		            if (JSCompiler_inline_result$jscomp$0) {
		              nextHydratableInstance = getNextHydratable(
		                JSCompiler_inline_result$jscomp$0.nextSibling
		              );
		              JSCompiler_inline_result =
		                "F!" === JSCompiler_inline_result$jscomp$0.data;
		              break a;
		            }
		          }
		          throwOnHydrationMismatch(JSCompiler_inline_result);
		        }
		        JSCompiler_inline_result = false;
		      }
		      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
		    }
		  }
		  ssrFormState = mountWorkInProgressHook();
		  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		  JSCompiler_inline_result = {
		    pending: null,
		    lanes: 0,
		    dispatch: null,
		    lastRenderedReducer: actionStateReducer,
		    lastRenderedState: initialStateProp
		  };
		  ssrFormState.queue = JSCompiler_inline_result;
		  ssrFormState = dispatchSetState.bind(
		    null,
		    currentlyRenderingFiber,
		    JSCompiler_inline_result
		  );
		  JSCompiler_inline_result.dispatch = ssrFormState;
		  JSCompiler_inline_result = mountStateImpl(false);
		  inRootOrSingleton = dispatchOptimisticSetState.bind(
		    null,
		    currentlyRenderingFiber,
		    false,
		    JSCompiler_inline_result.queue
		  );
		  JSCompiler_inline_result = mountWorkInProgressHook();
		  JSCompiler_inline_result$jscomp$0 = {
		    state: initialStateProp,
		    dispatch: null,
		    action: action,
		    pending: null
		  };
		  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
		  ssrFormState = dispatchActionState.bind(
		    null,
		    currentlyRenderingFiber,
		    JSCompiler_inline_result$jscomp$0,
		    inRootOrSingleton,
		    ssrFormState
		  );
		  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
		  JSCompiler_inline_result.memoizedState = action;
		  return [initialStateProp, ssrFormState, false];
		}
		function updateActionState(action) {
		  var stateHook = updateWorkInProgressHook();
		  return updateActionStateImpl(stateHook, currentHook, action);
		}
		function updateActionStateImpl(stateHook, currentStateHook, action) {
		  currentStateHook = updateReducerImpl(
		    stateHook,
		    currentStateHook,
		    actionStateReducer
		  )[0];
		  stateHook = updateReducer(basicStateReducer)[0];
		  if (
		    "object" === typeof currentStateHook &&
		    null !== currentStateHook &&
		    "function" === typeof currentStateHook.then
		  )
		    try {
		      var state = useThenable(currentStateHook);
		    } catch (x) {
		      if (x === SuspenseException) throw SuspenseActionException;
		      throw x;
		    }
		  else state = currentStateHook;
		  currentStateHook = updateWorkInProgressHook();
		  var actionQueue = currentStateHook.queue,
		    dispatch = actionQueue.dispatch;
		  action !== currentStateHook.memoizedState &&
		    ((currentlyRenderingFiber.flags |= 2048),
		    pushSimpleEffect(
		      9,
		      createEffectInstance(),
		      actionStateActionEffect.bind(null, actionQueue, action),
		      null
		    ));
		  return [state, dispatch, stateHook];
		}
		function actionStateActionEffect(actionQueue, action) {
		  actionQueue.action = action;
		}
		function rerenderActionState(action) {
		  var stateHook = updateWorkInProgressHook(),
		    currentStateHook = currentHook;
		  if (null !== currentStateHook)
		    return updateActionStateImpl(stateHook, currentStateHook, action);
		  updateWorkInProgressHook();
		  stateHook = stateHook.memoizedState;
		  currentStateHook = updateWorkInProgressHook();
		  var dispatch = currentStateHook.queue.dispatch;
		  currentStateHook.memoizedState = action;
		  return [stateHook, dispatch, false];
		}
		function pushSimpleEffect(tag, inst, create, createDeps) {
		  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };
		  inst = currentlyRenderingFiber.updateQueue;
		  null === inst &&
		    ((inst = createFunctionComponentUpdateQueue()),
		    (currentlyRenderingFiber.updateQueue = inst));
		  create = inst.lastEffect;
		  null === create
		    ? (inst.lastEffect = tag.next = tag)
		    : ((createDeps = create.next),
		      (create.next = tag),
		      (tag.next = createDeps),
		      (inst.lastEffect = tag));
		  return tag;
		}
		function createEffectInstance() {
		  return { destroy: void 0, resource: void 0 };
		}
		function updateRef() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
		  var hook = mountWorkInProgressHook();
		  createDeps = void 0 === createDeps ? null : createDeps;
		  currentlyRenderingFiber.flags |= fiberFlags;
		  hook.memoizedState = pushSimpleEffect(
		    1 | hookFlags,
		    createEffectInstance(),
		    create,
		    createDeps
		  );
		}
		function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var inst = hook.memoizedState.inst;
		  null !== currentHook &&
		  null !== deps &&
		  areHookInputsEqual(deps, currentHook.memoizedState.deps)
		    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
		    : ((currentlyRenderingFiber.flags |= fiberFlags),
		      (hook.memoizedState = pushSimpleEffect(
		        1 | hookFlags,
		        inst,
		        create,
		        deps
		      )));
		}
		function mountEffect(create, createDeps) {
		  mountEffectImpl(8390656, 8, create, createDeps);
		}
		function updateEffect(create, createDeps) {
		  updateEffectImpl(2048, 8, create, createDeps);
		}
		function updateInsertionEffect(create, deps) {
		  return updateEffectImpl(4, 2, create, deps);
		}
		function updateLayoutEffect(create, deps) {
		  return updateEffectImpl(4, 4, create, deps);
		}
		function imperativeHandleEffect(create, ref) {
		  if ("function" === typeof ref) {
		    create = create();
		    var refCleanup = ref(create);
		    return function () {
		      "function" === typeof refCleanup ? refCleanup() : ref(null);
		    };
		  }
		  if (null !== ref && void 0 !== ref)
		    return (
		      (create = create()),
		      (ref.current = create),
		      function () {
		        ref.current = null;
		      }
		    );
		}
		function updateImperativeHandle(ref, create, deps) {
		  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
		}
		function mountDebugValue() {}
		function updateCallback(callback, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var prevState = hook.memoizedState;
		  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		    return prevState[0];
		  hook.memoizedState = [callback, deps];
		  return callback;
		}
		function updateMemo(nextCreate, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var prevState = hook.memoizedState;
		  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		    return prevState[0];
		  prevState = nextCreate();
		  if (shouldDoubleInvokeUserFnsInHooksDEV) {
		    setIsStrictModeForDevtools(true);
		    try {
		      nextCreate();
		    } finally {
		      setIsStrictModeForDevtools(false);
		    }
		  }
		  hook.memoizedState = [prevState, deps];
		  return prevState;
		}
		function mountDeferredValueImpl(hook, value, initialValue) {
		  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
		    return (hook.memoizedState = value);
		  hook.memoizedState = initialValue;
		  hook = requestDeferredLane();
		  currentlyRenderingFiber.lanes |= hook;
		  workInProgressRootSkippedLanes |= hook;
		  return initialValue;
		}
		function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		  if (objectIs(value, prevValue)) return value;
		  if (null !== currentTreeHiddenStackCursor.current)
		    return (
		      (hook = mountDeferredValueImpl(hook, value, initialValue)),
		      objectIs(hook, prevValue) || (didReceiveUpdate = true),
		      hook
		    );
		  if (0 === (renderLanes & 42))
		    return (didReceiveUpdate = true), (hook.memoizedState = value);
		  hook = requestDeferredLane();
		  currentlyRenderingFiber.lanes |= hook;
		  workInProgressRootSkippedLanes |= hook;
		  return prevValue;
		}
		function startTransition(fiber, queue, pendingState, finishedState, callback) {
		  var previousPriority = ReactDOMSharedInternals.p;
		  ReactDOMSharedInternals.p =
		    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
		  var prevTransition = ReactSharedInternals.T,
		    currentTransition = {};
		  ReactSharedInternals.T = currentTransition;
		  dispatchOptimisticSetState(fiber, false, queue, pendingState);
		  try {
		    var returnValue = callback(),
		      onStartTransitionFinish = ReactSharedInternals.S;
		    null !== onStartTransitionFinish &&
		      onStartTransitionFinish(currentTransition, returnValue);
		    if (
		      null !== returnValue &&
		      "object" === typeof returnValue &&
		      "function" === typeof returnValue.then
		    ) {
		      var thenableForFinishedState = chainThenableValue(
		        returnValue,
		        finishedState
		      );
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        thenableForFinishedState,
		        requestUpdateLane(fiber)
		      );
		    } else
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        finishedState,
		        requestUpdateLane(fiber)
		      );
		  } catch (error) {
		    dispatchSetStateInternal(
		      fiber,
		      queue,
		      { then: function () {}, status: "rejected", reason: error },
		      requestUpdateLane()
		    );
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function noop$2() {}
		function startHostTransition(formFiber, pendingState, action, formData) {
		  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
		  var queue = ensureFormComponentIsStateful(formFiber).queue;
		  startTransition(
		    formFiber,
		    queue,
		    pendingState,
		    sharedNotPendingObject,
		    null === action
		      ? noop$2
		      : function () {
		          requestFormReset$1(formFiber);
		          return action(formData);
		        }
		  );
		}
		function ensureFormComponentIsStateful(formFiber) {
		  var existingStateHook = formFiber.memoizedState;
		  if (null !== existingStateHook) return existingStateHook;
		  existingStateHook = {
		    memoizedState: sharedNotPendingObject,
		    baseState: sharedNotPendingObject,
		    baseQueue: null,
		    queue: {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: basicStateReducer,
		      lastRenderedState: sharedNotPendingObject
		    },
		    next: null
		  };
		  var initialResetState = {};
		  existingStateHook.next = {
		    memoizedState: initialResetState,
		    baseState: initialResetState,
		    baseQueue: null,
		    queue: {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: basicStateReducer,
		      lastRenderedState: initialResetState
		    },
		    next: null
		  };
		  formFiber.memoizedState = existingStateHook;
		  formFiber = formFiber.alternate;
		  null !== formFiber && (formFiber.memoizedState = existingStateHook);
		  return existingStateHook;
		}
		function requestFormReset$1(formFiber) {
		  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
		  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
		}
		function useHostTransitionStatus() {
		  return readContext(HostTransitionContext);
		}
		function updateId() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function updateRefresh() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function refreshCache(fiber) {
		  for (var provider = fiber.return; null !== provider; ) {
		    switch (provider.tag) {
		      case 24:
		      case 3:
		        var lane = requestUpdateLane();
		        fiber = createUpdate(lane);
		        var root$41 = enqueueUpdate(provider, fiber, lane);
		        null !== root$41 &&
		          (scheduleUpdateOnFiber(root$41, provider, lane),
		          entangleTransitions(root$41, provider, lane));
		        provider = { cache: createCache() };
		        fiber.payload = provider;
		        return;
		    }
		    provider = provider.return;
		  }
		}
		function dispatchReducerAction(fiber, queue, action) {
		  var lane = requestUpdateLane();
		  action = {
		    lane: lane,
		    revertLane: 0,
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  isRenderPhaseUpdate(fiber)
		    ? enqueueRenderPhaseUpdate(queue, action)
		    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
		      null !== action &&
		        (scheduleUpdateOnFiber(action, fiber, lane),
		        entangleTransitionUpdate(action, queue, lane)));
		}
		function dispatchSetState(fiber, queue, action) {
		  var lane = requestUpdateLane();
		  dispatchSetStateInternal(fiber, queue, action, lane);
		}
		function dispatchSetStateInternal(fiber, queue, action, lane) {
		  var update = {
		    lane: lane,
		    revertLane: 0,
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		  else {
		    var alternate = fiber.alternate;
		    if (
		      0 === fiber.lanes &&
		      (null === alternate || 0 === alternate.lanes) &&
		      ((alternate = queue.lastRenderedReducer), null !== alternate)
		    )
		      try {
		        var currentState = queue.lastRenderedState,
		          eagerState = alternate(currentState, action);
		        update.hasEagerState = !0;
		        update.eagerState = eagerState;
		        if (objectIs(eagerState, currentState))
		          return (
		            enqueueUpdate$1(fiber, queue, update, 0),
		            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
		            !1
		          );
		      } catch (error) {
		      } finally {
		      }
		    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
		    if (null !== action)
		      return (
		        scheduleUpdateOnFiber(action, fiber, lane),
		        entangleTransitionUpdate(action, queue, lane),
		        true
		      );
		  }
		  return false;
		}
		function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
		  action = {
		    lane: 2,
		    revertLane: requestTransitionLane(),
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  if (isRenderPhaseUpdate(fiber)) {
		    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
		  } else
		    (throwIfDuringRender = enqueueConcurrentHookUpdate(
		      fiber,
		      queue,
		      action,
		      2
		    )),
		      null !== throwIfDuringRender &&
		        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
		}
		function isRenderPhaseUpdate(fiber) {
		  var alternate = fiber.alternate;
		  return (
		    fiber === currentlyRenderingFiber ||
		    (null !== alternate && alternate === currentlyRenderingFiber)
		  );
		}
		function enqueueRenderPhaseUpdate(queue, update) {
		  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
		    true;
		  var pending = queue.pending;
		  null === pending
		    ? (update.next = update)
		    : ((update.next = pending.next), (pending.next = update));
		  queue.pending = update;
		}
		function entangleTransitionUpdate(root, queue, lane) {
		  if (0 !== (lane & 4194048)) {
		    var queueLanes = queue.lanes;
		    queueLanes &= root.pendingLanes;
		    lane |= queueLanes;
		    queue.lanes = lane;
		    markRootEntangled(root, lane);
		  }
		}
		var ContextOnlyDispatcher = {
		    readContext: readContext,
		    use: use,
		    useCallback: throwInvalidHookError,
		    useContext: throwInvalidHookError,
		    useEffect: throwInvalidHookError,
		    useImperativeHandle: throwInvalidHookError,
		    useLayoutEffect: throwInvalidHookError,
		    useInsertionEffect: throwInvalidHookError,
		    useMemo: throwInvalidHookError,
		    useReducer: throwInvalidHookError,
		    useRef: throwInvalidHookError,
		    useState: throwInvalidHookError,
		    useDebugValue: throwInvalidHookError,
		    useDeferredValue: throwInvalidHookError,
		    useTransition: throwInvalidHookError,
		    useSyncExternalStore: throwInvalidHookError,
		    useId: throwInvalidHookError,
		    useHostTransitionStatus: throwInvalidHookError,
		    useFormState: throwInvalidHookError,
		    useActionState: throwInvalidHookError,
		    useOptimistic: throwInvalidHookError,
		    useMemoCache: throwInvalidHookError,
		    useCacheRefresh: throwInvalidHookError
		  },
		  HooksDispatcherOnMount = {
		    readContext: readContext,
		    use: use,
		    useCallback: function (callback, deps) {
		      mountWorkInProgressHook().memoizedState = [
		        callback,
		        void 0 === deps ? null : deps
		      ];
		      return callback;
		    },
		    useContext: readContext,
		    useEffect: mountEffect,
		    useImperativeHandle: function (ref, create, deps) {
		      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		      mountEffectImpl(
		        4194308,
		        4,
		        imperativeHandleEffect.bind(null, create, ref),
		        deps
		      );
		    },
		    useLayoutEffect: function (create, deps) {
		      return mountEffectImpl(4194308, 4, create, deps);
		    },
		    useInsertionEffect: function (create, deps) {
		      mountEffectImpl(4, 2, create, deps);
		    },
		    useMemo: function (nextCreate, deps) {
		      var hook = mountWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var nextValue = nextCreate();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          nextCreate();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      hook.memoizedState = [nextValue, deps];
		      return nextValue;
		    },
		    useReducer: function (reducer, initialArg, init) {
		      var hook = mountWorkInProgressHook();
		      if (void 0 !== init) {
		        var initialState = init(initialArg);
		        if (shouldDoubleInvokeUserFnsInHooksDEV) {
		          setIsStrictModeForDevtools(true);
		          try {
		            init(initialArg);
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		      } else initialState = initialArg;
		      hook.memoizedState = hook.baseState = initialState;
		      reducer = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: reducer,
		        lastRenderedState: initialState
		      };
		      hook.queue = reducer;
		      reducer = reducer.dispatch = dispatchReducerAction.bind(
		        null,
		        currentlyRenderingFiber,
		        reducer
		      );
		      return [hook.memoizedState, reducer];
		    },
		    useRef: function (initialValue) {
		      var hook = mountWorkInProgressHook();
		      initialValue = { current: initialValue };
		      return (hook.memoizedState = initialValue);
		    },
		    useState: function (initialState) {
		      initialState = mountStateImpl(initialState);
		      var queue = initialState.queue,
		        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
		      queue.dispatch = dispatch;
		      return [initialState.memoizedState, dispatch];
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = mountWorkInProgressHook();
		      return mountDeferredValueImpl(hook, value, initialValue);
		    },
		    useTransition: function () {
		      var stateHook = mountStateImpl(false);
		      stateHook = startTransition.bind(
		        null,
		        currentlyRenderingFiber,
		        stateHook.queue,
		        true,
		        false
		      );
		      mountWorkInProgressHook().memoizedState = stateHook;
		      return [false, stateHook];
		    },
		    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
		      var fiber = currentlyRenderingFiber,
		        hook = mountWorkInProgressHook();
		      if (isHydrating) {
		        if (void 0 === getServerSnapshot)
		          throw Error(formatProdErrorMessage(407));
		        getServerSnapshot = getServerSnapshot();
		      } else {
		        getServerSnapshot = getSnapshot();
		        if (null === workInProgressRoot)
		          throw Error(formatProdErrorMessage(349));
		        0 !== (workInProgressRootRenderLanes & 124) ||
		          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		      }
		      hook.memoizedState = getServerSnapshot;
		      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
		      hook.queue = inst;
		      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
		        subscribe
		      ]);
		      fiber.flags |= 2048;
		      pushSimpleEffect(
		        9,
		        createEffectInstance(),
		        updateStoreInstance.bind(
		          null,
		          fiber,
		          inst,
		          getServerSnapshot,
		          getSnapshot
		        ),
		        null
		      );
		      return getServerSnapshot;
		    },
		    useId: function () {
		      var hook = mountWorkInProgressHook(),
		        identifierPrefix = workInProgressRoot.identifierPrefix;
		      if (isHydrating) {
		        var JSCompiler_inline_result = treeContextOverflow;
		        var idWithLeadingBit = treeContextId;
		        JSCompiler_inline_result =
		          (
		            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
		          ).toString(32) + JSCompiler_inline_result;
		        identifierPrefix =
		          "\u00ab" + identifierPrefix + "R" + JSCompiler_inline_result;
		        JSCompiler_inline_result = localIdCounter++;
		        0 < JSCompiler_inline_result &&
		          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
		        identifierPrefix += "\u00bb";
		      } else
		        (JSCompiler_inline_result = globalClientIdCounter++),
		          (identifierPrefix =
		            "\u00ab" +
		            identifierPrefix +
		            "r" +
		            JSCompiler_inline_result.toString(32) +
		            "\u00bb");
		      return (hook.memoizedState = identifierPrefix);
		    },
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: mountActionState,
		    useActionState: mountActionState,
		    useOptimistic: function (passthrough) {
		      var hook = mountWorkInProgressHook();
		      hook.memoizedState = hook.baseState = passthrough;
		      var queue = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: null,
		        lastRenderedState: null
		      };
		      hook.queue = queue;
		      hook = dispatchOptimisticSetState.bind(
		        null,
		        currentlyRenderingFiber,
		        true,
		        queue
		      );
		      queue.dispatch = hook;
		      return [passthrough, hook];
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: function () {
		      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
		        null,
		        currentlyRenderingFiber
		      ));
		    }
		  },
		  HooksDispatcherOnUpdate = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: updateReducer,
		    useRef: updateRef,
		    useState: function () {
		      return updateReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return updateDeferredValueImpl(
		        hook,
		        currentHook.memoizedState,
		        value,
		        initialValue
		      );
		    },
		    useTransition: function () {
		      var booleanOrThenable = updateReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId,
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: updateActionState,
		    useActionState: updateActionState,
		    useOptimistic: function (passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: updateRefresh
		  },
		  HooksDispatcherOnRerender = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: rerenderReducer,
		    useRef: updateRef,
		    useState: function () {
		      return rerenderReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return null === currentHook
		        ? mountDeferredValueImpl(hook, value, initialValue)
		        : updateDeferredValueImpl(
		            hook,
		            currentHook.memoizedState,
		            value,
		            initialValue
		          );
		    },
		    useTransition: function () {
		      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId,
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: rerenderActionState,
		    useActionState: rerenderActionState,
		    useOptimistic: function (passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      if (null !== currentHook)
		        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		      hook.baseState = passthrough;
		      return [passthrough, hook.queue.dispatch];
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: updateRefresh
		  },
		  thenableState = null,
		  thenableIndexCounter = 0;
		function unwrapThenable(thenable) {
		  var index = thenableIndexCounter;
		  thenableIndexCounter += 1;
		  null === thenableState && (thenableState = []);
		  return trackUsedThenable(thenableState, thenable, index);
		}
		function coerceRef(workInProgress, element) {
		  element = element.props.ref;
		  workInProgress.ref = void 0 !== element ? element : null;
		}
		function throwOnInvalidObjectType(returnFiber, newChild) {
		  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
		    throw Error(formatProdErrorMessage(525));
		  returnFiber = Object.prototype.toString.call(newChild);
		  throw Error(
		    formatProdErrorMessage(
		      31,
		      "[object Object]" === returnFiber
		        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
		        : returnFiber
		    )
		  );
		}
		function resolveLazy(lazyType) {
		  var init = lazyType._init;
		  return init(lazyType._payload);
		}
		function createChildReconciler(shouldTrackSideEffects) {
		  function deleteChild(returnFiber, childToDelete) {
		    if (shouldTrackSideEffects) {
		      var deletions = returnFiber.deletions;
		      null === deletions
		        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
		        : deletions.push(childToDelete);
		    }
		  }
		  function deleteRemainingChildren(returnFiber, currentFirstChild) {
		    if (!shouldTrackSideEffects) return null;
		    for (; null !== currentFirstChild; )
		      deleteChild(returnFiber, currentFirstChild),
		        (currentFirstChild = currentFirstChild.sibling);
		    return null;
		  }
		  function mapRemainingChildren(currentFirstChild) {
		    for (var existingChildren = new Map(); null !== currentFirstChild; )
		      null !== currentFirstChild.key
		        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
		        : existingChildren.set(currentFirstChild.index, currentFirstChild),
		        (currentFirstChild = currentFirstChild.sibling);
		    return existingChildren;
		  }
		  function useFiber(fiber, pendingProps) {
		    fiber = createWorkInProgress(fiber, pendingProps);
		    fiber.index = 0;
		    fiber.sibling = null;
		    return fiber;
		  }
		  function placeChild(newFiber, lastPlacedIndex, newIndex) {
		    newFiber.index = newIndex;
		    if (!shouldTrackSideEffects)
		      return (newFiber.flags |= 1048576), lastPlacedIndex;
		    newIndex = newFiber.alternate;
		    if (null !== newIndex)
		      return (
		        (newIndex = newIndex.index),
		        newIndex < lastPlacedIndex
		          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
		          : newIndex
		      );
		    newFiber.flags |= 67108866;
		    return lastPlacedIndex;
		  }
		  function placeSingleChild(newFiber) {
		    shouldTrackSideEffects &&
		      null === newFiber.alternate &&
		      (newFiber.flags |= 67108866);
		    return newFiber;
		  }
		  function updateTextNode(returnFiber, current, textContent, lanes) {
		    if (null === current || 6 !== current.tag)
		      return (
		        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, textContent);
		    current.return = returnFiber;
		    return current;
		  }
		  function updateElement(returnFiber, current, element, lanes) {
		    var elementType = element.type;
		    if (elementType === REACT_FRAGMENT_TYPE)
		      return updateFragment(
		        returnFiber,
		        current,
		        element.props.children,
		        lanes,
		        element.key
		      );
		    if (
		      null !== current &&
		      (current.elementType === elementType ||
		        ("object" === typeof elementType &&
		          null !== elementType &&
		          elementType.$$typeof === REACT_LAZY_TYPE &&
		          resolveLazy(elementType) === current.type))
		    )
		      return (
		        (current = useFiber(current, element.props)),
		        coerceRef(current, element),
		        (current.return = returnFiber),
		        current
		      );
		    current = createFiberFromTypeAndProps(
		      element.type,
		      element.key,
		      element.props,
		      null,
		      returnFiber.mode,
		      lanes
		    );
		    coerceRef(current, element);
		    current.return = returnFiber;
		    return current;
		  }
		  function updatePortal(returnFiber, current, portal, lanes) {
		    if (
		      null === current ||
		      4 !== current.tag ||
		      current.stateNode.containerInfo !== portal.containerInfo ||
		      current.stateNode.implementation !== portal.implementation
		    )
		      return (
		        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, portal.children || []);
		    current.return = returnFiber;
		    return current;
		  }
		  function updateFragment(returnFiber, current, fragment, lanes, key) {
		    if (null === current || 7 !== current.tag)
		      return (
		        (current = createFiberFromFragment(
		          fragment,
		          returnFiber.mode,
		          lanes,
		          key
		        )),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, fragment);
		    current.return = returnFiber;
		    return current;
		  }
		  function createChild(returnFiber, newChild, lanes) {
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return (
		        (newChild = createFiberFromText(
		          "" + newChild,
		          returnFiber.mode,
		          lanes
		        )),
		        (newChild.return = returnFiber),
		        newChild
		      );
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return (
		            (lanes = createFiberFromTypeAndProps(
		              newChild.type,
		              newChild.key,
		              newChild.props,
		              null,
		              returnFiber.mode,
		              lanes
		            )),
		            coerceRef(lanes, newChild),
		            (lanes.return = returnFiber),
		            lanes
		          );
		        case REACT_PORTAL_TYPE:
		          return (
		            (newChild = createFiberFromPortal(
		              newChild,
		              returnFiber.mode,
		              lanes
		            )),
		            (newChild.return = returnFiber),
		            newChild
		          );
		        case REACT_LAZY_TYPE:
		          var init = newChild._init;
		          newChild = init(newChild._payload);
		          return createChild(returnFiber, newChild, lanes);
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return (
		          (newChild = createFiberFromFragment(
		            newChild,
		            returnFiber.mode,
		            lanes,
		            null
		          )),
		          (newChild.return = returnFiber),
		          newChild
		        );
		      if ("function" === typeof newChild.then)
		        return createChild(returnFiber, unwrapThenable(newChild), lanes);
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return createChild(
		          returnFiber,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
		    var key = null !== oldFiber ? oldFiber.key : null;
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return null !== key
		        ? null
		        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return newChild.key === key
		            ? updateElement(returnFiber, oldFiber, newChild, lanes)
		            : null;
		        case REACT_PORTAL_TYPE:
		          return newChild.key === key
		            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
		            : null;
		        case REACT_LAZY_TYPE:
		          return (
		            (key = newChild._init),
		            (newChild = key(newChild._payload)),
		            updateSlot(returnFiber, oldFiber, newChild, lanes)
		          );
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return null !== key
		          ? null
		          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
		      if ("function" === typeof newChild.then)
		        return updateSlot(
		          returnFiber,
		          oldFiber,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return updateSlot(
		          returnFiber,
		          oldFiber,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function updateFromMap(
		    existingChildren,
		    returnFiber,
		    newIdx,
		    newChild,
		    lanes
		  ) {
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return (
		        (existingChildren = existingChildren.get(newIdx) || null),
		        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
		      );
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return (
		            (existingChildren =
		              existingChildren.get(
		                null === newChild.key ? newIdx : newChild.key
		              ) || null),
		            updateElement(returnFiber, existingChildren, newChild, lanes)
		          );
		        case REACT_PORTAL_TYPE:
		          return (
		            (existingChildren =
		              existingChildren.get(
		                null === newChild.key ? newIdx : newChild.key
		              ) || null),
		            updatePortal(returnFiber, existingChildren, newChild, lanes)
		          );
		        case REACT_LAZY_TYPE:
		          var init = newChild._init;
		          newChild = init(newChild._payload);
		          return updateFromMap(
		            existingChildren,
		            returnFiber,
		            newIdx,
		            newChild,
		            lanes
		          );
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return (
		          (existingChildren = existingChildren.get(newIdx) || null),
		          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
		        );
		      if ("function" === typeof newChild.then)
		        return updateFromMap(
		          existingChildren,
		          returnFiber,
		          newIdx,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return updateFromMap(
		          existingChildren,
		          returnFiber,
		          newIdx,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function reconcileChildrenArray(
		    returnFiber,
		    currentFirstChild,
		    newChildren,
		    lanes
		  ) {
		    for (
		      var resultingFirstChild = null,
		        previousNewFiber = null,
		        oldFiber = currentFirstChild,
		        newIdx = (currentFirstChild = 0),
		        nextOldFiber = null;
		      null !== oldFiber && newIdx < newChildren.length;
		      newIdx++
		    ) {
		      oldFiber.index > newIdx
		        ? ((nextOldFiber = oldFiber), (oldFiber = null))
		        : (nextOldFiber = oldFiber.sibling);
		      var newFiber = updateSlot(
		        returnFiber,
		        oldFiber,
		        newChildren[newIdx],
		        lanes
		      );
		      if (null === newFiber) {
		        null === oldFiber && (oldFiber = nextOldFiber);
		        break;
		      }
		      shouldTrackSideEffects &&
		        oldFiber &&
		        null === newFiber.alternate &&
		        deleteChild(returnFiber, oldFiber);
		      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		      null === previousNewFiber
		        ? (resultingFirstChild = newFiber)
		        : (previousNewFiber.sibling = newFiber);
		      previousNewFiber = newFiber;
		      oldFiber = nextOldFiber;
		    }
		    if (newIdx === newChildren.length)
		      return (
		        deleteRemainingChildren(returnFiber, oldFiber),
		        isHydrating && pushTreeFork(returnFiber, newIdx),
		        resultingFirstChild
		      );
		    if (null === oldFiber) {
		      for (; newIdx < newChildren.length; newIdx++)
		        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
		          null !== oldFiber &&
		            ((currentFirstChild = placeChild(
		              oldFiber,
		              currentFirstChild,
		              newIdx
		            )),
		            null === previousNewFiber
		              ? (resultingFirstChild = oldFiber)
		              : (previousNewFiber.sibling = oldFiber),
		            (previousNewFiber = oldFiber));
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    for (
		      oldFiber = mapRemainingChildren(oldFiber);
		      newIdx < newChildren.length;
		      newIdx++
		    )
		      (nextOldFiber = updateFromMap(
		        oldFiber,
		        returnFiber,
		        newIdx,
		        newChildren[newIdx],
		        lanes
		      )),
		        null !== nextOldFiber &&
		          (shouldTrackSideEffects &&
		            null !== nextOldFiber.alternate &&
		            oldFiber.delete(
		              null === nextOldFiber.key ? newIdx : nextOldFiber.key
		            ),
		          (currentFirstChild = placeChild(
		            nextOldFiber,
		            currentFirstChild,
		            newIdx
		          )),
		          null === previousNewFiber
		            ? (resultingFirstChild = nextOldFiber)
		            : (previousNewFiber.sibling = nextOldFiber),
		          (previousNewFiber = nextOldFiber));
		    shouldTrackSideEffects &&
		      oldFiber.forEach(function (child) {
		        return deleteChild(returnFiber, child);
		      });
		    isHydrating && pushTreeFork(returnFiber, newIdx);
		    return resultingFirstChild;
		  }
		  function reconcileChildrenIterator(
		    returnFiber,
		    currentFirstChild,
		    newChildren,
		    lanes
		  ) {
		    if (null == newChildren) throw Error(formatProdErrorMessage(151));
		    for (
		      var resultingFirstChild = null,
		        previousNewFiber = null,
		        oldFiber = currentFirstChild,
		        newIdx = (currentFirstChild = 0),
		        nextOldFiber = null,
		        step = newChildren.next();
		      null !== oldFiber && !step.done;
		      newIdx++, step = newChildren.next()
		    ) {
		      oldFiber.index > newIdx
		        ? ((nextOldFiber = oldFiber), (oldFiber = null))
		        : (nextOldFiber = oldFiber.sibling);
		      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
		      if (null === newFiber) {
		        null === oldFiber && (oldFiber = nextOldFiber);
		        break;
		      }
		      shouldTrackSideEffects &&
		        oldFiber &&
		        null === newFiber.alternate &&
		        deleteChild(returnFiber, oldFiber);
		      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		      null === previousNewFiber
		        ? (resultingFirstChild = newFiber)
		        : (previousNewFiber.sibling = newFiber);
		      previousNewFiber = newFiber;
		      oldFiber = nextOldFiber;
		    }
		    if (step.done)
		      return (
		        deleteRemainingChildren(returnFiber, oldFiber),
		        isHydrating && pushTreeFork(returnFiber, newIdx),
		        resultingFirstChild
		      );
		    if (null === oldFiber) {
		      for (; !step.done; newIdx++, step = newChildren.next())
		        (step = createChild(returnFiber, step.value, lanes)),
		          null !== step &&
		            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
		            null === previousNewFiber
		              ? (resultingFirstChild = step)
		              : (previousNewFiber.sibling = step),
		            (previousNewFiber = step));
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    for (
		      oldFiber = mapRemainingChildren(oldFiber);
		      !step.done;
		      newIdx++, step = newChildren.next()
		    )
		      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
		        null !== step &&
		          (shouldTrackSideEffects &&
		            null !== step.alternate &&
		            oldFiber.delete(null === step.key ? newIdx : step.key),
		          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
		          null === previousNewFiber
		            ? (resultingFirstChild = step)
		            : (previousNewFiber.sibling = step),
		          (previousNewFiber = step));
		    shouldTrackSideEffects &&
		      oldFiber.forEach(function (child) {
		        return deleteChild(returnFiber, child);
		      });
		    isHydrating && pushTreeFork(returnFiber, newIdx);
		    return resultingFirstChild;
		  }
		  function reconcileChildFibersImpl(
		    returnFiber,
		    currentFirstChild,
		    newChild,
		    lanes
		  ) {
		    "object" === typeof newChild &&
		      null !== newChild &&
		      newChild.type === REACT_FRAGMENT_TYPE &&
		      null === newChild.key &&
		      (newChild = newChild.props.children);
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          a: {
		            for (var key = newChild.key; null !== currentFirstChild; ) {
		              if (currentFirstChild.key === key) {
		                key = newChild.type;
		                if (key === REACT_FRAGMENT_TYPE) {
		                  if (7 === currentFirstChild.tag) {
		                    deleteRemainingChildren(
		                      returnFiber,
		                      currentFirstChild.sibling
		                    );
		                    lanes = useFiber(
		                      currentFirstChild,
		                      newChild.props.children
		                    );
		                    lanes.return = returnFiber;
		                    returnFiber = lanes;
		                    break a;
		                  }
		                } else if (
		                  currentFirstChild.elementType === key ||
		                  ("object" === typeof key &&
		                    null !== key &&
		                    key.$$typeof === REACT_LAZY_TYPE &&
		                    resolveLazy(key) === currentFirstChild.type)
		                ) {
		                  deleteRemainingChildren(
		                    returnFiber,
		                    currentFirstChild.sibling
		                  );
		                  lanes = useFiber(currentFirstChild, newChild.props);
		                  coerceRef(lanes, newChild);
		                  lanes.return = returnFiber;
		                  returnFiber = lanes;
		                  break a;
		                }
		                deleteRemainingChildren(returnFiber, currentFirstChild);
		                break;
		              } else deleteChild(returnFiber, currentFirstChild);
		              currentFirstChild = currentFirstChild.sibling;
		            }
		            newChild.type === REACT_FRAGMENT_TYPE
		              ? ((lanes = createFiberFromFragment(
		                  newChild.props.children,
		                  returnFiber.mode,
		                  lanes,
		                  newChild.key
		                )),
		                (lanes.return = returnFiber),
		                (returnFiber = lanes))
		              : ((lanes = createFiberFromTypeAndProps(
		                  newChild.type,
		                  newChild.key,
		                  newChild.props,
		                  null,
		                  returnFiber.mode,
		                  lanes
		                )),
		                coerceRef(lanes, newChild),
		                (lanes.return = returnFiber),
		                (returnFiber = lanes));
		          }
		          return placeSingleChild(returnFiber);
		        case REACT_PORTAL_TYPE:
		          a: {
		            for (key = newChild.key; null !== currentFirstChild; ) {
		              if (currentFirstChild.key === key)
		                if (
		                  4 === currentFirstChild.tag &&
		                  currentFirstChild.stateNode.containerInfo ===
		                    newChild.containerInfo &&
		                  currentFirstChild.stateNode.implementation ===
		                    newChild.implementation
		                ) {
		                  deleteRemainingChildren(
		                    returnFiber,
		                    currentFirstChild.sibling
		                  );
		                  lanes = useFiber(currentFirstChild, newChild.children || []);
		                  lanes.return = returnFiber;
		                  returnFiber = lanes;
		                  break a;
		                } else {
		                  deleteRemainingChildren(returnFiber, currentFirstChild);
		                  break;
		                }
		              else deleteChild(returnFiber, currentFirstChild);
		              currentFirstChild = currentFirstChild.sibling;
		            }
		            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
		            lanes.return = returnFiber;
		            returnFiber = lanes;
		          }
		          return placeSingleChild(returnFiber);
		        case REACT_LAZY_TYPE:
		          return (
		            (key = newChild._init),
		            (newChild = key(newChild._payload)),
		            reconcileChildFibersImpl(
		              returnFiber,
		              currentFirstChild,
		              newChild,
		              lanes
		            )
		          );
		      }
		      if (isArrayImpl(newChild))
		        return reconcileChildrenArray(
		          returnFiber,
		          currentFirstChild,
		          newChild,
		          lanes
		        );
		      if (getIteratorFn(newChild)) {
		        key = getIteratorFn(newChild);
		        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
		        newChild = key.call(newChild);
		        return reconcileChildrenIterator(
		          returnFiber,
		          currentFirstChild,
		          newChild,
		          lanes
		        );
		      }
		      if ("function" === typeof newChild.then)
		        return reconcileChildFibersImpl(
		          returnFiber,
		          currentFirstChild,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return reconcileChildFibersImpl(
		          returnFiber,
		          currentFirstChild,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		      ? ((newChild = "" + newChild),
		        null !== currentFirstChild && 6 === currentFirstChild.tag
		          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
		            (lanes = useFiber(currentFirstChild, newChild)),
		            (lanes.return = returnFiber),
		            (returnFiber = lanes))
		          : (deleteRemainingChildren(returnFiber, currentFirstChild),
		            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
		            (lanes.return = returnFiber),
		            (returnFiber = lanes)),
		        placeSingleChild(returnFiber))
		      : deleteRemainingChildren(returnFiber, currentFirstChild);
		  }
		  return function (returnFiber, currentFirstChild, newChild, lanes) {
		    try {
		      thenableIndexCounter = 0;
		      var firstChildFiber = reconcileChildFibersImpl(
		        returnFiber,
		        currentFirstChild,
		        newChild,
		        lanes
		      );
		      thenableState = null;
		      return firstChildFiber;
		    } catch (x) {
		      if (x === SuspenseException || x === SuspenseActionException) throw x;
		      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
		      fiber.lanes = lanes;
		      fiber.return = returnFiber;
		      return fiber;
		    } finally {
		    }
		  };
		}
		var reconcileChildFibers = createChildReconciler(true),
		  mountChildFibers = createChildReconciler(false),
		  suspenseHandlerStackCursor = createCursor(null),
		  shellBoundary = null;
		function pushPrimaryTreeSuspenseHandler(handler) {
		  var current = handler.alternate;
		  push(suspenseStackCursor, suspenseStackCursor.current & 1);
		  push(suspenseHandlerStackCursor, handler);
		  null === shellBoundary &&
		    (null === current || null !== currentTreeHiddenStackCursor.current
		      ? (shellBoundary = handler)
		      : null !== current.memoizedState && (shellBoundary = handler));
		}
		function pushOffscreenSuspenseHandler(fiber) {
		  if (22 === fiber.tag) {
		    if (
		      (push(suspenseStackCursor, suspenseStackCursor.current),
		      push(suspenseHandlerStackCursor, fiber),
		      null === shellBoundary)
		    ) {
		      var current = fiber.alternate;
		      null !== current &&
		        null !== current.memoizedState &&
		        (shellBoundary = fiber);
		    }
		  } else reuseSuspenseHandlerOnStack();
		}
		function reuseSuspenseHandlerOnStack() {
		  push(suspenseStackCursor, suspenseStackCursor.current);
		  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
		}
		function popSuspenseHandler(fiber) {
		  pop(suspenseHandlerStackCursor);
		  shellBoundary === fiber && (shellBoundary = null);
		  pop(suspenseStackCursor);
		}
		var suspenseStackCursor = createCursor(0);
		function findFirstSuspended(row) {
		  for (var node = row; null !== node; ) {
		    if (13 === node.tag) {
		      var state = node.memoizedState;
		      if (
		        null !== state &&
		        ((state = state.dehydrated),
		        null === state ||
		          "$?" === state.data ||
		          isSuspenseInstanceFallback(state))
		      )
		        return node;
		    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
		      if (0 !== (node.flags & 128)) return node;
		    } else if (null !== node.child) {
		      node.child.return = node;
		      node = node.child;
		      continue;
		    }
		    if (node === row) break;
		    for (; null === node.sibling; ) {
		      if (null === node.return || node.return === row) return null;
		      node = node.return;
		    }
		    node.sibling.return = node.return;
		    node = node.sibling;
		  }
		  return null;
		}
		function applyDerivedStateFromProps(
		  workInProgress,
		  ctor,
		  getDerivedStateFromProps,
		  nextProps
		) {
		  ctor = workInProgress.memoizedState;
		  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
		  getDerivedStateFromProps =
		    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
		      ? ctor
		      : assign({}, ctor, getDerivedStateFromProps);
		  workInProgress.memoizedState = getDerivedStateFromProps;
		  0 === workInProgress.lanes &&
		    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
		}
		var classComponentUpdater = {
		  enqueueSetState: function (inst, payload, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.payload = payload;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    payload = enqueueUpdate(inst, update, lane);
		    null !== payload &&
		      (scheduleUpdateOnFiber(payload, inst, lane),
		      entangleTransitions(payload, inst, lane));
		  },
		  enqueueReplaceState: function (inst, payload, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.tag = 1;
		    update.payload = payload;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    payload = enqueueUpdate(inst, update, lane);
		    null !== payload &&
		      (scheduleUpdateOnFiber(payload, inst, lane),
		      entangleTransitions(payload, inst, lane));
		  },
		  enqueueForceUpdate: function (inst, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.tag = 2;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    callback = enqueueUpdate(inst, update, lane);
		    null !== callback &&
		      (scheduleUpdateOnFiber(callback, inst, lane),
		      entangleTransitions(callback, inst, lane));
		  }
		};
		function checkShouldComponentUpdate(
		  workInProgress,
		  ctor,
		  oldProps,
		  newProps,
		  oldState,
		  newState,
		  nextContext
		) {
		  workInProgress = workInProgress.stateNode;
		  return "function" === typeof workInProgress.shouldComponentUpdate
		    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
		    : ctor.prototype && ctor.prototype.isPureReactComponent
		      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
		      : true;
		}
		function callComponentWillReceiveProps(
		  workInProgress,
		  instance,
		  newProps,
		  nextContext
		) {
		  workInProgress = instance.state;
		  "function" === typeof instance.componentWillReceiveProps &&
		    instance.componentWillReceiveProps(newProps, nextContext);
		  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
		    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		  instance.state !== workInProgress &&
		    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
		}
		function resolveClassComponentProps(Component, baseProps) {
		  var newProps = baseProps;
		  if ("ref" in baseProps) {
		    newProps = {};
		    for (var propName in baseProps)
		      "ref" !== propName && (newProps[propName] = baseProps[propName]);
		  }
		  if ((Component = Component.defaultProps)) {
		    newProps === baseProps && (newProps = assign({}, newProps));
		    for (var propName$73 in Component)
		      void 0 === newProps[propName$73] &&
		        (newProps[propName$73] = Component[propName$73]);
		  }
		  return newProps;
		}
		var reportGlobalError =
		  "function" === typeof reportError
		    ? reportError
		    : function (error) {
		        if (
		          "object" === typeof window &&
		          "function" === typeof window.ErrorEvent
		        ) {
		          var event = new window.ErrorEvent("error", {
		            bubbles: true,
		            cancelable: true,
		            message:
		              "object" === typeof error &&
		              null !== error &&
		              "string" === typeof error.message
		                ? String(error.message)
		                : String(error),
		            error: error
		          });
		          if (!window.dispatchEvent(event)) return;
		        } else if (
		          "object" === typeof process &&
		          "function" === typeof process.emit
		        ) {
		          process.emit("uncaughtException", error);
		          return;
		        }
		        console.error(error);
		      };
		function defaultOnUncaughtError(error) {
		  reportGlobalError(error);
		}
		function defaultOnCaughtError(error) {
		  console.error(error);
		}
		function defaultOnRecoverableError(error) {
		  reportGlobalError(error);
		}
		function logUncaughtError(root, errorInfo) {
		  try {
		    var onUncaughtError = root.onUncaughtError;
		    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
		  } catch (e$74) {
		    setTimeout(function () {
		      throw e$74;
		    });
		  }
		}
		function logCaughtError(root, boundary, errorInfo) {
		  try {
		    var onCaughtError = root.onCaughtError;
		    onCaughtError(errorInfo.value, {
		      componentStack: errorInfo.stack,
		      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
		    });
		  } catch (e$75) {
		    setTimeout(function () {
		      throw e$75;
		    });
		  }
		}
		function createRootErrorUpdate(root, errorInfo, lane) {
		  lane = createUpdate(lane);
		  lane.tag = 3;
		  lane.payload = { element: null };
		  lane.callback = function () {
		    logUncaughtError(root, errorInfo);
		  };
		  return lane;
		}
		function createClassErrorUpdate(lane) {
		  lane = createUpdate(lane);
		  lane.tag = 3;
		  return lane;
		}
		function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
		  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		  if ("function" === typeof getDerivedStateFromError) {
		    var error = errorInfo.value;
		    update.payload = function () {
		      return getDerivedStateFromError(error);
		    };
		    update.callback = function () {
		      logCaughtError(root, fiber, errorInfo);
		    };
		  }
		  var inst = fiber.stateNode;
		  null !== inst &&
		    "function" === typeof inst.componentDidCatch &&
		    (update.callback = function () {
		      logCaughtError(root, fiber, errorInfo);
		      "function" !== typeof getDerivedStateFromError &&
		        (null === legacyErrorBoundariesThatAlreadyFailed
		          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
		          : legacyErrorBoundariesThatAlreadyFailed.add(this));
		      var stack = errorInfo.stack;
		      this.componentDidCatch(errorInfo.value, {
		        componentStack: null !== stack ? stack : ""
		      });
		    });
		}
		function throwException(
		  root,
		  returnFiber,
		  sourceFiber,
		  value,
		  rootRenderLanes
		) {
		  sourceFiber.flags |= 32768;
		  if (
		    null !== value &&
		    "object" === typeof value &&
		    "function" === typeof value.then
		  ) {
		    returnFiber = sourceFiber.alternate;
		    null !== returnFiber &&
		      propagateParentContextChanges(
		        returnFiber,
		        sourceFiber,
		        rootRenderLanes,
		        true
		      );
		    sourceFiber = suspenseHandlerStackCursor.current;
		    if (null !== sourceFiber) {
		      switch (sourceFiber.tag) {
		        case 13:
		          return (
		            null === shellBoundary
		              ? renderDidSuspendDelayIfPossible()
		              : null === sourceFiber.alternate &&
		                0 === workInProgressRootExitStatus &&
		                (workInProgressRootExitStatus = 3),
		            (sourceFiber.flags &= -257),
		            (sourceFiber.flags |= 65536),
		            (sourceFiber.lanes = rootRenderLanes),
		            value === noopSuspenseyCommitThenable
		              ? (sourceFiber.flags |= 16384)
		              : ((returnFiber = sourceFiber.updateQueue),
		                null === returnFiber
		                  ? (sourceFiber.updateQueue = new Set([value]))
		                  : returnFiber.add(value),
		                attachPingListener(root, value, rootRenderLanes)),
		            false
		          );
		        case 22:
		          return (
		            (sourceFiber.flags |= 65536),
		            value === noopSuspenseyCommitThenable
		              ? (sourceFiber.flags |= 16384)
		              : ((returnFiber = sourceFiber.updateQueue),
		                null === returnFiber
		                  ? ((returnFiber = {
		                      transitions: null,
		                      markerInstances: null,
		                      retryQueue: new Set([value])
		                    }),
		                    (sourceFiber.updateQueue = returnFiber))
		                  : ((sourceFiber = returnFiber.retryQueue),
		                    null === sourceFiber
		                      ? (returnFiber.retryQueue = new Set([value]))
		                      : sourceFiber.add(value)),
		                attachPingListener(root, value, rootRenderLanes)),
		            false
		          );
		      }
		      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
		    }
		    attachPingListener(root, value, rootRenderLanes);
		    renderDidSuspendDelayIfPossible();
		    return false;
		  }
		  if (isHydrating)
		    return (
		      (returnFiber = suspenseHandlerStackCursor.current),
		      null !== returnFiber
		        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
		          (returnFiber.flags |= 65536),
		          (returnFiber.lanes = rootRenderLanes),
		          value !== HydrationMismatchException &&
		            ((root = Error(formatProdErrorMessage(422), { cause: value })),
		            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
		        : (value !== HydrationMismatchException &&
		            ((returnFiber = Error(formatProdErrorMessage(423), {
		              cause: value
		            })),
		            queueHydrationError(
		              createCapturedValueAtFiber(returnFiber, sourceFiber)
		            )),
		          (root = root.current.alternate),
		          (root.flags |= 65536),
		          (rootRenderLanes &= -rootRenderLanes),
		          (root.lanes |= rootRenderLanes),
		          (value = createCapturedValueAtFiber(value, sourceFiber)),
		          (rootRenderLanes = createRootErrorUpdate(
		            root.stateNode,
		            value,
		            rootRenderLanes
		          )),
		          enqueueCapturedUpdate(root, rootRenderLanes),
		          4 !== workInProgressRootExitStatus &&
		            (workInProgressRootExitStatus = 2)),
		      false
		    );
		  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
		  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
		  null === workInProgressRootConcurrentErrors
		    ? (workInProgressRootConcurrentErrors = [wrapperError])
		    : workInProgressRootConcurrentErrors.push(wrapperError);
		  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
		  if (null === returnFiber) return true;
		  value = createCapturedValueAtFiber(value, sourceFiber);
		  sourceFiber = returnFiber;
		  do {
		    switch (sourceFiber.tag) {
		      case 3:
		        return (
		          (sourceFiber.flags |= 65536),
		          (root = rootRenderLanes & -rootRenderLanes),
		          (sourceFiber.lanes |= root),
		          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
		          enqueueCapturedUpdate(sourceFiber, root),
		          false
		        );
		      case 1:
		        if (
		          ((returnFiber = sourceFiber.type),
		          (wrapperError = sourceFiber.stateNode),
		          0 === (sourceFiber.flags & 128) &&
		            ("function" === typeof returnFiber.getDerivedStateFromError ||
		              (null !== wrapperError &&
		                "function" === typeof wrapperError.componentDidCatch &&
		                (null === legacyErrorBoundariesThatAlreadyFailed ||
		                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
		        )
		          return (
		            (sourceFiber.flags |= 65536),
		            (rootRenderLanes &= -rootRenderLanes),
		            (sourceFiber.lanes |= rootRenderLanes),
		            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
		            initializeClassErrorUpdate(
		              rootRenderLanes,
		              root,
		              sourceFiber,
		              value
		            ),
		            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
		            false
		          );
		    }
		    sourceFiber = sourceFiber.return;
		  } while (null !== sourceFiber);
		  return false;
		}
		var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
		  didReceiveUpdate = false;
		function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
		  workInProgress.child =
		    null === current
		      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
		      : reconcileChildFibers(
		          workInProgress,
		          current.child,
		          nextChildren,
		          renderLanes
		        );
		}
		function updateForwardRef(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  Component = Component.render;
		  var ref = workInProgress.ref;
		  if ("ref" in nextProps) {
		    var propsWithoutRef = {};
		    for (var key in nextProps)
		      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		  } else propsWithoutRef = nextProps;
		  prepareToReadContext(workInProgress);
		  nextProps = renderWithHooks(
		    current,
		    workInProgress,
		    Component,
		    propsWithoutRef,
		    ref,
		    renderLanes
		  );
		  key = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && key && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, nextProps, renderLanes);
		  return workInProgress.child;
		}
		function updateMemoComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  if (null === current) {
		    var type = Component.type;
		    if (
		      "function" === typeof type &&
		      !shouldConstruct(type) &&
		      void 0 === type.defaultProps &&
		      null === Component.compare
		    )
		      return (
		        (workInProgress.tag = 15),
		        (workInProgress.type = type),
		        updateSimpleMemoComponent(
		          current,
		          workInProgress,
		          type,
		          nextProps,
		          renderLanes
		        )
		      );
		    current = createFiberFromTypeAndProps(
		      Component.type,
		      null,
		      nextProps,
		      workInProgress,
		      workInProgress.mode,
		      renderLanes
		    );
		    current.ref = workInProgress.ref;
		    current.return = workInProgress;
		    return (workInProgress.child = current);
		  }
		  type = current.child;
		  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
		    var prevProps = type.memoizedProps;
		    Component = Component.compare;
		    Component = null !== Component ? Component : shallowEqual;
		    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
		      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		  }
		  workInProgress.flags |= 1;
		  current = createWorkInProgress(type, nextProps);
		  current.ref = workInProgress.ref;
		  current.return = workInProgress;
		  return (workInProgress.child = current);
		}
		function updateSimpleMemoComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  if (null !== current) {
		    var prevProps = current.memoizedProps;
		    if (
		      shallowEqual(prevProps, nextProps) &&
		      current.ref === workInProgress.ref
		    )
		      if (
		        ((didReceiveUpdate = false),
		        (workInProgress.pendingProps = nextProps = prevProps),
		        checkScheduledUpdateOrContext(current, renderLanes))
		      )
		        0 !== (current.flags & 131072) && (didReceiveUpdate = true);
		      else
		        return (
		          (workInProgress.lanes = current.lanes),
		          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		        );
		  }
		  return updateFunctionComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  );
		}
		function updateOffscreenComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    nextChildren = nextProps.children,
		    prevState = null !== current ? current.memoizedState : null;
		  if ("hidden" === nextProps.mode) {
		    if (0 !== (workInProgress.flags & 128)) {
		      nextProps =
		        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
		      if (null !== current) {
		        nextChildren = workInProgress.child = current.child;
		        for (prevState = 0; null !== nextChildren; )
		          (prevState =
		            prevState | nextChildren.lanes | nextChildren.childLanes),
		            (nextChildren = nextChildren.sibling);
		        workInProgress.childLanes = prevState & ~nextProps;
		      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
		      return deferHiddenOffscreenComponent(
		        current,
		        workInProgress,
		        nextProps,
		        renderLanes
		      );
		    }
		    if (0 !== (renderLanes & 536870912))
		      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
		        null !== current &&
		          pushTransition(
		            workInProgress,
		            null !== prevState ? prevState.cachePool : null
		          ),
		        null !== prevState
		          ? pushHiddenContext(workInProgress, prevState)
		          : reuseHiddenContextOnStack(),
		        pushOffscreenSuspenseHandler(workInProgress);
		    else
		      return (
		        (workInProgress.lanes = workInProgress.childLanes = 536870912),
		        deferHiddenOffscreenComponent(
		          current,
		          workInProgress,
		          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
		          renderLanes
		        )
		      );
		  } else
		    null !== prevState
		      ? (pushTransition(workInProgress, prevState.cachePool),
		        pushHiddenContext(workInProgress, prevState),
		        reuseSuspenseHandlerOnStack(),
		        (workInProgress.memoizedState = null))
		      : (null !== current && pushTransition(workInProgress, null),
		        reuseHiddenContextOnStack(),
		        reuseSuspenseHandlerOnStack());
		  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		  return workInProgress.child;
		}
		function deferHiddenOffscreenComponent(
		  current,
		  workInProgress,
		  nextBaseLanes,
		  renderLanes
		) {
		  var JSCompiler_inline_result = peekCacheFromPool();
		  JSCompiler_inline_result =
		    null === JSCompiler_inline_result
		      ? null
		      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
		  workInProgress.memoizedState = {
		    baseLanes: nextBaseLanes,
		    cachePool: JSCompiler_inline_result
		  };
		  null !== current && pushTransition(workInProgress, null);
		  reuseHiddenContextOnStack();
		  pushOffscreenSuspenseHandler(workInProgress);
		  null !== current &&
		    propagateParentContextChanges(current, workInProgress, renderLanes, true);
		  return null;
		}
		function markRef(current, workInProgress) {
		  var ref = workInProgress.ref;
		  if (null === ref)
		    null !== current &&
		      null !== current.ref &&
		      (workInProgress.flags |= 4194816);
		  else {
		    if ("function" !== typeof ref && "object" !== typeof ref)
		      throw Error(formatProdErrorMessage(284));
		    if (null === current || current.ref !== ref)
		      workInProgress.flags |= 4194816;
		  }
		}
		function updateFunctionComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  Component = renderWithHooks(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    void 0,
		    renderLanes
		  );
		  nextProps = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, Component, renderLanes);
		  return workInProgress.child;
		}
		function replayFunctionComponent(
		  current,
		  workInProgress,
		  nextProps,
		  Component,
		  secondArg,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  workInProgress.updateQueue = null;
		  nextProps = renderWithHooksAgain(
		    workInProgress,
		    Component,
		    nextProps,
		    secondArg
		  );
		  finishRenderingHooks(current);
		  Component = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && Component && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, nextProps, renderLanes);
		  return workInProgress.child;
		}
		function updateClassComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  if (null === workInProgress.stateNode) {
		    var context = emptyContextObject,
		      contextType = Component.contextType;
		    "object" === typeof contextType &&
		      null !== contextType &&
		      (context = readContext(contextType));
		    context = new Component(nextProps, context);
		    workInProgress.memoizedState =
		      null !== context.state && void 0 !== context.state ? context.state : null;
		    context.updater = classComponentUpdater;
		    workInProgress.stateNode = context;
		    context._reactInternals = workInProgress;
		    context = workInProgress.stateNode;
		    context.props = nextProps;
		    context.state = workInProgress.memoizedState;
		    context.refs = {};
		    initializeUpdateQueue(workInProgress);
		    contextType = Component.contextType;
		    context.context =
		      "object" === typeof contextType && null !== contextType
		        ? readContext(contextType)
		        : emptyContextObject;
		    context.state = workInProgress.memoizedState;
		    contextType = Component.getDerivedStateFromProps;
		    "function" === typeof contextType &&
		      (applyDerivedStateFromProps(
		        workInProgress,
		        Component,
		        contextType,
		        nextProps
		      ),
		      (context.state = workInProgress.memoizedState));
		    "function" === typeof Component.getDerivedStateFromProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate ||
		      ("function" !== typeof context.UNSAFE_componentWillMount &&
		        "function" !== typeof context.componentWillMount) ||
		      ((contextType = context.state),
		      "function" === typeof context.componentWillMount &&
		        context.componentWillMount(),
		      "function" === typeof context.UNSAFE_componentWillMount &&
		        context.UNSAFE_componentWillMount(),
		      contextType !== context.state &&
		        classComponentUpdater.enqueueReplaceState(context, context.state, null),
		      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
		      suspendIfUpdateReadFromEntangledAsyncAction(),
		      (context.state = workInProgress.memoizedState));
		    "function" === typeof context.componentDidMount &&
		      (workInProgress.flags |= 4194308);
		    nextProps = true;
		  } else if (null === current) {
		    context = workInProgress.stateNode;
		    var unresolvedOldProps = workInProgress.memoizedProps,
		      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
		    context.props = oldProps;
		    var oldContext = context.context,
		      contextType$jscomp$0 = Component.contextType;
		    contextType = emptyContextObject;
		    "object" === typeof contextType$jscomp$0 &&
		      null !== contextType$jscomp$0 &&
		      (contextType = readContext(contextType$jscomp$0));
		    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
		    contextType$jscomp$0 =
		      "function" === typeof getDerivedStateFromProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate;
		    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
		    contextType$jscomp$0 ||
		      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		        "function" !== typeof context.componentWillReceiveProps) ||
		      ((unresolvedOldProps || oldContext !== contextType) &&
		        callComponentWillReceiveProps(
		          workInProgress,
		          context,
		          nextProps,
		          contextType
		        ));
		    hasForceUpdate = false;
		    var oldState = workInProgress.memoizedState;
		    context.state = oldState;
		    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		    suspendIfUpdateReadFromEntangledAsyncAction();
		    oldContext = workInProgress.memoizedState;
		    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
		      ? ("function" === typeof getDerivedStateFromProps &&
		          (applyDerivedStateFromProps(
		            workInProgress,
		            Component,
		            getDerivedStateFromProps,
		            nextProps
		          ),
		          (oldContext = workInProgress.memoizedState)),
		        (oldProps =
		          hasForceUpdate ||
		          checkShouldComponentUpdate(
		            workInProgress,
		            Component,
		            oldProps,
		            nextProps,
		            oldState,
		            oldContext,
		            contextType
		          ))
		          ? (contextType$jscomp$0 ||
		              ("function" !== typeof context.UNSAFE_componentWillMount &&
		                "function" !== typeof context.componentWillMount) ||
		              ("function" === typeof context.componentWillMount &&
		                context.componentWillMount(),
		              "function" === typeof context.UNSAFE_componentWillMount &&
		                context.UNSAFE_componentWillMount()),
		            "function" === typeof context.componentDidMount &&
		              (workInProgress.flags |= 4194308))
		          : ("function" === typeof context.componentDidMount &&
		              (workInProgress.flags |= 4194308),
		            (workInProgress.memoizedProps = nextProps),
		            (workInProgress.memoizedState = oldContext)),
		        (context.props = nextProps),
		        (context.state = oldContext),
		        (context.context = contextType),
		        (nextProps = oldProps))
		      : ("function" === typeof context.componentDidMount &&
		          (workInProgress.flags |= 4194308),
		        (nextProps = false));
		  } else {
		    context = workInProgress.stateNode;
		    cloneUpdateQueue(current, workInProgress);
		    contextType = workInProgress.memoizedProps;
		    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
		    context.props = contextType$jscomp$0;
		    getDerivedStateFromProps = workInProgress.pendingProps;
		    oldState = context.context;
		    oldContext = Component.contextType;
		    oldProps = emptyContextObject;
		    "object" === typeof oldContext &&
		      null !== oldContext &&
		      (oldProps = readContext(oldContext));
		    unresolvedOldProps = Component.getDerivedStateFromProps;
		    (oldContext =
		      "function" === typeof unresolvedOldProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate) ||
		      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		        "function" !== typeof context.componentWillReceiveProps) ||
		      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
		        callComponentWillReceiveProps(
		          workInProgress,
		          context,
		          nextProps,
		          oldProps
		        ));
		    hasForceUpdate = false;
		    oldState = workInProgress.memoizedState;
		    context.state = oldState;
		    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		    suspendIfUpdateReadFromEntangledAsyncAction();
		    var newState = workInProgress.memoizedState;
		    contextType !== getDerivedStateFromProps ||
		    oldState !== newState ||
		    hasForceUpdate ||
		    (null !== current &&
		      null !== current.dependencies &&
		      checkIfContextChanged(current.dependencies))
		      ? ("function" === typeof unresolvedOldProps &&
		          (applyDerivedStateFromProps(
		            workInProgress,
		            Component,
		            unresolvedOldProps,
		            nextProps
		          ),
		          (newState = workInProgress.memoizedState)),
		        (contextType$jscomp$0 =
		          hasForceUpdate ||
		          checkShouldComponentUpdate(
		            workInProgress,
		            Component,
		            contextType$jscomp$0,
		            nextProps,
		            oldState,
		            newState,
		            oldProps
		          ) ||
		          (null !== current &&
		            null !== current.dependencies &&
		            checkIfContextChanged(current.dependencies)))
		          ? (oldContext ||
		              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
		                "function" !== typeof context.componentWillUpdate) ||
		              ("function" === typeof context.componentWillUpdate &&
		                context.componentWillUpdate(nextProps, newState, oldProps),
		              "function" === typeof context.UNSAFE_componentWillUpdate &&
		                context.UNSAFE_componentWillUpdate(
		                  nextProps,
		                  newState,
		                  oldProps
		                )),
		            "function" === typeof context.componentDidUpdate &&
		              (workInProgress.flags |= 4),
		            "function" === typeof context.getSnapshotBeforeUpdate &&
		              (workInProgress.flags |= 1024))
		          : ("function" !== typeof context.componentDidUpdate ||
		              (contextType === current.memoizedProps &&
		                oldState === current.memoizedState) ||
		              (workInProgress.flags |= 4),
		            "function" !== typeof context.getSnapshotBeforeUpdate ||
		              (contextType === current.memoizedProps &&
		                oldState === current.memoizedState) ||
		              (workInProgress.flags |= 1024),
		            (workInProgress.memoizedProps = nextProps),
		            (workInProgress.memoizedState = newState)),
		        (context.props = nextProps),
		        (context.state = newState),
		        (context.context = oldProps),
		        (nextProps = contextType$jscomp$0))
		      : ("function" !== typeof context.componentDidUpdate ||
		          (contextType === current.memoizedProps &&
		            oldState === current.memoizedState) ||
		          (workInProgress.flags |= 4),
		        "function" !== typeof context.getSnapshotBeforeUpdate ||
		          (contextType === current.memoizedProps &&
		            oldState === current.memoizedState) ||
		          (workInProgress.flags |= 1024),
		        (nextProps = false));
		  }
		  context = nextProps;
		  markRef(current, workInProgress);
		  nextProps = 0 !== (workInProgress.flags & 128);
		  context || nextProps
		    ? ((context = workInProgress.stateNode),
		      (Component =
		        nextProps && "function" !== typeof Component.getDerivedStateFromError
		          ? null
		          : context.render()),
		      (workInProgress.flags |= 1),
		      null !== current && nextProps
		        ? ((workInProgress.child = reconcileChildFibers(
		            workInProgress,
		            current.child,
		            null,
		            renderLanes
		          )),
		          (workInProgress.child = reconcileChildFibers(
		            workInProgress,
		            null,
		            Component,
		            renderLanes
		          )))
		        : reconcileChildren(current, workInProgress, Component, renderLanes),
		      (workInProgress.memoizedState = context.state),
		      (current = workInProgress.child))
		    : (current = bailoutOnAlreadyFinishedWork(
		        current,
		        workInProgress,
		        renderLanes
		      ));
		  return current;
		}
		function mountHostRootWithoutHydrating(
		  current,
		  workInProgress,
		  nextChildren,
		  renderLanes
		) {
		  resetHydrationState();
		  workInProgress.flags |= 256;
		  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		  return workInProgress.child;
		}
		var SUSPENDED_MARKER = {
		  dehydrated: null,
		  treeContext: null,
		  retryLane: 0,
		  hydrationErrors: null
		};
		function mountSuspenseOffscreenState(renderLanes) {
		  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
		}
		function getRemainingWorkInPrimaryTree(
		  current,
		  primaryTreeDidDefer,
		  renderLanes
		) {
		  current = null !== current ? current.childLanes & ~renderLanes : 0;
		  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		  return current;
		}
		function updateSuspenseComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    showFallback = false,
		    didSuspend = 0 !== (workInProgress.flags & 128),
		    JSCompiler_temp;
		  (JSCompiler_temp = didSuspend) ||
		    (JSCompiler_temp =
		      null !== current && null === current.memoizedState
		        ? false
		        : 0 !== (suspenseStackCursor.current & 2));
		  JSCompiler_temp && ((showFallback = true), (workInProgress.flags &= -129));
		  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
		  workInProgress.flags &= -33;
		  if (null === current) {
		    if (isHydrating) {
		      showFallback
		        ? pushPrimaryTreeSuspenseHandler(workInProgress)
		        : reuseSuspenseHandlerOnStack();
		      if (isHydrating) {
		        var nextInstance = nextHydratableInstance,
		          JSCompiler_temp$jscomp$0;
		        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
		          c: {
		            JSCompiler_temp$jscomp$0 = nextInstance;
		            for (
		              nextInstance = rootOrSingletonContext;
		              8 !== JSCompiler_temp$jscomp$0.nodeType;

		            ) {
		              if (!nextInstance) {
		                nextInstance = null;
		                break c;
		              }
		              JSCompiler_temp$jscomp$0 = getNextHydratable(
		                JSCompiler_temp$jscomp$0.nextSibling
		              );
		              if (null === JSCompiler_temp$jscomp$0) {
		                nextInstance = null;
		                break c;
		              }
		            }
		            nextInstance = JSCompiler_temp$jscomp$0;
		          }
		          null !== nextInstance
		            ? ((workInProgress.memoizedState = {
		                dehydrated: nextInstance,
		                treeContext:
		                  null !== treeContextProvider
		                    ? { id: treeContextId, overflow: treeContextOverflow }
		                    : null,
		                retryLane: 536870912,
		                hydrationErrors: null
		              }),
		              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
		                18,
		                null,
		                null,
		                0
		              )),
		              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
		              (JSCompiler_temp$jscomp$0.return = workInProgress),
		              (workInProgress.child = JSCompiler_temp$jscomp$0),
		              (hydrationParentFiber = workInProgress),
		              (nextHydratableInstance = null),
		              (JSCompiler_temp$jscomp$0 = true))
		            : (JSCompiler_temp$jscomp$0 = false);
		        }
		        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
		      }
		      nextInstance = workInProgress.memoizedState;
		      if (
		        null !== nextInstance &&
		        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
		      )
		        return (
		          isSuspenseInstanceFallback(nextInstance)
		            ? (workInProgress.lanes = 32)
		            : (workInProgress.lanes = 536870912),
		          null
		        );
		      popSuspenseHandler(workInProgress);
		    }
		    nextInstance = nextProps.children;
		    nextProps = nextProps.fallback;
		    if (showFallback)
		      return (
		        reuseSuspenseHandlerOnStack(),
		        (showFallback = workInProgress.mode),
		        (nextInstance = mountWorkInProgressOffscreenFiber(
		          { mode: "hidden", children: nextInstance },
		          showFallback
		        )),
		        (nextProps = createFiberFromFragment(
		          nextProps,
		          showFallback,
		          renderLanes,
		          null
		        )),
		        (nextInstance.return = workInProgress),
		        (nextProps.return = workInProgress),
		        (nextInstance.sibling = nextProps),
		        (workInProgress.child = nextInstance),
		        (showFallback = workInProgress.child),
		        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
		        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		          current,
		          JSCompiler_temp,
		          renderLanes
		        )),
		        (workInProgress.memoizedState = SUSPENDED_MARKER),
		        nextProps
		      );
		    pushPrimaryTreeSuspenseHandler(workInProgress);
		    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
		  }
		  JSCompiler_temp$jscomp$0 = current.memoizedState;
		  if (
		    null !== JSCompiler_temp$jscomp$0 &&
		    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
		    null !== nextInstance)
		  ) {
		    if (didSuspend)
		      workInProgress.flags & 256
		        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
		          (workInProgress.flags &= -257),
		          (workInProgress = retrySuspenseComponentWithoutHydrating(
		            current,
		            workInProgress,
		            renderLanes
		          )))
		        : null !== workInProgress.memoizedState
		          ? (reuseSuspenseHandlerOnStack(),
		            (workInProgress.child = current.child),
		            (workInProgress.flags |= 128),
		            (workInProgress = null))
		          : (reuseSuspenseHandlerOnStack(),
		            (showFallback = nextProps.fallback),
		            (nextInstance = workInProgress.mode),
		            (nextProps = mountWorkInProgressOffscreenFiber(
		              { mode: "visible", children: nextProps.children },
		              nextInstance
		            )),
		            (showFallback = createFiberFromFragment(
		              showFallback,
		              nextInstance,
		              renderLanes,
		              null
		            )),
		            (showFallback.flags |= 2),
		            (nextProps.return = workInProgress),
		            (showFallback.return = workInProgress),
		            (nextProps.sibling = showFallback),
		            (workInProgress.child = nextProps),
		            reconcileChildFibers(
		              workInProgress,
		              current.child,
		              null,
		              renderLanes
		            ),
		            (nextProps = workInProgress.child),
		            (nextProps.memoizedState =
		              mountSuspenseOffscreenState(renderLanes)),
		            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
		              current,
		              JSCompiler_temp,
		              renderLanes
		            )),
		            (workInProgress.memoizedState = SUSPENDED_MARKER),
		            (workInProgress = showFallback));
		    else if (
		      (pushPrimaryTreeSuspenseHandler(workInProgress),
		      isSuspenseInstanceFallback(nextInstance))
		    ) {
		      JSCompiler_temp =
		        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
		      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
		      JSCompiler_temp = digest;
		      nextProps = Error(formatProdErrorMessage(419));
		      nextProps.stack = "";
		      nextProps.digest = JSCompiler_temp;
		      queueHydrationError({ value: nextProps, source: null, stack: null });
		      workInProgress = retrySuspenseComponentWithoutHydrating(
		        current,
		        workInProgress,
		        renderLanes
		      );
		    } else if (
		      (didReceiveUpdate ||
		        propagateParentContextChanges(current, workInProgress, renderLanes, false),
		      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
		      didReceiveUpdate || JSCompiler_temp)
		    ) {
		      JSCompiler_temp = workInProgressRoot;
		      if (
		        null !== JSCompiler_temp &&
		        ((nextProps = renderLanes & -renderLanes),
		        (nextProps =
		          0 !== (nextProps & 42)
		            ? 1
		            : getBumpedLaneForHydrationByLane(nextProps)),
		        (nextProps =
		          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
		            ? 0
		            : nextProps),
		        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
		      )
		        throw (
		          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
		          enqueueConcurrentRenderForLane(current, nextProps),
		          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
		          SelectiveHydrationException)
		        );
		      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
		      workInProgress = retrySuspenseComponentWithoutHydrating(
		        current,
		        workInProgress,
		        renderLanes
		      );
		    } else
		      "$?" === nextInstance.data
		        ? ((workInProgress.flags |= 192),
		          (workInProgress.child = current.child),
		          (workInProgress = null))
		        : ((current = JSCompiler_temp$jscomp$0.treeContext),
		          (nextHydratableInstance = getNextHydratable(
		            nextInstance.nextSibling
		          )),
		          (hydrationParentFiber = workInProgress),
		          (isHydrating = true),
		          (hydrationErrors = null),
		          (rootOrSingletonContext = false),
		          null !== current &&
		            ((idStack[idStackIndex++] = treeContextId),
		            (idStack[idStackIndex++] = treeContextOverflow),
		            (idStack[idStackIndex++] = treeContextProvider),
		            (treeContextId = current.id),
		            (treeContextOverflow = current.overflow),
		            (treeContextProvider = workInProgress)),
		          (workInProgress = mountSuspensePrimaryChildren(
		            workInProgress,
		            nextProps.children
		          )),
		          (workInProgress.flags |= 4096));
		    return workInProgress;
		  }
		  if (showFallback)
		    return (
		      reuseSuspenseHandlerOnStack(),
		      (showFallback = nextProps.fallback),
		      (nextInstance = workInProgress.mode),
		      (JSCompiler_temp$jscomp$0 = current.child),
		      (digest = JSCompiler_temp$jscomp$0.sibling),
		      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
		        mode: "hidden",
		        children: nextProps.children
		      })),
		      (nextProps.subtreeFlags =
		        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),
		      null !== digest
		        ? (showFallback = createWorkInProgress(digest, showFallback))
		        : ((showFallback = createFiberFromFragment(
		            showFallback,
		            nextInstance,
		            renderLanes,
		            null
		          )),
		          (showFallback.flags |= 2)),
		      (showFallback.return = workInProgress),
		      (nextProps.return = workInProgress),
		      (nextProps.sibling = showFallback),
		      (workInProgress.child = nextProps),
		      (nextProps = showFallback),
		      (showFallback = workInProgress.child),
		      (nextInstance = current.child.memoizedState),
		      null === nextInstance
		        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
		        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
		          null !== JSCompiler_temp$jscomp$0
		            ? ((digest = CacheContext._currentValue),
		              (JSCompiler_temp$jscomp$0 =
		                JSCompiler_temp$jscomp$0.parent !== digest
		                  ? { parent: digest, pool: digest }
		                  : JSCompiler_temp$jscomp$0))
		            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
		          (nextInstance = {
		            baseLanes: nextInstance.baseLanes | renderLanes,
		            cachePool: JSCompiler_temp$jscomp$0
		          })),
		      (showFallback.memoizedState = nextInstance),
		      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		        current,
		        JSCompiler_temp,
		        renderLanes
		      )),
		      (workInProgress.memoizedState = SUSPENDED_MARKER),
		      nextProps
		    );
		  pushPrimaryTreeSuspenseHandler(workInProgress);
		  renderLanes = current.child;
		  current = renderLanes.sibling;
		  renderLanes = createWorkInProgress(renderLanes, {
		    mode: "visible",
		    children: nextProps.children
		  });
		  renderLanes.return = workInProgress;
		  renderLanes.sibling = null;
		  null !== current &&
		    ((JSCompiler_temp = workInProgress.deletions),
		    null === JSCompiler_temp
		      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
		      : JSCompiler_temp.push(current));
		  workInProgress.child = renderLanes;
		  workInProgress.memoizedState = null;
		  return renderLanes;
		}
		function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
		  primaryChildren = mountWorkInProgressOffscreenFiber(
		    { mode: "visible", children: primaryChildren },
		    workInProgress.mode
		  );
		  primaryChildren.return = workInProgress;
		  return (workInProgress.child = primaryChildren);
		}
		function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
		  offscreenProps.lanes = 0;
		  offscreenProps.stateNode = {
		    _visibility: 1,
		    _pendingMarkers: null,
		    _retryCache: null,
		    _transitions: null
		  };
		  return offscreenProps;
		}
		function retrySuspenseComponentWithoutHydrating(
		  current,
		  workInProgress,
		  renderLanes
		) {
		  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		  current = mountSuspensePrimaryChildren(
		    workInProgress,
		    workInProgress.pendingProps.children
		  );
		  current.flags |= 2;
		  workInProgress.memoizedState = null;
		  return current;
		}
		function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
		  fiber.lanes |= renderLanes;
		  var alternate = fiber.alternate;
		  null !== alternate && (alternate.lanes |= renderLanes);
		  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
		}
		function initSuspenseListRenderState(
		  workInProgress,
		  isBackwards,
		  tail,
		  lastContentRow,
		  tailMode
		) {
		  var renderState = workInProgress.memoizedState;
		  null === renderState
		    ? (workInProgress.memoizedState = {
		        isBackwards: isBackwards,
		        rendering: null,
		        renderingStartTime: 0,
		        last: lastContentRow,
		        tail: tail,
		        tailMode: tailMode
		      })
		    : ((renderState.isBackwards = isBackwards),
		      (renderState.rendering = null),
		      (renderState.renderingStartTime = 0),
		      (renderState.last = lastContentRow),
		      (renderState.tail = tail),
		      (renderState.tailMode = tailMode));
		}
		function updateSuspenseListComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    revealOrder = nextProps.revealOrder,
		    tailMode = nextProps.tail;
		  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
		  nextProps = suspenseStackCursor.current;
		  if (0 !== (nextProps & 2))
		    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
		  else {
		    if (null !== current && 0 !== (current.flags & 128))
		      a: for (current = workInProgress.child; null !== current; ) {
		        if (13 === current.tag)
		          null !== current.memoizedState &&
		            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		        else if (19 === current.tag)
		          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		        else if (null !== current.child) {
		          current.child.return = current;
		          current = current.child;
		          continue;
		        }
		        if (current === workInProgress) break a;
		        for (; null === current.sibling; ) {
		          if (null === current.return || current.return === workInProgress)
		            break a;
		          current = current.return;
		        }
		        current.sibling.return = current.return;
		        current = current.sibling;
		      }
		    nextProps &= 1;
		  }
		  push(suspenseStackCursor, nextProps);
		  switch (revealOrder) {
		    case "forwards":
		      renderLanes = workInProgress.child;
		      for (revealOrder = null; null !== renderLanes; )
		        (current = renderLanes.alternate),
		          null !== current &&
		            null === findFirstSuspended(current) &&
		            (revealOrder = renderLanes),
		          (renderLanes = renderLanes.sibling);
		      renderLanes = revealOrder;
		      null === renderLanes
		        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
		        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
		      initSuspenseListRenderState(
		        workInProgress,
		        false,
		        revealOrder,
		        renderLanes,
		        tailMode
		      );
		      break;
		    case "backwards":
		      renderLanes = null;
		      revealOrder = workInProgress.child;
		      for (workInProgress.child = null; null !== revealOrder; ) {
		        current = revealOrder.alternate;
		        if (null !== current && null === findFirstSuspended(current)) {
		          workInProgress.child = revealOrder;
		          break;
		        }
		        current = revealOrder.sibling;
		        revealOrder.sibling = renderLanes;
		        renderLanes = revealOrder;
		        revealOrder = current;
		      }
		      initSuspenseListRenderState(
		        workInProgress,
		        true,
		        renderLanes,
		        null,
		        tailMode
		      );
		      break;
		    case "together":
		      initSuspenseListRenderState(workInProgress, false, null, null, void 0);
		      break;
		    default:
		      workInProgress.memoizedState = null;
		  }
		  return workInProgress.child;
		}
		function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
		  null !== current && (workInProgress.dependencies = current.dependencies);
		  workInProgressRootSkippedLanes |= workInProgress.lanes;
		  if (0 === (renderLanes & workInProgress.childLanes))
		    if (null !== current) {
		      if (
		        (propagateParentContextChanges(
		          current,
		          workInProgress,
		          renderLanes,
		          false
		        ),
		        0 === (renderLanes & workInProgress.childLanes))
		      )
		        return null;
		    } else return null;
		  if (null !== current && workInProgress.child !== current.child)
		    throw Error(formatProdErrorMessage(153));
		  if (null !== workInProgress.child) {
		    current = workInProgress.child;
		    renderLanes = createWorkInProgress(current, current.pendingProps);
		    workInProgress.child = renderLanes;
		    for (renderLanes.return = workInProgress; null !== current.sibling; )
		      (current = current.sibling),
		        (renderLanes = renderLanes.sibling =
		          createWorkInProgress(current, current.pendingProps)),
		        (renderLanes.return = workInProgress);
		    renderLanes.sibling = null;
		  }
		  return workInProgress.child;
		}
		function checkScheduledUpdateOrContext(current, renderLanes) {
		  if (0 !== (current.lanes & renderLanes)) return true;
		  current = current.dependencies;
		  return null !== current && checkIfContextChanged(current) ? true : false;
		}
		function attemptEarlyBailoutIfNoScheduledUpdate(
		  current,
		  workInProgress,
		  renderLanes
		) {
		  switch (workInProgress.tag) {
		    case 3:
		      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
		      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		      resetHydrationState();
		      break;
		    case 27:
		    case 5:
		      pushHostContext(workInProgress);
		      break;
		    case 4:
		      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
		      break;
		    case 10:
		      pushProvider(
		        workInProgress,
		        workInProgress.type,
		        workInProgress.memoizedProps.value
		      );
		      break;
		    case 13:
		      var state = workInProgress.memoizedState;
		      if (null !== state) {
		        if (null !== state.dehydrated)
		          return (
		            pushPrimaryTreeSuspenseHandler(workInProgress),
		            (workInProgress.flags |= 128),
		            null
		          );
		        if (0 !== (renderLanes & workInProgress.child.childLanes))
		          return updateSuspenseComponent(current, workInProgress, renderLanes);
		        pushPrimaryTreeSuspenseHandler(workInProgress);
		        current = bailoutOnAlreadyFinishedWork(
		          current,
		          workInProgress,
		          renderLanes
		        );
		        return null !== current ? current.sibling : null;
		      }
		      pushPrimaryTreeSuspenseHandler(workInProgress);
		      break;
		    case 19:
		      var didSuspendBefore = 0 !== (current.flags & 128);
		      state = 0 !== (renderLanes & workInProgress.childLanes);
		      state ||
		        (propagateParentContextChanges(
		          current,
		          workInProgress,
		          renderLanes,
		          false
		        ),
		        (state = 0 !== (renderLanes & workInProgress.childLanes)));
		      if (didSuspendBefore) {
		        if (state)
		          return updateSuspenseListComponent(
		            current,
		            workInProgress,
		            renderLanes
		          );
		        workInProgress.flags |= 128;
		      }
		      didSuspendBefore = workInProgress.memoizedState;
		      null !== didSuspendBefore &&
		        ((didSuspendBefore.rendering = null),
		        (didSuspendBefore.tail = null),
		        (didSuspendBefore.lastEffect = null));
		      push(suspenseStackCursor, suspenseStackCursor.current);
		      if (state) break;
		      else return null;
		    case 22:
		    case 23:
		      return (
		        (workInProgress.lanes = 0),
		        updateOffscreenComponent(current, workInProgress, renderLanes)
		      );
		    case 24:
		      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		  }
		  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		}
		function beginWork(current, workInProgress, renderLanes) {
		  if (null !== current)
		    if (current.memoizedProps !== workInProgress.pendingProps)
		      didReceiveUpdate = true;
		    else {
		      if (
		        !checkScheduledUpdateOrContext(current, renderLanes) &&
		        0 === (workInProgress.flags & 128)
		      )
		        return (
		          (didReceiveUpdate = false),
		          attemptEarlyBailoutIfNoScheduledUpdate(
		            current,
		            workInProgress,
		            renderLanes
		          )
		        );
		      didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
		    }
		  else
		    (didReceiveUpdate = false),
		      isHydrating &&
		        0 !== (workInProgress.flags & 1048576) &&
		        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
		  workInProgress.lanes = 0;
		  switch (workInProgress.tag) {
		    case 16:
		      a: {
		        current = workInProgress.pendingProps;
		        var lazyComponent = workInProgress.elementType,
		          init = lazyComponent._init;
		        lazyComponent = init(lazyComponent._payload);
		        workInProgress.type = lazyComponent;
		        if ("function" === typeof lazyComponent)
		          shouldConstruct(lazyComponent)
		            ? ((current = resolveClassComponentProps(lazyComponent, current)),
		              (workInProgress.tag = 1),
		              (workInProgress = updateClassComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              )))
		            : ((workInProgress.tag = 0),
		              (workInProgress = updateFunctionComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              )));
		        else {
		          if (void 0 !== lazyComponent && null !== lazyComponent)
		            if (
		              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
		            ) {
		              workInProgress.tag = 11;
		              workInProgress = updateForwardRef(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              );
		              break a;
		            } else if (init === REACT_MEMO_TYPE) {
		              workInProgress.tag = 14;
		              workInProgress = updateMemoComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              );
		              break a;
		            }
		          workInProgress =
		            getComponentNameFromType(lazyComponent) || lazyComponent;
		          throw Error(formatProdErrorMessage(306, workInProgress, ""));
		        }
		      }
		      return workInProgress;
		    case 0:
		      return updateFunctionComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 1:
		      return (
		        (lazyComponent = workInProgress.type),
		        (init = resolveClassComponentProps(
		          lazyComponent,
		          workInProgress.pendingProps
		        )),
		        updateClassComponent(
		          current,
		          workInProgress,
		          lazyComponent,
		          init,
		          renderLanes
		        )
		      );
		    case 3:
		      a: {
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        );
		        if (null === current) throw Error(formatProdErrorMessage(387));
		        lazyComponent = workInProgress.pendingProps;
		        var prevState = workInProgress.memoizedState;
		        init = prevState.element;
		        cloneUpdateQueue(current, workInProgress);
		        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
		        var nextState = workInProgress.memoizedState;
		        lazyComponent = nextState.cache;
		        pushProvider(workInProgress, CacheContext, lazyComponent);
		        lazyComponent !== prevState.cache &&
		          propagateContextChanges(
		            workInProgress,
		            [CacheContext],
		            renderLanes,
		            true
		          );
		        suspendIfUpdateReadFromEntangledAsyncAction();
		        lazyComponent = nextState.element;
		        if (prevState.isDehydrated)
		          if (
		            ((prevState = {
		              element: lazyComponent,
		              isDehydrated: false,
		              cache: nextState.cache
		            }),
		            (workInProgress.updateQueue.baseState = prevState),
		            (workInProgress.memoizedState = prevState),
		            workInProgress.flags & 256)
		          ) {
		            workInProgress = mountHostRootWithoutHydrating(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            );
		            break a;
		          } else if (lazyComponent !== init) {
		            init = createCapturedValueAtFiber(
		              Error(formatProdErrorMessage(424)),
		              workInProgress
		            );
		            queueHydrationError(init);
		            workInProgress = mountHostRootWithoutHydrating(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            );
		            break a;
		          } else {
		            current = workInProgress.stateNode.containerInfo;
		            switch (current.nodeType) {
		              case 9:
		                current = current.body;
		                break;
		              default:
		                current =
		                  "HTML" === current.nodeName
		                    ? current.ownerDocument.body
		                    : current;
		            }
		            nextHydratableInstance = getNextHydratable(current.firstChild);
		            hydrationParentFiber = workInProgress;
		            isHydrating = true;
		            hydrationErrors = null;
		            rootOrSingletonContext = true;
		            renderLanes = mountChildFibers(
		              workInProgress,
		              null,
		              lazyComponent,
		              renderLanes
		            );
		            for (workInProgress.child = renderLanes; renderLanes; )
		              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
		                (renderLanes = renderLanes.sibling);
		          }
		        else {
		          resetHydrationState();
		          if (lazyComponent === init) {
		            workInProgress = bailoutOnAlreadyFinishedWork(
		              current,
		              workInProgress,
		              renderLanes
		            );
		            break a;
		          }
		          reconcileChildren(
		            current,
		            workInProgress,
		            lazyComponent,
		            renderLanes
		          );
		        }
		        workInProgress = workInProgress.child;
		      }
		      return workInProgress;
		    case 26:
		      return (
		        markRef(current, workInProgress),
		        null === current
		          ? (renderLanes = getResource(
		              workInProgress.type,
		              null,
		              workInProgress.pendingProps,
		              null
		            ))
		            ? (workInProgress.memoizedState = renderLanes)
		            : isHydrating ||
		              ((renderLanes = workInProgress.type),
		              (current = workInProgress.pendingProps),
		              (lazyComponent = getOwnerDocumentFromRootContainer(
		                rootInstanceStackCursor.current
		              ).createElement(renderLanes)),
		              (lazyComponent[internalInstanceKey] = workInProgress),
		              (lazyComponent[internalPropsKey] = current),
		              setInitialProperties(lazyComponent, renderLanes, current),
		              markNodeAsHoistable(lazyComponent),
		              (workInProgress.stateNode = lazyComponent))
		          : (workInProgress.memoizedState = getResource(
		              workInProgress.type,
		              current.memoizedProps,
		              workInProgress.pendingProps,
		              current.memoizedState
		            )),
		        null
		      );
		    case 27:
		      return (
		        pushHostContext(workInProgress),
		        null === current &&
		          isHydrating &&
		          ((lazyComponent = workInProgress.stateNode =
		            resolveSingletonInstance(
		              workInProgress.type,
		              workInProgress.pendingProps,
		              rootInstanceStackCursor.current
		            )),
		          (hydrationParentFiber = workInProgress),
		          (rootOrSingletonContext = true),
		          (init = nextHydratableInstance),
		          isSingletonScope(workInProgress.type)
		            ? ((previousHydratableOnEnteringScopedSingleton = init),
		              (nextHydratableInstance = getNextHydratable(
		                lazyComponent.firstChild
		              )))
		            : (nextHydratableInstance = init)),
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        markRef(current, workInProgress),
		        null === current && (workInProgress.flags |= 4194304),
		        workInProgress.child
		      );
		    case 5:
		      if (null === current && isHydrating) {
		        if ((init = lazyComponent = nextHydratableInstance))
		          (lazyComponent = canHydrateInstance(
		            lazyComponent,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            rootOrSingletonContext
		          )),
		            null !== lazyComponent
		              ? ((workInProgress.stateNode = lazyComponent),
		                (hydrationParentFiber = workInProgress),
		                (nextHydratableInstance = getNextHydratable(
		                  lazyComponent.firstChild
		                )),
		                (rootOrSingletonContext = false),
		                (init = true))
		              : (init = false);
		        init || throwOnHydrationMismatch(workInProgress);
		      }
		      pushHostContext(workInProgress);
		      init = workInProgress.type;
		      prevState = workInProgress.pendingProps;
		      nextState = null !== current ? current.memoizedProps : null;
		      lazyComponent = prevState.children;
		      shouldSetTextContent(init, prevState)
		        ? (lazyComponent = null)
		        : null !== nextState &&
		          shouldSetTextContent(init, nextState) &&
		          (workInProgress.flags |= 32);
		      null !== workInProgress.memoizedState &&
		        ((init = renderWithHooks(
		          current,
		          workInProgress,
		          TransitionAwareHostComponent,
		          null,
		          null,
		          renderLanes
		        )),
		        (HostTransitionContext._currentValue = init));
		      markRef(current, workInProgress);
		      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
		      return workInProgress.child;
		    case 6:
		      if (null === current && isHydrating) {
		        if ((current = renderLanes = nextHydratableInstance))
		          (renderLanes = canHydrateTextInstance(
		            renderLanes,
		            workInProgress.pendingProps,
		            rootOrSingletonContext
		          )),
		            null !== renderLanes
		              ? ((workInProgress.stateNode = renderLanes),
		                (hydrationParentFiber = workInProgress),
		                (nextHydratableInstance = null),
		                (current = true))
		              : (current = false);
		        current || throwOnHydrationMismatch(workInProgress);
		      }
		      return null;
		    case 13:
		      return updateSuspenseComponent(current, workInProgress, renderLanes);
		    case 4:
		      return (
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        ),
		        (lazyComponent = workInProgress.pendingProps),
		        null === current
		          ? (workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              null,
		              lazyComponent,
		              renderLanes
		            ))
		          : reconcileChildren(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            ),
		        workInProgress.child
		      );
		    case 11:
		      return updateForwardRef(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 7:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 8:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 12:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 10:
		      return (
		        (lazyComponent = workInProgress.pendingProps),
		        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
		        reconcileChildren(
		          current,
		          workInProgress,
		          lazyComponent.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 9:
		      return (
		        (init = workInProgress.type._context),
		        (lazyComponent = workInProgress.pendingProps.children),
		        prepareToReadContext(workInProgress),
		        (init = readContext(init)),
		        (lazyComponent = lazyComponent(init)),
		        (workInProgress.flags |= 1),
		        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
		        workInProgress.child
		      );
		    case 14:
		      return updateMemoComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 15:
		      return updateSimpleMemoComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 19:
		      return updateSuspenseListComponent(current, workInProgress, renderLanes);
		    case 31:
		      return (
		        (lazyComponent = workInProgress.pendingProps),
		        (renderLanes = workInProgress.mode),
		        (lazyComponent = {
		          mode: lazyComponent.mode,
		          children: lazyComponent.children
		        }),
		        null === current
		          ? ((renderLanes = mountWorkInProgressOffscreenFiber(
		              lazyComponent,
		              renderLanes
		            )),
		            (renderLanes.ref = workInProgress.ref),
		            (workInProgress.child = renderLanes),
		            (renderLanes.return = workInProgress),
		            (workInProgress = renderLanes))
		          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),
		            (renderLanes.ref = workInProgress.ref),
		            (workInProgress.child = renderLanes),
		            (renderLanes.return = workInProgress),
		            (workInProgress = renderLanes)),
		        workInProgress
		      );
		    case 22:
		      return updateOffscreenComponent(current, workInProgress, renderLanes);
		    case 24:
		      return (
		        prepareToReadContext(workInProgress),
		        (lazyComponent = readContext(CacheContext)),
		        null === current
		          ? ((init = peekCacheFromPool()),
		            null === init &&
		              ((init = workInProgressRoot),
		              (prevState = createCache()),
		              (init.pooledCache = prevState),
		              prevState.refCount++,
		              null !== prevState && (init.pooledCacheLanes |= renderLanes),
		              (init = prevState)),
		            (workInProgress.memoizedState = {
		              parent: lazyComponent,
		              cache: init
		            }),
		            initializeUpdateQueue(workInProgress),
		            pushProvider(workInProgress, CacheContext, init))
		          : (0 !== (current.lanes & renderLanes) &&
		              (cloneUpdateQueue(current, workInProgress),
		              processUpdateQueue(workInProgress, null, null, renderLanes),
		              suspendIfUpdateReadFromEntangledAsyncAction()),
		            (init = current.memoizedState),
		            (prevState = workInProgress.memoizedState),
		            init.parent !== lazyComponent
		              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
		                (workInProgress.memoizedState = init),
		                0 === workInProgress.lanes &&
		                  (workInProgress.memoizedState =
		                    workInProgress.updateQueue.baseState =
		                      init),
		                pushProvider(workInProgress, CacheContext, lazyComponent))
		              : ((lazyComponent = prevState.cache),
		                pushProvider(workInProgress, CacheContext, lazyComponent),
		                lazyComponent !== init.cache &&
		                  propagateContextChanges(
		                    workInProgress,
		                    [CacheContext],
		                    renderLanes,
		                    true
		                  ))),
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 29:
		      throw workInProgress.pendingProps;
		  }
		  throw Error(formatProdErrorMessage(156, workInProgress.tag));
		}
		function markUpdate(workInProgress) {
		  workInProgress.flags |= 4;
		}
		function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
		  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
		    workInProgress.flags &= -16777217;
		  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
		    resource = suspenseHandlerStackCursor.current;
		    if (
		      null !== resource &&
		      ((workInProgressRootRenderLanes & 4194048) ===
		      workInProgressRootRenderLanes
		        ? null !== shellBoundary
		        : ((workInProgressRootRenderLanes & 62914560) !==
		            workInProgressRootRenderLanes &&
		            0 === (workInProgressRootRenderLanes & 536870912)) ||
		          resource !== shellBoundary)
		    )
		      throw (
		        ((suspendedThenable = noopSuspenseyCommitThenable),
		        SuspenseyCommitException)
		      );
		    workInProgress.flags |= 8192;
		  }
		}
		function scheduleRetryEffect(workInProgress, retryQueue) {
		  null !== retryQueue && (workInProgress.flags |= 4);
		  workInProgress.flags & 16384 &&
		    ((retryQueue =
		      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
		    (workInProgress.lanes |= retryQueue),
		    (workInProgressSuspendedRetryLanes |= retryQueue));
		}
		function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		  if (!isHydrating)
		    switch (renderState.tailMode) {
		      case "hidden":
		        hasRenderedATailFallback = renderState.tail;
		        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
		          null !== hasRenderedATailFallback.alternate &&
		            (lastTailNode = hasRenderedATailFallback),
		            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
		        null === lastTailNode
		          ? (renderState.tail = null)
		          : (lastTailNode.sibling = null);
		        break;
		      case "collapsed":
		        lastTailNode = renderState.tail;
		        for (var lastTailNode$113 = null; null !== lastTailNode; )
		          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),
		            (lastTailNode = lastTailNode.sibling);
		        null === lastTailNode$113
		          ? hasRenderedATailFallback || null === renderState.tail
		            ? (renderState.tail = null)
		            : (renderState.tail.sibling = null)
		          : (lastTailNode$113.sibling = null);
		    }
		}
		function bubbleProperties(completedWork) {
		  var didBailout =
		      null !== completedWork.alternate &&
		      completedWork.alternate.child === completedWork.child,
		    newChildLanes = 0,
		    subtreeFlags = 0;
		  if (didBailout)
		    for (var child$114 = completedWork.child; null !== child$114; )
		      (newChildLanes |= child$114.lanes | child$114.childLanes),
		        (subtreeFlags |= child$114.subtreeFlags & 65011712),
		        (subtreeFlags |= child$114.flags & 65011712),
		        (child$114.return = completedWork),
		        (child$114 = child$114.sibling);
		  else
		    for (child$114 = completedWork.child; null !== child$114; )
		      (newChildLanes |= child$114.lanes | child$114.childLanes),
		        (subtreeFlags |= child$114.subtreeFlags),
		        (subtreeFlags |= child$114.flags),
		        (child$114.return = completedWork),
		        (child$114 = child$114.sibling);
		  completedWork.subtreeFlags |= subtreeFlags;
		  completedWork.childLanes = newChildLanes;
		  return didBailout;
		}
		function completeWork(current, workInProgress, renderLanes) {
		  var newProps = workInProgress.pendingProps;
		  popTreeContext(workInProgress);
		  switch (workInProgress.tag) {
		    case 31:
		    case 16:
		    case 15:
		    case 0:
		    case 11:
		    case 7:
		    case 8:
		    case 12:
		    case 9:
		    case 14:
		      return bubbleProperties(workInProgress), null;
		    case 1:
		      return bubbleProperties(workInProgress), null;
		    case 3:
		      renderLanes = workInProgress.stateNode;
		      newProps = null;
		      null !== current && (newProps = current.memoizedState.cache);
		      workInProgress.memoizedState.cache !== newProps &&
		        (workInProgress.flags |= 2048);
		      popProvider(CacheContext);
		      popHostContainer();
		      renderLanes.pendingContext &&
		        ((renderLanes.context = renderLanes.pendingContext),
		        (renderLanes.pendingContext = null));
		      if (null === current || null === current.child)
		        popHydrationState(workInProgress)
		          ? markUpdate(workInProgress)
		          : null === current ||
		            (current.memoizedState.isDehydrated &&
		              0 === (workInProgress.flags & 256)) ||
		            ((workInProgress.flags |= 1024),
		            upgradeHydrationErrorsToRecoverable());
		      bubbleProperties(workInProgress);
		      return null;
		    case 26:
		      return (
		        (renderLanes = workInProgress.memoizedState),
		        null === current
		          ? (markUpdate(workInProgress),
		            null !== renderLanes
		              ? (bubbleProperties(workInProgress),
		                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
		              : (bubbleProperties(workInProgress),
		                (workInProgress.flags &= -16777217)))
		          : renderLanes
		            ? renderLanes !== current.memoizedState
		              ? (markUpdate(workInProgress),
		                bubbleProperties(workInProgress),
		                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
		              : (bubbleProperties(workInProgress),
		                (workInProgress.flags &= -16777217))
		            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
		              bubbleProperties(workInProgress),
		              (workInProgress.flags &= -16777217)),
		        null
		      );
		    case 27:
		      popHostContext(workInProgress);
		      renderLanes = rootInstanceStackCursor.current;
		      var type = workInProgress.type;
		      if (null !== current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if (!newProps) {
		          if (null === workInProgress.stateNode)
		            throw Error(formatProdErrorMessage(166));
		          bubbleProperties(workInProgress);
		          return null;
		        }
		        current = contextStackCursor.current;
		        popHydrationState(workInProgress)
		          ? prepareToHydrateHostInstance(workInProgress)
		          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
		            (workInProgress.stateNode = current),
		            markUpdate(workInProgress));
		      }
		      bubbleProperties(workInProgress);
		      return null;
		    case 5:
		      popHostContext(workInProgress);
		      renderLanes = workInProgress.type;
		      if (null !== current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if (!newProps) {
		          if (null === workInProgress.stateNode)
		            throw Error(formatProdErrorMessage(166));
		          bubbleProperties(workInProgress);
		          return null;
		        }
		        current = contextStackCursor.current;
		        if (popHydrationState(workInProgress))
		          prepareToHydrateHostInstance(workInProgress);
		        else {
		          type = getOwnerDocumentFromRootContainer(
		            rootInstanceStackCursor.current
		          );
		          switch (current) {
		            case 1:
		              current = type.createElementNS(
		                "http://www.w3.org/2000/svg",
		                renderLanes
		              );
		              break;
		            case 2:
		              current = type.createElementNS(
		                "http://www.w3.org/1998/Math/MathML",
		                renderLanes
		              );
		              break;
		            default:
		              switch (renderLanes) {
		                case "svg":
		                  current = type.createElementNS(
		                    "http://www.w3.org/2000/svg",
		                    renderLanes
		                  );
		                  break;
		                case "math":
		                  current = type.createElementNS(
		                    "http://www.w3.org/1998/Math/MathML",
		                    renderLanes
		                  );
		                  break;
		                case "script":
		                  current = type.createElement("div");
		                  current.innerHTML = "<script>\x3c/script>";
		                  current = current.removeChild(current.firstChild);
		                  break;
		                case "select":
		                  current =
		                    "string" === typeof newProps.is
		                      ? type.createElement("select", { is: newProps.is })
		                      : type.createElement("select");
		                  newProps.multiple
		                    ? (current.multiple = true)
		                    : newProps.size && (current.size = newProps.size);
		                  break;
		                default:
		                  current =
		                    "string" === typeof newProps.is
		                      ? type.createElement(renderLanes, { is: newProps.is })
		                      : type.createElement(renderLanes);
		              }
		          }
		          current[internalInstanceKey] = workInProgress;
		          current[internalPropsKey] = newProps;
		          a: for (type = workInProgress.child; null !== type; ) {
		            if (5 === type.tag || 6 === type.tag)
		              current.appendChild(type.stateNode);
		            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
		              type.child.return = type;
		              type = type.child;
		              continue;
		            }
		            if (type === workInProgress) break a;
		            for (; null === type.sibling; ) {
		              if (null === type.return || type.return === workInProgress)
		                break a;
		              type = type.return;
		            }
		            type.sibling.return = type.return;
		            type = type.sibling;
		          }
		          workInProgress.stateNode = current;
		          a: switch (
		            (setInitialProperties(current, renderLanes, newProps), renderLanes)
		          ) {
		            case "button":
		            case "input":
		            case "select":
		            case "textarea":
		              current = !!newProps.autoFocus;
		              break a;
		            case "img":
		              current = true;
		              break a;
		            default:
		              current = false;
		          }
		          current && markUpdate(workInProgress);
		        }
		      }
		      bubbleProperties(workInProgress);
		      workInProgress.flags &= -16777217;
		      return null;
		    case 6:
		      if (current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if ("string" !== typeof newProps && null === workInProgress.stateNode)
		          throw Error(formatProdErrorMessage(166));
		        current = rootInstanceStackCursor.current;
		        if (popHydrationState(workInProgress)) {
		          current = workInProgress.stateNode;
		          renderLanes = workInProgress.memoizedProps;
		          newProps = null;
		          type = hydrationParentFiber;
		          if (null !== type)
		            switch (type.tag) {
		              case 27:
		              case 5:
		                newProps = type.memoizedProps;
		            }
		          current[internalInstanceKey] = workInProgress;
		          current =
		            current.nodeValue === renderLanes ||
		            (null !== newProps && true === newProps.suppressHydrationWarning) ||
		            checkForUnmatchedText(current.nodeValue, renderLanes)
		              ? true
		              : false;
		          current || throwOnHydrationMismatch(workInProgress);
		        } else
		          (current =
		            getOwnerDocumentFromRootContainer(current).createTextNode(
		              newProps
		            )),
		            (current[internalInstanceKey] = workInProgress),
		            (workInProgress.stateNode = current);
		      }
		      bubbleProperties(workInProgress);
		      return null;
		    case 13:
		      newProps = workInProgress.memoizedState;
		      if (
		        null === current ||
		        (null !== current.memoizedState &&
		          null !== current.memoizedState.dehydrated)
		      ) {
		        type = popHydrationState(workInProgress);
		        if (null !== newProps && null !== newProps.dehydrated) {
		          if (null === current) {
		            if (!type) throw Error(formatProdErrorMessage(318));
		            type = workInProgress.memoizedState;
		            type = null !== type ? type.dehydrated : null;
		            if (!type) throw Error(formatProdErrorMessage(317));
		            type[internalInstanceKey] = workInProgress;
		          } else
		            resetHydrationState(),
		              0 === (workInProgress.flags & 128) &&
		                (workInProgress.memoizedState = null),
		              (workInProgress.flags |= 4);
		          bubbleProperties(workInProgress);
		          type = false;
		        } else
		          (type = upgradeHydrationErrorsToRecoverable()),
		            null !== current &&
		              null !== current.memoizedState &&
		              (current.memoizedState.hydrationErrors = type),
		            (type = true);
		        if (!type) {
		          if (workInProgress.flags & 256)
		            return popSuspenseHandler(workInProgress), workInProgress;
		          popSuspenseHandler(workInProgress);
		          return null;
		        }
		      }
		      popSuspenseHandler(workInProgress);
		      if (0 !== (workInProgress.flags & 128))
		        return (workInProgress.lanes = renderLanes), workInProgress;
		      renderLanes = null !== newProps;
		      current = null !== current && null !== current.memoizedState;
		      if (renderLanes) {
		        newProps = workInProgress.child;
		        type = null;
		        null !== newProps.alternate &&
		          null !== newProps.alternate.memoizedState &&
		          null !== newProps.alternate.memoizedState.cachePool &&
		          (type = newProps.alternate.memoizedState.cachePool.pool);
		        var cache$127 = null;
		        null !== newProps.memoizedState &&
		          null !== newProps.memoizedState.cachePool &&
		          (cache$127 = newProps.memoizedState.cachePool.pool);
		        cache$127 !== type && (newProps.flags |= 2048);
		      }
		      renderLanes !== current &&
		        renderLanes &&
		        (workInProgress.child.flags |= 8192);
		      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
		      bubbleProperties(workInProgress);
		      return null;
		    case 4:
		      return (
		        popHostContainer(),
		        null === current &&
		          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
		        bubbleProperties(workInProgress),
		        null
		      );
		    case 10:
		      return (
		        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
		      );
		    case 19:
		      pop(suspenseStackCursor);
		      type = workInProgress.memoizedState;
		      if (null === type) return bubbleProperties(workInProgress), null;
		      newProps = 0 !== (workInProgress.flags & 128);
		      cache$127 = type.rendering;
		      if (null === cache$127)
		        if (newProps) cutOffTailIfNeeded(type, false);
		        else {
		          if (
		            0 !== workInProgressRootExitStatus ||
		            (null !== current && 0 !== (current.flags & 128))
		          )
		            for (current = workInProgress.child; null !== current; ) {
		              cache$127 = findFirstSuspended(current);
		              if (null !== cache$127) {
		                workInProgress.flags |= 128;
		                cutOffTailIfNeeded(type, false);
		                current = cache$127.updateQueue;
		                workInProgress.updateQueue = current;
		                scheduleRetryEffect(workInProgress, current);
		                workInProgress.subtreeFlags = 0;
		                current = renderLanes;
		                for (renderLanes = workInProgress.child; null !== renderLanes; )
		                  resetWorkInProgress(renderLanes, current),
		                    (renderLanes = renderLanes.sibling);
		                push(
		                  suspenseStackCursor,
		                  (suspenseStackCursor.current & 1) | 2
		                );
		                return workInProgress.child;
		              }
		              current = current.sibling;
		            }
		          null !== type.tail &&
		            now() > workInProgressRootRenderTargetTime &&
		            ((workInProgress.flags |= 128),
		            (newProps = true),
		            cutOffTailIfNeeded(type, false),
		            (workInProgress.lanes = 4194304));
		        }
		      else {
		        if (!newProps)
		          if (((current = findFirstSuspended(cache$127)), null !== current)) {
		            if (
		              ((workInProgress.flags |= 128),
		              (newProps = true),
		              (current = current.updateQueue),
		              (workInProgress.updateQueue = current),
		              scheduleRetryEffect(workInProgress, current),
		              cutOffTailIfNeeded(type, true),
		              null === type.tail &&
		                "hidden" === type.tailMode &&
		                !cache$127.alternate &&
		                !isHydrating)
		            )
		              return bubbleProperties(workInProgress), null;
		          } else
		            2 * now() - type.renderingStartTime >
		              workInProgressRootRenderTargetTime &&
		              536870912 !== renderLanes &&
		              ((workInProgress.flags |= 128),
		              (newProps = true),
		              cutOffTailIfNeeded(type, false),
		              (workInProgress.lanes = 4194304));
		        type.isBackwards
		          ? ((cache$127.sibling = workInProgress.child),
		            (workInProgress.child = cache$127))
		          : ((current = type.last),
		            null !== current
		              ? (current.sibling = cache$127)
		              : (workInProgress.child = cache$127),
		            (type.last = cache$127));
		      }
		      if (null !== type.tail)
		        return (
		          (workInProgress = type.tail),
		          (type.rendering = workInProgress),
		          (type.tail = workInProgress.sibling),
		          (type.renderingStartTime = now()),
		          (workInProgress.sibling = null),
		          (current = suspenseStackCursor.current),
		          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
		          workInProgress
		        );
		      bubbleProperties(workInProgress);
		      return null;
		    case 22:
		    case 23:
		      return (
		        popSuspenseHandler(workInProgress),
		        popHiddenContext(),
		        (newProps = null !== workInProgress.memoizedState),
		        null !== current
		          ? (null !== current.memoizedState) !== newProps &&
		            (workInProgress.flags |= 8192)
		          : newProps && (workInProgress.flags |= 8192),
		        newProps
		          ? 0 !== (renderLanes & 536870912) &&
		            0 === (workInProgress.flags & 128) &&
		            (bubbleProperties(workInProgress),
		            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
		          : bubbleProperties(workInProgress),
		        (renderLanes = workInProgress.updateQueue),
		        null !== renderLanes &&
		          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
		        (renderLanes = null),
		        null !== current &&
		          null !== current.memoizedState &&
		          null !== current.memoizedState.cachePool &&
		          (renderLanes = current.memoizedState.cachePool.pool),
		        (newProps = null),
		        null !== workInProgress.memoizedState &&
		          null !== workInProgress.memoizedState.cachePool &&
		          (newProps = workInProgress.memoizedState.cachePool.pool),
		        newProps !== renderLanes && (workInProgress.flags |= 2048),
		        null !== current && pop(resumedCache),
		        null
		      );
		    case 24:
		      return (
		        (renderLanes = null),
		        null !== current && (renderLanes = current.memoizedState.cache),
		        workInProgress.memoizedState.cache !== renderLanes &&
		          (workInProgress.flags |= 2048),
		        popProvider(CacheContext),
		        bubbleProperties(workInProgress),
		        null
		      );
		    case 25:
		      return null;
		    case 30:
		      return null;
		  }
		  throw Error(formatProdErrorMessage(156, workInProgress.tag));
		}
		function unwindWork(current, workInProgress) {
		  popTreeContext(workInProgress);
		  switch (workInProgress.tag) {
		    case 1:
		      return (
		        (current = workInProgress.flags),
		        current & 65536
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 3:
		      return (
		        popProvider(CacheContext),
		        popHostContainer(),
		        (current = workInProgress.flags),
		        0 !== (current & 65536) && 0 === (current & 128)
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 26:
		    case 27:
		    case 5:
		      return popHostContext(workInProgress), null;
		    case 13:
		      popSuspenseHandler(workInProgress);
		      current = workInProgress.memoizedState;
		      if (null !== current && null !== current.dehydrated) {
		        if (null === workInProgress.alternate)
		          throw Error(formatProdErrorMessage(340));
		        resetHydrationState();
		      }
		      current = workInProgress.flags;
		      return current & 65536
		        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		        : null;
		    case 19:
		      return pop(suspenseStackCursor), null;
		    case 4:
		      return popHostContainer(), null;
		    case 10:
		      return popProvider(workInProgress.type), null;
		    case 22:
		    case 23:
		      return (
		        popSuspenseHandler(workInProgress),
		        popHiddenContext(),
		        null !== current && pop(resumedCache),
		        (current = workInProgress.flags),
		        current & 65536
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 24:
		      return popProvider(CacheContext), null;
		    case 25:
		      return null;
		    default:
		      return null;
		  }
		}
		function unwindInterruptedWork(current, interruptedWork) {
		  popTreeContext(interruptedWork);
		  switch (interruptedWork.tag) {
		    case 3:
		      popProvider(CacheContext);
		      popHostContainer();
		      break;
		    case 26:
		    case 27:
		    case 5:
		      popHostContext(interruptedWork);
		      break;
		    case 4:
		      popHostContainer();
		      break;
		    case 13:
		      popSuspenseHandler(interruptedWork);
		      break;
		    case 19:
		      pop(suspenseStackCursor);
		      break;
		    case 10:
		      popProvider(interruptedWork.type);
		      break;
		    case 22:
		    case 23:
		      popSuspenseHandler(interruptedWork);
		      popHiddenContext();
		      null !== current && pop(resumedCache);
		      break;
		    case 24:
		      popProvider(CacheContext);
		  }
		}
		function commitHookEffectListMount(flags, finishedWork) {
		  try {
		    var updateQueue = finishedWork.updateQueue,
		      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		    if (null !== lastEffect) {
		      var firstEffect = lastEffect.next;
		      updateQueue = firstEffect;
		      do {
		        if ((updateQueue.tag & flags) === flags) {
		          lastEffect = void 0;
		          var create = updateQueue.create,
		            inst = updateQueue.inst;
		          lastEffect = create();
		          inst.destroy = lastEffect;
		        }
		        updateQueue = updateQueue.next;
		      } while (updateQueue !== firstEffect);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitHookEffectListUnmount(
		  flags,
		  finishedWork,
		  nearestMountedAncestor$jscomp$0
		) {
		  try {
		    var updateQueue = finishedWork.updateQueue,
		      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		    if (null !== lastEffect) {
		      var firstEffect = lastEffect.next;
		      updateQueue = firstEffect;
		      do {
		        if ((updateQueue.tag & flags) === flags) {
		          var inst = updateQueue.inst,
		            destroy = inst.destroy;
		          if (void 0 !== destroy) {
		            inst.destroy = void 0;
		            lastEffect = finishedWork;
		            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
		              destroy_ = destroy;
		            try {
		              destroy_();
		            } catch (error) {
		              captureCommitPhaseError(
		                lastEffect,
		                nearestMountedAncestor,
		                error
		              );
		            }
		          }
		        }
		        updateQueue = updateQueue.next;
		      } while (updateQueue !== firstEffect);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitClassCallbacks(finishedWork) {
		  var updateQueue = finishedWork.updateQueue;
		  if (null !== updateQueue) {
		    var instance = finishedWork.stateNode;
		    try {
		      commitCallbacks(updateQueue, instance);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		}
		function safelyCallComponentWillUnmount(
		  current,
		  nearestMountedAncestor,
		  instance
		) {
		  instance.props = resolveClassComponentProps(
		    current.type,
		    current.memoizedProps
		  );
		  instance.state = current.memoizedState;
		  try {
		    instance.componentWillUnmount();
		  } catch (error) {
		    captureCommitPhaseError(current, nearestMountedAncestor, error);
		  }
		}
		function safelyAttachRef(current, nearestMountedAncestor) {
		  try {
		    var ref = current.ref;
		    if (null !== ref) {
		      switch (current.tag) {
		        case 26:
		        case 27:
		        case 5:
		          var instanceToUse = current.stateNode;
		          break;
		        case 30:
		          instanceToUse = current.stateNode;
		          break;
		        default:
		          instanceToUse = current.stateNode;
		      }
		      "function" === typeof ref
		        ? (current.refCleanup = ref(instanceToUse))
		        : (ref.current = instanceToUse);
		    }
		  } catch (error) {
		    captureCommitPhaseError(current, nearestMountedAncestor, error);
		  }
		}
		function safelyDetachRef(current, nearestMountedAncestor) {
		  var ref = current.ref,
		    refCleanup = current.refCleanup;
		  if (null !== ref)
		    if ("function" === typeof refCleanup)
		      try {
		        refCleanup();
		      } catch (error) {
		        captureCommitPhaseError(current, nearestMountedAncestor, error);
		      } finally {
		        (current.refCleanup = null),
		          (current = current.alternate),
		          null != current && (current.refCleanup = null);
		      }
		    else if ("function" === typeof ref)
		      try {
		        ref(null);
		      } catch (error$143) {
		        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
		      }
		    else ref.current = null;
		}
		function commitHostMount(finishedWork) {
		  var type = finishedWork.type,
		    props = finishedWork.memoizedProps,
		    instance = finishedWork.stateNode;
		  try {
		    a: switch (type) {
		      case "button":
		      case "input":
		      case "select":
		      case "textarea":
		        props.autoFocus && instance.focus();
		        break a;
		      case "img":
		        props.src
		          ? (instance.src = props.src)
		          : props.srcSet && (instance.srcset = props.srcSet);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitHostUpdate(finishedWork, newProps, oldProps) {
		  try {
		    var domElement = finishedWork.stateNode;
		    updateProperties(domElement, finishedWork.type, oldProps, newProps);
		    domElement[internalPropsKey] = newProps;
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function isHostParent(fiber) {
		  return (
		    5 === fiber.tag ||
		    3 === fiber.tag ||
		    26 === fiber.tag ||
		    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
		    4 === fiber.tag
		  );
		}
		function getHostSibling(fiber) {
		  a: for (;;) {
		    for (; null === fiber.sibling; ) {
		      if (null === fiber.return || isHostParent(fiber.return)) return null;
		      fiber = fiber.return;
		    }
		    fiber.sibling.return = fiber.return;
		    for (
		      fiber = fiber.sibling;
		      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

		    ) {
		      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
		      if (fiber.flags & 2) continue a;
		      if (null === fiber.child || 4 === fiber.tag) continue a;
		      else (fiber.child.return = fiber), (fiber = fiber.child);
		    }
		    if (!(fiber.flags & 2)) return fiber.stateNode;
		  }
		}
		function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		  var tag = node.tag;
		  if (5 === tag || 6 === tag)
		    (node = node.stateNode),
		      before
		        ? (9 === parent.nodeType
		            ? parent.body
		            : "HTML" === parent.nodeName
		              ? parent.ownerDocument.body
		              : parent
		          ).insertBefore(node, before)
		        : ((before =
		            9 === parent.nodeType
		              ? parent.body
		              : "HTML" === parent.nodeName
		                ? parent.ownerDocument.body
		                : parent),
		          before.appendChild(node),
		          (parent = parent._reactRootContainer),
		          (null !== parent && void 0 !== parent) ||
		            null !== before.onclick ||
		            (before.onclick = noop$1));
		  else if (
		    4 !== tag &&
		    (27 === tag &&
		      isSingletonScope(node.type) &&
		      ((parent = node.stateNode), (before = null)),
		    (node = node.child),
		    null !== node)
		  )
		    for (
		      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		        node = node.sibling;
		      null !== node;

		    )
		      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		        (node = node.sibling);
		}
		function insertOrAppendPlacementNode(node, before, parent) {
		  var tag = node.tag;
		  if (5 === tag || 6 === tag)
		    (node = node.stateNode),
		      before ? parent.insertBefore(node, before) : parent.appendChild(node);
		  else if (
		    4 !== tag &&
		    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
		    (node = node.child),
		    null !== node)
		  )
		    for (
		      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
		      null !== node;

		    )
		      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
		}
		function commitHostSingletonAcquisition(finishedWork) {
		  var singleton = finishedWork.stateNode,
		    props = finishedWork.memoizedProps;
		  try {
		    for (
		      var type = finishedWork.type, attributes = singleton.attributes;
		      attributes.length;

		    )
		      singleton.removeAttributeNode(attributes[0]);
		    setInitialProperties(singleton, type, props);
		    singleton[internalInstanceKey] = finishedWork;
		    singleton[internalPropsKey] = props;
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		var offscreenSubtreeIsHidden = false,
		  offscreenSubtreeWasHidden = false,
		  needsFormReset = false,
		  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
		  nextEffect = null;
		function commitBeforeMutationEffects(root, firstChild) {
		  root = root.containerInfo;
		  eventsEnabled = _enabled;
		  root = getActiveElementDeep(root);
		  if (hasSelectionCapabilities(root)) {
		    if ("selectionStart" in root)
		      var JSCompiler_temp = {
		        start: root.selectionStart,
		        end: root.selectionEnd
		      };
		    else
		      a: {
		        JSCompiler_temp =
		          ((JSCompiler_temp = root.ownerDocument) &&
		            JSCompiler_temp.defaultView) ||
		          window;
		        var selection =
		          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
		        if (selection && 0 !== selection.rangeCount) {
		          JSCompiler_temp = selection.anchorNode;
		          var anchorOffset = selection.anchorOffset,
		            focusNode = selection.focusNode;
		          selection = selection.focusOffset;
		          try {
		            JSCompiler_temp.nodeType, focusNode.nodeType;
		          } catch (e$20) {
		            JSCompiler_temp = null;
		            break a;
		          }
		          var length = 0,
		            start = -1,
		            end = -1,
		            indexWithinAnchor = 0,
		            indexWithinFocus = 0,
		            node = root,
		            parentNode = null;
		          b: for (;;) {
		            for (var next; ; ) {
		              node !== JSCompiler_temp ||
		                (0 !== anchorOffset && 3 !== node.nodeType) ||
		                (start = length + anchorOffset);
		              node !== focusNode ||
		                (0 !== selection && 3 !== node.nodeType) ||
		                (end = length + selection);
		              3 === node.nodeType && (length += node.nodeValue.length);
		              if (null === (next = node.firstChild)) break;
		              parentNode = node;
		              node = next;
		            }
		            for (;;) {
		              if (node === root) break b;
		              parentNode === JSCompiler_temp &&
		                ++indexWithinAnchor === anchorOffset &&
		                (start = length);
		              parentNode === focusNode &&
		                ++indexWithinFocus === selection &&
		                (end = length);
		              if (null !== (next = node.nextSibling)) break;
		              node = parentNode;
		              parentNode = node.parentNode;
		            }
		            node = next;
		          }
		          JSCompiler_temp =
		            -1 === start || -1 === end ? null : { start: start, end: end };
		        } else JSCompiler_temp = null;
		      }
		    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
		  } else JSCompiler_temp = null;
		  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
		  _enabled = false;
		  for (nextEffect = firstChild; null !== nextEffect; )
		    if (
		      ((firstChild = nextEffect),
		      (root = firstChild.child),
		      0 !== (firstChild.subtreeFlags & 1024) && null !== root)
		    )
		      (root.return = firstChild), (nextEffect = root);
		    else
		      for (; null !== nextEffect; ) {
		        firstChild = nextEffect;
		        focusNode = firstChild.alternate;
		        root = firstChild.flags;
		        switch (firstChild.tag) {
		          case 0:
		            break;
		          case 11:
		          case 15:
		            break;
		          case 1:
		            if (0 !== (root & 1024) && null !== focusNode) {
		              root = void 0;
		              JSCompiler_temp = firstChild;
		              anchorOffset = focusNode.memoizedProps;
		              focusNode = focusNode.memoizedState;
		              selection = JSCompiler_temp.stateNode;
		              try {
		                var resolvedPrevProps = resolveClassComponentProps(
		                  JSCompiler_temp.type,
		                  anchorOffset,
		                  JSCompiler_temp.elementType === JSCompiler_temp.type
		                );
		                root = selection.getSnapshotBeforeUpdate(
		                  resolvedPrevProps,
		                  focusNode
		                );
		                selection.__reactInternalSnapshotBeforeUpdate = root;
		              } catch (error) {
		                captureCommitPhaseError(
		                  JSCompiler_temp,
		                  JSCompiler_temp.return,
		                  error
		                );
		              }
		            }
		            break;
		          case 3:
		            if (0 !== (root & 1024))
		              if (
		                ((root = firstChild.stateNode.containerInfo),
		                (JSCompiler_temp = root.nodeType),
		                9 === JSCompiler_temp)
		              )
		                clearContainerSparingly(root);
		              else if (1 === JSCompiler_temp)
		                switch (root.nodeName) {
		                  case "HEAD":
		                  case "HTML":
		                  case "BODY":
		                    clearContainerSparingly(root);
		                    break;
		                  default:
		                    root.textContent = "";
		                }
		            break;
		          case 5:
		          case 26:
		          case 27:
		          case 6:
		          case 4:
		          case 17:
		            break;
		          default:
		            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
		        }
		        root = firstChild.sibling;
		        if (null !== root) {
		          root.return = firstChild.return;
		          nextEffect = root;
		          break;
		        }
		        nextEffect = firstChild.return;
		      }
		}
		function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		  var flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      flags & 4 && commitHookEffectListMount(5, finishedWork);
		      break;
		    case 1:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      if (flags & 4)
		        if (((finishedRoot = finishedWork.stateNode), null === current))
		          try {
		            finishedRoot.componentDidMount();
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        else {
		          var prevProps = resolveClassComponentProps(
		            finishedWork.type,
		            current.memoizedProps
		          );
		          current = current.memoizedState;
		          try {
		            finishedRoot.componentDidUpdate(
		              prevProps,
		              current,
		              finishedRoot.__reactInternalSnapshotBeforeUpdate
		            );
		          } catch (error$142) {
		            captureCommitPhaseError(
		              finishedWork,
		              finishedWork.return,
		              error$142
		            );
		          }
		        }
		      flags & 64 && commitClassCallbacks(finishedWork);
		      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		      break;
		    case 3:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      if (
		        flags & 64 &&
		        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
		      ) {
		        current = null;
		        if (null !== finishedWork.child)
		          switch (finishedWork.child.tag) {
		            case 27:
		            case 5:
		              current = finishedWork.child.stateNode;
		              break;
		            case 1:
		              current = finishedWork.child.stateNode;
		          }
		        try {
		          commitCallbacks(finishedRoot, current);
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      break;
		    case 27:
		      null === current &&
		        flags & 4 &&
		        commitHostSingletonAcquisition(finishedWork);
		    case 26:
		    case 5:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      null === current && flags & 4 && commitHostMount(finishedWork);
		      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		      break;
		    case 12:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      break;
		    case 13:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		      flags & 64 &&
		        ((finishedRoot = finishedWork.memoizedState),
		        null !== finishedRoot &&
		          ((finishedRoot = finishedRoot.dehydrated),
		          null !== finishedRoot &&
		            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
		              null,
		              finishedWork
		            )),
		            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
		      break;
		    case 22:
		      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
		      if (!flags) {
		        current =
		          (null !== current && null !== current.memoizedState) ||
		          offscreenSubtreeWasHidden;
		        prevProps = offscreenSubtreeIsHidden;
		        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		        offscreenSubtreeIsHidden = flags;
		        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
		          ? recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              0 !== (finishedWork.subtreeFlags & 8772)
		            )
		          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        offscreenSubtreeIsHidden = prevProps;
		        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		      }
		      break;
		    case 30:
		      break;
		    default:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		  }
		}
		function detachFiberAfterEffects(fiber) {
		  var alternate = fiber.alternate;
		  null !== alternate &&
		    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
		  fiber.child = null;
		  fiber.deletions = null;
		  fiber.sibling = null;
		  5 === fiber.tag &&
		    ((alternate = fiber.stateNode),
		    null !== alternate && detachDeletedInstance(alternate));
		  fiber.stateNode = null;
		  fiber.return = null;
		  fiber.dependencies = null;
		  fiber.memoizedProps = null;
		  fiber.memoizedState = null;
		  fiber.pendingProps = null;
		  fiber.stateNode = null;
		  fiber.updateQueue = null;
		}
		var hostParent = null,
		  hostParentIsContainer = false;
		function recursivelyTraverseDeletionEffects(
		  finishedRoot,
		  nearestMountedAncestor,
		  parent
		) {
		  for (parent = parent.child; null !== parent; )
		    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
		      (parent = parent.sibling);
		}
		function commitDeletionEffectsOnFiber(
		  finishedRoot,
		  nearestMountedAncestor,
		  deletedFiber
		) {
		  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
		    try {
		      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		    } catch (err) {}
		  switch (deletedFiber.tag) {
		    case 26:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      deletedFiber.memoizedState
		        ? deletedFiber.memoizedState.count--
		        : deletedFiber.stateNode &&
		          ((deletedFiber = deletedFiber.stateNode),
		          deletedFiber.parentNode.removeChild(deletedFiber));
		      break;
		    case 27:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		      var prevHostParent = hostParent,
		        prevHostParentIsContainer = hostParentIsContainer;
		      isSingletonScope(deletedFiber.type) &&
		        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = false));
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      releaseSingletonInstance(deletedFiber.stateNode);
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      break;
		    case 5:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		    case 6:
		      prevHostParent = hostParent;
		      prevHostParentIsContainer = hostParentIsContainer;
		      hostParent = null;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      if (null !== hostParent)
		        if (hostParentIsContainer)
		          try {
		            (9 === hostParent.nodeType
		              ? hostParent.body
		              : "HTML" === hostParent.nodeName
		                ? hostParent.ownerDocument.body
		                : hostParent
		            ).removeChild(deletedFiber.stateNode);
		          } catch (error) {
		            captureCommitPhaseError(
		              deletedFiber,
		              nearestMountedAncestor,
		              error
		            );
		          }
		        else
		          try {
		            hostParent.removeChild(deletedFiber.stateNode);
		          } catch (error) {
		            captureCommitPhaseError(
		              deletedFiber,
		              nearestMountedAncestor,
		              error
		            );
		          }
		      break;
		    case 18:
		      null !== hostParent &&
		        (hostParentIsContainer
		          ? ((finishedRoot = hostParent),
		            clearSuspenseBoundary(
		              9 === finishedRoot.nodeType
		                ? finishedRoot.body
		                : "HTML" === finishedRoot.nodeName
		                  ? finishedRoot.ownerDocument.body
		                  : finishedRoot,
		              deletedFiber.stateNode
		            ),
		            retryIfBlockedOn(finishedRoot))
		          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
		      break;
		    case 4:
		      prevHostParent = hostParent;
		      prevHostParentIsContainer = hostParentIsContainer;
		      hostParent = deletedFiber.stateNode.containerInfo;
		      hostParentIsContainer = true;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      break;
		    case 0:
		    case 11:
		    case 14:
		    case 15:
		      offscreenSubtreeWasHidden ||
		        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
		      offscreenSubtreeWasHidden ||
		        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 1:
		      offscreenSubtreeWasHidden ||
		        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
		        (prevHostParent = deletedFiber.stateNode),
		        "function" === typeof prevHostParent.componentWillUnmount &&
		          safelyCallComponentWillUnmount(
		            deletedFiber,
		            nearestMountedAncestor,
		            prevHostParent
		          ));
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 21:
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 22:
		      offscreenSubtreeWasHidden =
		        (prevHostParent = offscreenSubtreeWasHidden) ||
		        null !== deletedFiber.memoizedState;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      offscreenSubtreeWasHidden = prevHostParent;
		      break;
		    default:
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		  }
		}
		function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		  if (
		    null === finishedWork.memoizedState &&
		    ((finishedRoot = finishedWork.alternate),
		    null !== finishedRoot &&
		      ((finishedRoot = finishedRoot.memoizedState),
		      null !== finishedRoot &&
		        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
		  )
		    try {
		      retryIfBlockedOn(finishedRoot);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		}
		function getRetryCache(finishedWork) {
		  switch (finishedWork.tag) {
		    case 13:
		    case 19:
		      var retryCache = finishedWork.stateNode;
		      null === retryCache &&
		        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
		      return retryCache;
		    case 22:
		      return (
		        (finishedWork = finishedWork.stateNode),
		        (retryCache = finishedWork._retryCache),
		        null === retryCache &&
		          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
		        retryCache
		      );
		    default:
		      throw Error(formatProdErrorMessage(435, finishedWork.tag));
		  }
		}
		function attachSuspenseRetryListeners(finishedWork, wakeables) {
		  var retryCache = getRetryCache(finishedWork);
		  wakeables.forEach(function (wakeable) {
		    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
		    retryCache.has(wakeable) ||
		      (retryCache.add(wakeable), wakeable.then(retry, retry));
		  });
		}
		function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (null !== deletions)
		    for (var i = 0; i < deletions.length; i++) {
		      var childToDelete = deletions[i],
		        root = root$jscomp$0,
		        returnFiber = parentFiber,
		        parent = returnFiber;
		      a: for (; null !== parent; ) {
		        switch (parent.tag) {
		          case 27:
		            if (isSingletonScope(parent.type)) {
		              hostParent = parent.stateNode;
		              hostParentIsContainer = false;
		              break a;
		            }
		            break;
		          case 5:
		            hostParent = parent.stateNode;
		            hostParentIsContainer = false;
		            break a;
		          case 3:
		          case 4:
		            hostParent = parent.stateNode.containerInfo;
		            hostParentIsContainer = true;
		            break a;
		        }
		        parent = parent.return;
		      }
		      if (null === hostParent) throw Error(formatProdErrorMessage(160));
		      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
		      hostParent = null;
		      hostParentIsContainer = false;
		      root = childToDelete.alternate;
		      null !== root && (root.return = null);
		      childToDelete.return = null;
		    }
		  if (parentFiber.subtreeFlags & 13878)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
		        (parentFiber = parentFiber.sibling);
		}
		var currentHoistableRoot = null;
		function commitMutationEffectsOnFiber(finishedWork, root) {
		  var current = finishedWork.alternate,
		    flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 14:
		    case 15:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 4 &&
		        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
		        commitHookEffectListMount(3, finishedWork),
		        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
		      break;
		    case 1:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      flags & 64 &&
		        offscreenSubtreeIsHidden &&
		        ((finishedWork = finishedWork.updateQueue),
		        null !== finishedWork &&
		          ((flags = finishedWork.callbacks),
		          null !== flags &&
		            ((current = finishedWork.shared.hiddenCallbacks),
		            (finishedWork.shared.hiddenCallbacks =
		              null === current ? flags : current.concat(flags)))));
		      break;
		    case 26:
		      var hoistableRoot = currentHoistableRoot;
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      if (flags & 4) {
		        var currentResource = null !== current ? current.memoizedState : null;
		        flags = finishedWork.memoizedState;
		        if (null === current)
		          if (null === flags)
		            if (null === finishedWork.stateNode) {
		              a: {
		                flags = finishedWork.type;
		                current = finishedWork.memoizedProps;
		                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		                b: switch (flags) {
		                  case "title":
		                    currentResource =
		                      hoistableRoot.getElementsByTagName("title")[0];
		                    if (
		                      !currentResource ||
		                      currentResource[internalHoistableMarker] ||
		                      currentResource[internalInstanceKey] ||
		                      "http://www.w3.org/2000/svg" ===
		                        currentResource.namespaceURI ||
		                      currentResource.hasAttribute("itemprop")
		                    )
		                      (currentResource = hoistableRoot.createElement(flags)),
		                        hoistableRoot.head.insertBefore(
		                          currentResource,
		                          hoistableRoot.querySelector("head > title")
		                        );
		                    setInitialProperties(currentResource, flags, current);
		                    currentResource[internalInstanceKey] = finishedWork;
		                    markNodeAsHoistable(currentResource);
		                    flags = currentResource;
		                    break a;
		                  case "link":
		                    var maybeNodes = getHydratableHoistableCache(
		                      "link",
		                      "href",
		                      hoistableRoot
		                    ).get(flags + (current.href || ""));
		                    if (maybeNodes)
		                      for (var i = 0; i < maybeNodes.length; i++)
		                        if (
		                          ((currentResource = maybeNodes[i]),
		                          currentResource.getAttribute("href") ===
		                            (null == current.href || "" === current.href
		                              ? null
		                              : current.href) &&
		                            currentResource.getAttribute("rel") ===
		                              (null == current.rel ? null : current.rel) &&
		                            currentResource.getAttribute("title") ===
		                              (null == current.title ? null : current.title) &&
		                            currentResource.getAttribute("crossorigin") ===
		                              (null == current.crossOrigin
		                                ? null
		                                : current.crossOrigin))
		                        ) {
		                          maybeNodes.splice(i, 1);
		                          break b;
		                        }
		                    currentResource = hoistableRoot.createElement(flags);
		                    setInitialProperties(currentResource, flags, current);
		                    hoistableRoot.head.appendChild(currentResource);
		                    break;
		                  case "meta":
		                    if (
		                      (maybeNodes = getHydratableHoistableCache(
		                        "meta",
		                        "content",
		                        hoistableRoot
		                      ).get(flags + (current.content || "")))
		                    )
		                      for (i = 0; i < maybeNodes.length; i++)
		                        if (
		                          ((currentResource = maybeNodes[i]),
		                          currentResource.getAttribute("content") ===
		                            (null == current.content
		                              ? null
		                              : "" + current.content) &&
		                            currentResource.getAttribute("name") ===
		                              (null == current.name ? null : current.name) &&
		                            currentResource.getAttribute("property") ===
		                              (null == current.property
		                                ? null
		                                : current.property) &&
		                            currentResource.getAttribute("http-equiv") ===
		                              (null == current.httpEquiv
		                                ? null
		                                : current.httpEquiv) &&
		                            currentResource.getAttribute("charset") ===
		                              (null == current.charSet
		                                ? null
		                                : current.charSet))
		                        ) {
		                          maybeNodes.splice(i, 1);
		                          break b;
		                        }
		                    currentResource = hoistableRoot.createElement(flags);
		                    setInitialProperties(currentResource, flags, current);
		                    hoistableRoot.head.appendChild(currentResource);
		                    break;
		                  default:
		                    throw Error(formatProdErrorMessage(468, flags));
		                }
		                currentResource[internalInstanceKey] = finishedWork;
		                markNodeAsHoistable(currentResource);
		                flags = currentResource;
		              }
		              finishedWork.stateNode = flags;
		            } else
		              mountHoistable(
		                hoistableRoot,
		                finishedWork.type,
		                finishedWork.stateNode
		              );
		          else
		            finishedWork.stateNode = acquireResource(
		              hoistableRoot,
		              flags,
		              finishedWork.memoizedProps
		            );
		        else
		          currentResource !== flags
		            ? (null === currentResource
		                ? null !== current.stateNode &&
		                  ((current = current.stateNode),
		                  current.parentNode.removeChild(current))
		                : currentResource.count--,
		              null === flags
		                ? mountHoistable(
		                    hoistableRoot,
		                    finishedWork.type,
		                    finishedWork.stateNode
		                  )
		                : acquireResource(
		                    hoistableRoot,
		                    flags,
		                    finishedWork.memoizedProps
		                  ))
		            : null === flags &&
		              null !== finishedWork.stateNode &&
		              commitHostUpdate(
		                finishedWork,
		                finishedWork.memoizedProps,
		                current.memoizedProps
		              );
		      }
		      break;
		    case 27:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      null !== current &&
		        flags & 4 &&
		        commitHostUpdate(
		          finishedWork,
		          finishedWork.memoizedProps,
		          current.memoizedProps
		        );
		      break;
		    case 5:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      if (finishedWork.flags & 32) {
		        hoistableRoot = finishedWork.stateNode;
		        try {
		          setTextContent(hoistableRoot, "");
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      flags & 4 &&
		        null != finishedWork.stateNode &&
		        ((hoistableRoot = finishedWork.memoizedProps),
		        commitHostUpdate(
		          finishedWork,
		          hoistableRoot,
		          null !== current ? current.memoizedProps : hoistableRoot
		        ));
		      flags & 1024 && (needsFormReset = true);
		      break;
		    case 6:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      if (flags & 4) {
		        if (null === finishedWork.stateNode)
		          throw Error(formatProdErrorMessage(162));
		        flags = finishedWork.memoizedProps;
		        current = finishedWork.stateNode;
		        try {
		          current.nodeValue = flags;
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      break;
		    case 3:
		      tagCaches = null;
		      hoistableRoot = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(root.containerInfo);
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      currentHoistableRoot = hoistableRoot;
		      commitReconciliationEffects(finishedWork);
		      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
		        try {
		          retryIfBlockedOn(root.containerInfo);
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      needsFormReset &&
		        ((needsFormReset = false), recursivelyResetForms(finishedWork));
		      break;
		    case 4:
		      flags = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(
		        finishedWork.stateNode.containerInfo
		      );
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      currentHoistableRoot = flags;
		      break;
		    case 12:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      break;
		    case 13:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      finishedWork.child.flags & 8192 &&
		        (null !== finishedWork.memoizedState) !==
		          (null !== current && null !== current.memoizedState) &&
		        (globalMostRecentFallbackTime = now());
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((finishedWork.updateQueue = null),
		          attachSuspenseRetryListeners(finishedWork, flags)));
		      break;
		    case 22:
		      hoistableRoot = null !== finishedWork.memoizedState;
		      var wasHidden = null !== current && null !== current.memoizedState,
		        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
		      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		      commitReconciliationEffects(finishedWork);
		      if (flags & 8192)
		        a: for (
		          root = finishedWork.stateNode,
		            root._visibility = hoistableRoot
		              ? root._visibility & -2
		              : root._visibility | 1,
		            hoistableRoot &&
		              (null === current ||
		                wasHidden ||
		                offscreenSubtreeIsHidden ||
		                offscreenSubtreeWasHidden ||
		                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
		            current = null,
		            root = finishedWork;
		          ;

		        ) {
		          if (5 === root.tag || 26 === root.tag) {
		            if (null === current) {
		              wasHidden = current = root;
		              try {
		                if (((currentResource = wasHidden.stateNode), hoistableRoot))
		                  (maybeNodes = currentResource.style),
		                    "function" === typeof maybeNodes.setProperty
		                      ? maybeNodes.setProperty("display", "none", "important")
		                      : (maybeNodes.display = "none");
		                else {
		                  i = wasHidden.stateNode;
		                  var styleProp = wasHidden.memoizedProps.style,
		                    display =
		                      void 0 !== styleProp &&
		                      null !== styleProp &&
		                      styleProp.hasOwnProperty("display")
		                        ? styleProp.display
		                        : null;
		                  i.style.display =
		                    null == display || "boolean" === typeof display
		                      ? ""
		                      : ("" + display).trim();
		                }
		              } catch (error) {
		                captureCommitPhaseError(wasHidden, wasHidden.return, error);
		              }
		            }
		          } else if (6 === root.tag) {
		            if (null === current) {
		              wasHidden = root;
		              try {
		                wasHidden.stateNode.nodeValue = hoistableRoot
		                  ? ""
		                  : wasHidden.memoizedProps;
		              } catch (error) {
		                captureCommitPhaseError(wasHidden, wasHidden.return, error);
		              }
		            }
		          } else if (
		            ((22 !== root.tag && 23 !== root.tag) ||
		              null === root.memoizedState ||
		              root === finishedWork) &&
		            null !== root.child
		          ) {
		            root.child.return = root;
		            root = root.child;
		            continue;
		          }
		          if (root === finishedWork) break a;
		          for (; null === root.sibling; ) {
		            if (null === root.return || root.return === finishedWork) break a;
		            current === root && (current = null);
		            root = root.return;
		          }
		          current === root && (current = null);
		          root.sibling.return = root.return;
		          root = root.sibling;
		        }
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((current = flags.retryQueue),
		          null !== current &&
		            ((flags.retryQueue = null),
		            attachSuspenseRetryListeners(finishedWork, current))));
		      break;
		    case 19:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((finishedWork.updateQueue = null),
		          attachSuspenseRetryListeners(finishedWork, flags)));
		      break;
		    case 30:
		      break;
		    case 21:
		      break;
		    default:
		      recursivelyTraverseMutationEffects(root, finishedWork),
		        commitReconciliationEffects(finishedWork);
		  }
		}
		function commitReconciliationEffects(finishedWork) {
		  var flags = finishedWork.flags;
		  if (flags & 2) {
		    try {
		      for (
		        var hostParentFiber, parentFiber = finishedWork.return;
		        null !== parentFiber;

		      ) {
		        if (isHostParent(parentFiber)) {
		          hostParentFiber = parentFiber;
		          break;
		        }
		        parentFiber = parentFiber.return;
		      }
		      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
		      switch (hostParentFiber.tag) {
		        case 27:
		          var parent = hostParentFiber.stateNode,
		            before = getHostSibling(finishedWork);
		          insertOrAppendPlacementNode(finishedWork, before, parent);
		          break;
		        case 5:
		          var parent$144 = hostParentFiber.stateNode;
		          hostParentFiber.flags & 32 &&
		            (setTextContent(parent$144, ""), (hostParentFiber.flags &= -33));
		          var before$145 = getHostSibling(finishedWork);
		          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
		          break;
		        case 3:
		        case 4:
		          var parent$146 = hostParentFiber.stateNode.containerInfo,
		            before$147 = getHostSibling(finishedWork);
		          insertOrAppendPlacementNodeIntoContainer(
		            finishedWork,
		            before$147,
		            parent$146
		          );
		          break;
		        default:
		          throw Error(formatProdErrorMessage(161));
		      }
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		    finishedWork.flags &= -3;
		  }
		  flags & 4096 && (finishedWork.flags &= -4097);
		}
		function recursivelyResetForms(parentFiber) {
		  if (parentFiber.subtreeFlags & 1024)
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var fiber = parentFiber;
		      recursivelyResetForms(fiber);
		      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
		      parentFiber = parentFiber.sibling;
		    }
		}
		function recursivelyTraverseLayoutEffects(root, parentFiber) {
		  if (parentFiber.subtreeFlags & 8772)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var finishedWork = parentFiber;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 14:
		      case 15:
		        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 1:
		        safelyDetachRef(finishedWork, finishedWork.return);
		        var instance = finishedWork.stateNode;
		        "function" === typeof instance.componentWillUnmount &&
		          safelyCallComponentWillUnmount(
		            finishedWork,
		            finishedWork.return,
		            instance
		          );
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 27:
		        releaseSingletonInstance(finishedWork.stateNode);
		      case 26:
		      case 5:
		        safelyDetachRef(finishedWork, finishedWork.return);
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 22:
		        null === finishedWork.memoizedState &&
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 30:
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      default:
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function recursivelyTraverseReappearLayoutEffects(
		  finishedRoot$jscomp$0,
		  parentFiber,
		  includeWorkInProgressEffects
		) {
		  includeWorkInProgressEffects =
		    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var current = parentFiber.alternate,
		      finishedRoot = finishedRoot$jscomp$0,
		      finishedWork = parentFiber,
		      flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        commitHookEffectListMount(4, finishedWork);
		        break;
		      case 1:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        current = finishedWork;
		        finishedRoot = current.stateNode;
		        if ("function" === typeof finishedRoot.componentDidMount)
		          try {
		            finishedRoot.componentDidMount();
		          } catch (error) {
		            captureCommitPhaseError(current, current.return, error);
		          }
		        current = finishedWork;
		        finishedRoot = current.updateQueue;
		        if (null !== finishedRoot) {
		          var instance = current.stateNode;
		          try {
		            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
		            if (null !== hiddenCallbacks)
		              for (
		                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
		                finishedRoot < hiddenCallbacks.length;
		                finishedRoot++
		              )
		                callCallback(hiddenCallbacks[finishedRoot], instance);
		          } catch (error) {
		            captureCommitPhaseError(current, current.return, error);
		          }
		        }
		        includeWorkInProgressEffects &&
		          flags & 64 &&
		          commitClassCallbacks(finishedWork);
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 27:
		        commitHostSingletonAcquisition(finishedWork);
		      case 26:
		      case 5:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          null === current &&
		          flags & 4 &&
		          commitHostMount(finishedWork);
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 12:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        break;
		      case 13:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          flags & 4 &&
		          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		        break;
		      case 22:
		        null === finishedWork.memoizedState &&
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 30:
		        break;
		      default:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function commitOffscreenPassiveMountEffects(current, finishedWork) {
		  var previousCache = null;
		  null !== current &&
		    null !== current.memoizedState &&
		    null !== current.memoizedState.cachePool &&
		    (previousCache = current.memoizedState.cachePool.pool);
		  current = null;
		  null !== finishedWork.memoizedState &&
		    null !== finishedWork.memoizedState.cachePool &&
		    (current = finishedWork.memoizedState.cachePool.pool);
		  current !== previousCache &&
		    (null != current && current.refCount++,
		    null != previousCache && releaseCache(previousCache));
		}
		function commitCachePassiveMountEffect(current, finishedWork) {
		  current = null;
		  null !== finishedWork.alternate &&
		    (current = finishedWork.alternate.memoizedState.cache);
		  finishedWork = finishedWork.memoizedState.cache;
		  finishedWork !== current &&
		    (finishedWork.refCount++, null != current && releaseCache(current));
		}
		function recursivelyTraversePassiveMountEffects(
		  root,
		  parentFiber,
		  committedLanes,
		  committedTransitions
		) {
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitPassiveMountOnFiber(
		        root,
		        parentFiber,
		        committedLanes,
		        committedTransitions
		      ),
		        (parentFiber = parentFiber.sibling);
		}
		function commitPassiveMountOnFiber(
		  finishedRoot,
		  finishedWork,
		  committedLanes,
		  committedTransitions
		) {
		  var flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 && commitHookEffectListMount(9, finishedWork);
		      break;
		    case 1:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      break;
		    case 3:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 &&
		        ((finishedRoot = null),
		        null !== finishedWork.alternate &&
		          (finishedRoot = finishedWork.alternate.memoizedState.cache),
		        (finishedWork = finishedWork.memoizedState.cache),
		        finishedWork !== finishedRoot &&
		          (finishedWork.refCount++,
		          null != finishedRoot && releaseCache(finishedRoot)));
		      break;
		    case 12:
		      if (flags & 2048) {
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		        finishedRoot = finishedWork.stateNode;
		        try {
		          var _finishedWork$memoize2 = finishedWork.memoizedProps,
		            id = _finishedWork$memoize2.id,
		            onPostCommit = _finishedWork$memoize2.onPostCommit;
		          "function" === typeof onPostCommit &&
		            onPostCommit(
		              id,
		              null === finishedWork.alternate ? "mount" : "update",
		              finishedRoot.passiveEffectDuration,
		              -0
		            );
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      } else
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		      break;
		    case 13:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      break;
		    case 23:
		      break;
		    case 22:
		      _finishedWork$memoize2 = finishedWork.stateNode;
		      id = finishedWork.alternate;
		      null !== finishedWork.memoizedState
		        ? _finishedWork$memoize2._visibility & 2
		          ? recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            )
		          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
		        : _finishedWork$memoize2._visibility & 2
		          ? recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            )
		          : ((_finishedWork$memoize2._visibility |= 2),
		            recursivelyTraverseReconnectPassiveEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions,
		              0 !== (finishedWork.subtreeFlags & 10256)
		            ));
		      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
		      break;
		    case 24:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 &&
		        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		      break;
		    default:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		  }
		}
		function recursivelyTraverseReconnectPassiveEffects(
		  finishedRoot$jscomp$0,
		  parentFiber,
		  committedLanes$jscomp$0,
		  committedTransitions$jscomp$0,
		  includeWorkInProgressEffects
		) {
		  includeWorkInProgressEffects =
		    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var finishedRoot = finishedRoot$jscomp$0,
		      finishedWork = parentFiber,
		      committedLanes = committedLanes$jscomp$0,
		      committedTransitions = committedTransitions$jscomp$0,
		      flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		        commitHookEffectListMount(8, finishedWork);
		        break;
		      case 23:
		        break;
		      case 22:
		        var instance = finishedWork.stateNode;
		        null !== finishedWork.memoizedState
		          ? instance._visibility & 2
		            ? recursivelyTraverseReconnectPassiveEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions,
		                includeWorkInProgressEffects
		              )
		            : recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              )
		          : ((instance._visibility |= 2),
		            recursivelyTraverseReconnectPassiveEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions,
		              includeWorkInProgressEffects
		            ));
		        includeWorkInProgressEffects &&
		          flags & 2048 &&
		          commitOffscreenPassiveMountEffects(
		            finishedWork.alternate,
		            finishedWork
		          );
		        break;
		      case 24:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          flags & 2048 &&
		          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		        break;
		      default:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function recursivelyTraverseAtomicPassiveEffects(
		  finishedRoot$jscomp$0,
		  parentFiber
		) {
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var finishedRoot = finishedRoot$jscomp$0,
		        finishedWork = parentFiber,
		        flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 22:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		          flags & 2048 &&
		            commitOffscreenPassiveMountEffects(
		              finishedWork.alternate,
		              finishedWork
		            );
		          break;
		        case 24:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		          flags & 2048 &&
		            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		          break;
		        default:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		      }
		      parentFiber = parentFiber.sibling;
		    }
		}
		var suspenseyCommitFlag = 8192;
		function recursivelyAccumulateSuspenseyCommit(parentFiber) {
		  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      accumulateSuspenseyCommitOnFiber(parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function accumulateSuspenseyCommitOnFiber(fiber) {
		  switch (fiber.tag) {
		    case 26:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      fiber.flags & suspenseyCommitFlag &&
		        null !== fiber.memoizedState &&
		        suspendResource(
		          currentHoistableRoot,
		          fiber.memoizedState,
		          fiber.memoizedProps
		        );
		      break;
		    case 5:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      break;
		    case 3:
		    case 4:
		      var previousHoistableRoot = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      currentHoistableRoot = previousHoistableRoot;
		      break;
		    case 22:
		      null === fiber.memoizedState &&
		        ((previousHoistableRoot = fiber.alternate),
		        null !== previousHoistableRoot &&
		        null !== previousHoistableRoot.memoizedState
		          ? ((previousHoistableRoot = suspenseyCommitFlag),
		            (suspenseyCommitFlag = 16777216),
		            recursivelyAccumulateSuspenseyCommit(fiber),
		            (suspenseyCommitFlag = previousHoistableRoot))
		          : recursivelyAccumulateSuspenseyCommit(fiber));
		      break;
		    default:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		  }
		}
		function detachAlternateSiblings(parentFiber) {
		  var previousFiber = parentFiber.alternate;
		  if (
		    null !== previousFiber &&
		    ((parentFiber = previousFiber.child), null !== parentFiber)
		  ) {
		    previousFiber.child = null;
		    do
		      (previousFiber = parentFiber.sibling),
		        (parentFiber.sibling = null),
		        (parentFiber = previousFiber);
		    while (null !== parentFiber);
		  }
		}
		function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (0 !== (parentFiber.flags & 16)) {
		    if (null !== deletions)
		      for (var i = 0; i < deletions.length; i++) {
		        var childToDelete = deletions[i];
		        nextEffect = childToDelete;
		        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		          childToDelete,
		          parentFiber
		        );
		      }
		    detachAlternateSiblings(parentFiber);
		  }
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitPassiveUnmountOnFiber(parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function commitPassiveUnmountOnFiber(finishedWork) {
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      finishedWork.flags & 2048 &&
		        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
		      break;
		    case 3:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    case 12:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    case 22:
		      var instance = finishedWork.stateNode;
		      null !== finishedWork.memoizedState &&
		      instance._visibility & 2 &&
		      (null === finishedWork.return || 13 !== finishedWork.return.tag)
		        ? ((instance._visibility &= -3),
		          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
		        : recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    default:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		  }
		}
		function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (0 !== (parentFiber.flags & 16)) {
		    if (null !== deletions)
		      for (var i = 0; i < deletions.length; i++) {
		        var childToDelete = deletions[i];
		        nextEffect = childToDelete;
		        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		          childToDelete,
		          parentFiber
		        );
		      }
		    detachAlternateSiblings(parentFiber);
		  }
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    deletions = parentFiber;
		    switch (deletions.tag) {
		      case 0:
		      case 11:
		      case 15:
		        commitHookEffectListUnmount(8, deletions, deletions.return);
		        recursivelyTraverseDisconnectPassiveEffects(deletions);
		        break;
		      case 22:
		        i = deletions.stateNode;
		        i._visibility & 2 &&
		          ((i._visibility &= -3),
		          recursivelyTraverseDisconnectPassiveEffects(deletions));
		        break;
		      default:
		        recursivelyTraverseDisconnectPassiveEffects(deletions);
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		  deletedSubtreeRoot,
		  nearestMountedAncestor
		) {
		  for (; null !== nextEffect; ) {
		    var fiber = nextEffect;
		    switch (fiber.tag) {
		      case 0:
		      case 11:
		      case 15:
		        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
		        break;
		      case 23:
		      case 22:
		        if (
		          null !== fiber.memoizedState &&
		          null !== fiber.memoizedState.cachePool
		        ) {
		          var cache = fiber.memoizedState.cachePool.pool;
		          null != cache && cache.refCount++;
		        }
		        break;
		      case 24:
		        releaseCache(fiber.memoizedState.cache);
		    }
		    cache = fiber.child;
		    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
		    else
		      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
		        cache = nextEffect;
		        var sibling = cache.sibling,
		          returnFiber = cache.return;
		        detachFiberAfterEffects(cache);
		        if (cache === fiber) {
		          nextEffect = null;
		          break a;
		        }
		        if (null !== sibling) {
		          sibling.return = returnFiber;
		          nextEffect = sibling;
		          break a;
		        }
		        nextEffect = returnFiber;
		      }
		  }
		}
		var DefaultAsyncDispatcher = {
		    getCacheForType: function (resourceType) {
		      var cache = readContext(CacheContext),
		        cacheForType = cache.data.get(resourceType);
		      void 0 === cacheForType &&
		        ((cacheForType = resourceType()),
		        cache.data.set(resourceType, cacheForType));
		      return cacheForType;
		    }
		  },
		  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
		  executionContext = 0,
		  workInProgressRoot = null,
		  workInProgress = null,
		  workInProgressRootRenderLanes = 0,
		  workInProgressSuspendedReason = 0,
		  workInProgressThrownValue = null,
		  workInProgressRootDidSkipSuspendedSiblings = false,
		  workInProgressRootIsPrerendering = false,
		  workInProgressRootDidAttachPingListener = false,
		  entangledRenderLanes = 0,
		  workInProgressRootExitStatus = 0,
		  workInProgressRootSkippedLanes = 0,
		  workInProgressRootInterleavedUpdatedLanes = 0,
		  workInProgressRootPingedLanes = 0,
		  workInProgressDeferredLane = 0,
		  workInProgressSuspendedRetryLanes = 0,
		  workInProgressRootConcurrentErrors = null,
		  workInProgressRootRecoverableErrors = null,
		  workInProgressRootDidIncludeRecursiveRenderUpdate = false,
		  globalMostRecentFallbackTime = 0,
		  workInProgressRootRenderTargetTime = Infinity,
		  workInProgressTransitions = null,
		  legacyErrorBoundariesThatAlreadyFailed = null,
		  pendingEffectsStatus = 0,
		  pendingEffectsRoot = null,
		  pendingFinishedWork = null,
		  pendingEffectsLanes = 0,
		  pendingEffectsRemainingLanes = 0,
		  pendingPassiveTransitions = null,
		  pendingRecoverableErrors = null,
		  nestedUpdateCount = 0,
		  rootWithNestedUpdates = null;
		function requestUpdateLane() {
		  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
		    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
		  if (null !== ReactSharedInternals.T) {
		    var actionScopeLane = currentEntangledLane;
		    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
		  }
		  return resolveUpdatePriority();
		}
		function requestDeferredLane() {
		  0 === workInProgressDeferredLane &&
		    (workInProgressDeferredLane =
		      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
		        ? claimNextTransitionLane()
		        : 536870912);
		  var suspenseHandler = suspenseHandlerStackCursor.current;
		  null !== suspenseHandler && (suspenseHandler.flags |= 32);
		  return workInProgressDeferredLane;
		}
		function scheduleUpdateOnFiber(root, fiber, lane) {
		  if (
		    (root === workInProgressRoot &&
		      (2 === workInProgressSuspendedReason ||
		        9 === workInProgressSuspendedReason)) ||
		    null !== root.cancelPendingCommit
		  )
		    prepareFreshStack(root, 0),
		      markRootSuspended(
		        root,
		        workInProgressRootRenderLanes,
		        workInProgressDeferredLane,
		        false
		      );
		  markRootUpdated$1(root, lane);
		  if (0 === (executionContext & 2) || root !== workInProgressRoot)
		    root === workInProgressRoot &&
		      (0 === (executionContext & 2) &&
		        (workInProgressRootInterleavedUpdatedLanes |= lane),
		      4 === workInProgressRootExitStatus &&
		        markRootSuspended(
		          root,
		          workInProgressRootRenderLanes,
		          workInProgressDeferredLane,
		          false
		        )),
		      ensureRootIsScheduled(root);
		}
		function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
		  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		  var shouldTimeSlice =
		      (!forceSync &&
		        0 === (lanes & 124) &&
		        0 === (lanes & root$jscomp$0.expiredLanes)) ||
		      checkIfRootIsPrerendering(root$jscomp$0, lanes),
		    exitStatus = shouldTimeSlice
		      ? renderRootConcurrent(root$jscomp$0, lanes)
		      : renderRootSync(root$jscomp$0, lanes, true),
		    renderWasConcurrent = shouldTimeSlice;
		  do {
		    if (0 === exitStatus) {
		      workInProgressRootIsPrerendering &&
		        !shouldTimeSlice &&
		        markRootSuspended(root$jscomp$0, lanes, 0, false);
		      break;
		    } else {
		      forceSync = root$jscomp$0.current.alternate;
		      if (
		        renderWasConcurrent &&
		        !isRenderConsistentWithExternalStores(forceSync)
		      ) {
		        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
		        renderWasConcurrent = false;
		        continue;
		      }
		      if (2 === exitStatus) {
		        renderWasConcurrent = lanes;
		        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
		          var JSCompiler_inline_result = 0;
		        else
		          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
		            (JSCompiler_inline_result =
		              0 !== JSCompiler_inline_result
		                ? JSCompiler_inline_result
		                : JSCompiler_inline_result & 536870912
		                  ? 536870912
		                  : 0);
		        if (0 !== JSCompiler_inline_result) {
		          lanes = JSCompiler_inline_result;
		          a: {
		            var root = root$jscomp$0;
		            exitStatus = workInProgressRootConcurrentErrors;
		            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
		            wasRootDehydrated &&
		              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
		            JSCompiler_inline_result = renderRootSync(
		              root,
		              JSCompiler_inline_result,
		              false
		            );
		            if (2 !== JSCompiler_inline_result) {
		              if (
		                workInProgressRootDidAttachPingListener &&
		                !wasRootDehydrated
		              ) {
		                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
		                workInProgressRootInterleavedUpdatedLanes |=
		                  renderWasConcurrent;
		                exitStatus = 4;
		                break a;
		              }
		              renderWasConcurrent = workInProgressRootRecoverableErrors;
		              workInProgressRootRecoverableErrors = exitStatus;
		              null !== renderWasConcurrent &&
		                (null === workInProgressRootRecoverableErrors
		                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
		                  : workInProgressRootRecoverableErrors.push.apply(
		                      workInProgressRootRecoverableErrors,
		                      renderWasConcurrent
		                    ));
		            }
		            exitStatus = JSCompiler_inline_result;
		          }
		          renderWasConcurrent = false;
		          if (2 !== exitStatus) continue;
		        }
		      }
		      if (1 === exitStatus) {
		        prepareFreshStack(root$jscomp$0, 0);
		        markRootSuspended(root$jscomp$0, lanes, 0, true);
		        break;
		      }
		      a: {
		        shouldTimeSlice = root$jscomp$0;
		        renderWasConcurrent = exitStatus;
		        switch (renderWasConcurrent) {
		          case 0:
		          case 1:
		            throw Error(formatProdErrorMessage(345));
		          case 4:
		            if ((lanes & 4194048) !== lanes) break;
		          case 6:
		            markRootSuspended(
		              shouldTimeSlice,
		              lanes,
		              workInProgressDeferredLane,
		              !workInProgressRootDidSkipSuspendedSiblings
		            );
		            break a;
		          case 2:
		            workInProgressRootRecoverableErrors = null;
		            break;
		          case 3:
		          case 5:
		            break;
		          default:
		            throw Error(formatProdErrorMessage(329));
		        }
		        if (
		          (lanes & 62914560) === lanes &&
		          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
		          10 < exitStatus)
		        ) {
		          markRootSuspended(
		            shouldTimeSlice,
		            lanes,
		            workInProgressDeferredLane,
		            !workInProgressRootDidSkipSuspendedSiblings
		          );
		          if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
		          shouldTimeSlice.timeoutHandle = scheduleTimeout(
		            commitRootWhenReady.bind(
		              null,
		              shouldTimeSlice,
		              forceSync,
		              workInProgressRootRecoverableErrors,
		              workInProgressTransitions,
		              workInProgressRootDidIncludeRecursiveRenderUpdate,
		              lanes,
		              workInProgressDeferredLane,
		              workInProgressRootInterleavedUpdatedLanes,
		              workInProgressSuspendedRetryLanes,
		              workInProgressRootDidSkipSuspendedSiblings,
		              renderWasConcurrent,
		              2,
		              -0,
		              0
		            ),
		            exitStatus
		          );
		          break a;
		        }
		        commitRootWhenReady(
		          shouldTimeSlice,
		          forceSync,
		          workInProgressRootRecoverableErrors,
		          workInProgressTransitions,
		          workInProgressRootDidIncludeRecursiveRenderUpdate,
		          lanes,
		          workInProgressDeferredLane,
		          workInProgressRootInterleavedUpdatedLanes,
		          workInProgressSuspendedRetryLanes,
		          workInProgressRootDidSkipSuspendedSiblings,
		          renderWasConcurrent,
		          0,
		          -0,
		          0
		        );
		      }
		    }
		    break;
		  } while (1);
		  ensureRootIsScheduled(root$jscomp$0);
		}
		function commitRootWhenReady(
		  root,
		  finishedWork,
		  recoverableErrors,
		  transitions,
		  didIncludeRenderPhaseUpdate,
		  lanes,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes,
		  didSkipSuspendedSiblings,
		  exitStatus,
		  suspendedCommitReason,
		  completedRenderStartTime,
		  completedRenderEndTime
		) {
		  root.timeoutHandle = -1;
		  suspendedCommitReason = finishedWork.subtreeFlags;
		  if (
		    suspendedCommitReason & 8192 ||
		    16785408 === (suspendedCommitReason & 16785408)
		  )
		    if (
		      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
		      accumulateSuspenseyCommitOnFiber(finishedWork),
		      (suspendedCommitReason = waitForCommitToBeReady()),
		      null !== suspendedCommitReason)
		    ) {
		      root.cancelPendingCommit = suspendedCommitReason(
		        commitRoot.bind(
		          null,
		          root,
		          finishedWork,
		          lanes,
		          recoverableErrors,
		          transitions,
		          didIncludeRenderPhaseUpdate,
		          spawnedLane,
		          updatedLanes,
		          suspendedRetryLanes,
		          exitStatus,
		          1,
		          completedRenderStartTime,
		          completedRenderEndTime
		        )
		      );
		      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
		      return;
		    }
		  commitRoot(
		    root,
		    finishedWork,
		    lanes,
		    recoverableErrors,
		    transitions,
		    didIncludeRenderPhaseUpdate,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes
		  );
		}
		function isRenderConsistentWithExternalStores(finishedWork) {
		  for (var node = finishedWork; ; ) {
		    var tag = node.tag;
		    if (
		      (0 === tag || 11 === tag || 15 === tag) &&
		      node.flags & 16384 &&
		      ((tag = node.updateQueue),
		      null !== tag && ((tag = tag.stores), null !== tag))
		    )
		      for (var i = 0; i < tag.length; i++) {
		        var check = tag[i],
		          getSnapshot = check.getSnapshot;
		        check = check.value;
		        try {
		          if (!objectIs(getSnapshot(), check)) return !1;
		        } catch (error) {
		          return false;
		        }
		      }
		    tag = node.child;
		    if (node.subtreeFlags & 16384 && null !== tag)
		      (tag.return = node), (node = tag);
		    else {
		      if (node === finishedWork) break;
		      for (; null === node.sibling; ) {
		        if (null === node.return || node.return === finishedWork) return true;
		        node = node.return;
		      }
		      node.sibling.return = node.return;
		      node = node.sibling;
		    }
		  }
		  return true;
		}
		function markRootSuspended(
		  root,
		  suspendedLanes,
		  spawnedLane,
		  didAttemptEntireTree
		) {
		  suspendedLanes &= ~workInProgressRootPingedLanes;
		  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		  root.suspendedLanes |= suspendedLanes;
		  root.pingedLanes &= ~suspendedLanes;
		  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
		  didAttemptEntireTree = root.expirationTimes;
		  for (var lanes = suspendedLanes; 0 < lanes; ) {
		    var index$4 = 31 - clz32(lanes),
		      lane = 1 << index$4;
		    didAttemptEntireTree[index$4] = -1;
		    lanes &= ~lane;
		  }
		  0 !== spawnedLane &&
		    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
		}
		function flushSyncWork$1() {
		  return 0 === (executionContext & 6)
		    ? (flushSyncWorkAcrossRoots_impl(0), false)
		    : true;
		}
		function resetWorkInProgressStack() {
		  if (null !== workInProgress) {
		    if (0 === workInProgressSuspendedReason)
		      var interruptedWork = workInProgress.return;
		    else
		      (interruptedWork = workInProgress),
		        (lastContextDependency = currentlyRenderingFiber$1 = null),
		        resetHooksOnUnwind(interruptedWork),
		        (thenableState = null),
		        (thenableIndexCounter = 0),
		        (interruptedWork = workInProgress);
		    for (; null !== interruptedWork; )
		      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
		        (interruptedWork = interruptedWork.return);
		    workInProgress = null;
		  }
		}
		function prepareFreshStack(root, lanes) {
		  var timeoutHandle = root.timeoutHandle;
		  -1 !== timeoutHandle &&
		    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
		  timeoutHandle = root.cancelPendingCommit;
		  null !== timeoutHandle &&
		    ((root.cancelPendingCommit = null), timeoutHandle());
		  resetWorkInProgressStack();
		  workInProgressRoot = root;
		  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
		  workInProgressRootRenderLanes = lanes;
		  workInProgressSuspendedReason = 0;
		  workInProgressThrownValue = null;
		  workInProgressRootDidSkipSuspendedSiblings = false;
		  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		  workInProgressRootDidAttachPingListener = false;
		  workInProgressSuspendedRetryLanes =
		    workInProgressDeferredLane =
		    workInProgressRootPingedLanes =
		    workInProgressRootInterleavedUpdatedLanes =
		    workInProgressRootSkippedLanes =
		    workInProgressRootExitStatus =
		      0;
		  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
		    null;
		  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
		  0 !== (lanes & 8) && (lanes |= lanes & 32);
		  var allEntangledLanes = root.entangledLanes;
		  if (0 !== allEntangledLanes)
		    for (
		      root = root.entanglements, allEntangledLanes &= lanes;
		      0 < allEntangledLanes;

		    ) {
		      var index$2 = 31 - clz32(allEntangledLanes),
		        lane = 1 << index$2;
		      lanes |= root[index$2];
		      allEntangledLanes &= ~lane;
		    }
		  entangledRenderLanes = lanes;
		  finishQueueingConcurrentUpdates();
		  return timeoutHandle;
		}
		function handleThrow(root, thrownValue) {
		  currentlyRenderingFiber = null;
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  thrownValue === SuspenseException || thrownValue === SuspenseActionException
		    ? ((thrownValue = getSuspendedThenable()),
		      (workInProgressSuspendedReason = 3))
		    : thrownValue === SuspenseyCommitException
		      ? ((thrownValue = getSuspendedThenable()),
		        (workInProgressSuspendedReason = 4))
		      : (workInProgressSuspendedReason =
		          thrownValue === SelectiveHydrationException
		            ? 8
		            : null !== thrownValue &&
		                "object" === typeof thrownValue &&
		                "function" === typeof thrownValue.then
		              ? 6
		              : 1);
		  workInProgressThrownValue = thrownValue;
		  null === workInProgress &&
		    ((workInProgressRootExitStatus = 1),
		    logUncaughtError(
		      root,
		      createCapturedValueAtFiber(thrownValue, root.current)
		    ));
		}
		function pushDispatcher() {
		  var prevDispatcher = ReactSharedInternals.H;
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
		}
		function pushAsyncDispatcher() {
		  var prevAsyncDispatcher = ReactSharedInternals.A;
		  ReactSharedInternals.A = DefaultAsyncDispatcher;
		  return prevAsyncDispatcher;
		}
		function renderDidSuspendDelayIfPossible() {
		  workInProgressRootExitStatus = 4;
		  workInProgressRootDidSkipSuspendedSiblings ||
		    ((workInProgressRootRenderLanes & 4194048) !==
		      workInProgressRootRenderLanes &&
		      null !== suspenseHandlerStackCursor.current) ||
		    (workInProgressRootIsPrerendering = true);
		  (0 === (workInProgressRootSkippedLanes & 134217727) &&
		    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
		    null === workInProgressRoot ||
		    markRootSuspended(
		      workInProgressRoot,
		      workInProgressRootRenderLanes,
		      workInProgressDeferredLane,
		      false
		    );
		}
		function renderRootSync(root, lanes, shouldYieldForPrerendering) {
		  var prevExecutionContext = executionContext;
		  executionContext |= 2;
		  var prevDispatcher = pushDispatcher(),
		    prevAsyncDispatcher = pushAsyncDispatcher();
		  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
		    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
		  lanes = false;
		  var exitStatus = workInProgressRootExitStatus;
		  a: do
		    try {
		      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		        var unitOfWork = workInProgress,
		          thrownValue = workInProgressThrownValue;
		        switch (workInProgressSuspendedReason) {
		          case 8:
		            resetWorkInProgressStack();
		            exitStatus = 6;
		            break a;
		          case 3:
		          case 2:
		          case 9:
		          case 6:
		            null === suspenseHandlerStackCursor.current && (lanes = !0);
		            var reason = workInProgressSuspendedReason;
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		            if (
		              shouldYieldForPrerendering &&
		              workInProgressRootIsPrerendering
		            ) {
		              exitStatus = 0;
		              break a;
		            }
		            break;
		          default:
		            (reason = workInProgressSuspendedReason),
		              (workInProgressSuspendedReason = 0),
		              (workInProgressThrownValue = null),
		              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		        }
		      }
		      workLoopSync();
		      exitStatus = workInProgressRootExitStatus;
		      break;
		    } catch (thrownValue$167) {
		      handleThrow(root, thrownValue$167);
		    }
		  while (1);
		  lanes && root.shellSuspendCounter++;
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  executionContext = prevExecutionContext;
		  ReactSharedInternals.H = prevDispatcher;
		  ReactSharedInternals.A = prevAsyncDispatcher;
		  null === workInProgress &&
		    ((workInProgressRoot = null),
		    (workInProgressRootRenderLanes = 0),
		    finishQueueingConcurrentUpdates());
		  return exitStatus;
		}
		function workLoopSync() {
		  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
		}
		function renderRootConcurrent(root, lanes) {
		  var prevExecutionContext = executionContext;
		  executionContext |= 2;
		  var prevDispatcher = pushDispatcher(),
		    prevAsyncDispatcher = pushAsyncDispatcher();
		  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
		    ? ((workInProgressTransitions = null),
		      (workInProgressRootRenderTargetTime = now() + 500),
		      prepareFreshStack(root, lanes))
		    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
		        root,
		        lanes
		      ));
		  a: do
		    try {
		      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		        lanes = workInProgress;
		        var thrownValue = workInProgressThrownValue;
		        b: switch (workInProgressSuspendedReason) {
		          case 1:
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
		            break;
		          case 2:
		          case 9:
		            if (isThenableResolved(thrownValue)) {
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              replaySuspendedUnitOfWork(lanes);
		              break;
		            }
		            lanes = function () {
		              (2 !== workInProgressSuspendedReason &&
		                9 !== workInProgressSuspendedReason) ||
		                workInProgressRoot !== root ||
		                (workInProgressSuspendedReason = 7);
		              ensureRootIsScheduled(root);
		            };
		            thrownValue.then(lanes, lanes);
		            break a;
		          case 3:
		            workInProgressSuspendedReason = 7;
		            break a;
		          case 4:
		            workInProgressSuspendedReason = 5;
		            break a;
		          case 7:
		            isThenableResolved(thrownValue)
		              ? ((workInProgressSuspendedReason = 0),
		                (workInProgressThrownValue = null),
		                replaySuspendedUnitOfWork(lanes))
		              : ((workInProgressSuspendedReason = 0),
		                (workInProgressThrownValue = null),
		                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
		            break;
		          case 5:
		            var resource = null;
		            switch (workInProgress.tag) {
		              case 26:
		                resource = workInProgress.memoizedState;
		              case 5:
		              case 27:
		                var hostFiber = workInProgress;
		                if (resource ? preloadResource(resource) : 1) {
		                  workInProgressSuspendedReason = 0;
		                  workInProgressThrownValue = null;
		                  var sibling = hostFiber.sibling;
		                  if (null !== sibling) workInProgress = sibling;
		                  else {
		                    var returnFiber = hostFiber.return;
		                    null !== returnFiber
		                      ? ((workInProgress = returnFiber),
		                        completeUnitOfWork(returnFiber))
		                      : (workInProgress = null);
		                  }
		                  break b;
		                }
		            }
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
		            break;
		          case 6:
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
		            break;
		          case 8:
		            resetWorkInProgressStack();
		            workInProgressRootExitStatus = 6;
		            break a;
		          default:
		            throw Error(formatProdErrorMessage(462));
		        }
		      }
		      workLoopConcurrentByScheduler();
		      break;
		    } catch (thrownValue$169) {
		      handleThrow(root, thrownValue$169);
		    }
		  while (1);
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  ReactSharedInternals.H = prevDispatcher;
		  ReactSharedInternals.A = prevAsyncDispatcher;
		  executionContext = prevExecutionContext;
		  if (null !== workInProgress) return 0;
		  workInProgressRoot = null;
		  workInProgressRootRenderLanes = 0;
		  finishQueueingConcurrentUpdates();
		  return workInProgressRootExitStatus;
		}
		function workLoopConcurrentByScheduler() {
		  for (; null !== workInProgress && !shouldYield(); )
		    performUnitOfWork(workInProgress);
		}
		function performUnitOfWork(unitOfWork) {
		  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
		  unitOfWork.memoizedProps = unitOfWork.pendingProps;
		  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		}
		function replaySuspendedUnitOfWork(unitOfWork) {
		  var next = unitOfWork;
		  var current = next.alternate;
		  switch (next.tag) {
		    case 15:
		    case 0:
		      next = replayFunctionComponent(
		        current,
		        next,
		        next.pendingProps,
		        next.type,
		        void 0,
		        workInProgressRootRenderLanes
		      );
		      break;
		    case 11:
		      next = replayFunctionComponent(
		        current,
		        next,
		        next.pendingProps,
		        next.type.render,
		        next.ref,
		        workInProgressRootRenderLanes
		      );
		      break;
		    case 5:
		      resetHooksOnUnwind(next);
		    default:
		      unwindInterruptedWork(current, next),
		        (next = workInProgress =
		          resetWorkInProgress(next, entangledRenderLanes)),
		        (next = beginWork(current, next, entangledRenderLanes));
		  }
		  unitOfWork.memoizedProps = unitOfWork.pendingProps;
		  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		}
		function throwAndUnwindWorkLoop(
		  root,
		  unitOfWork,
		  thrownValue,
		  suspendedReason
		) {
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  resetHooksOnUnwind(unitOfWork);
		  thenableState = null;
		  thenableIndexCounter = 0;
		  var returnFiber = unitOfWork.return;
		  try {
		    if (
		      throwException(
		        root,
		        returnFiber,
		        unitOfWork,
		        thrownValue,
		        workInProgressRootRenderLanes
		      )
		    ) {
		      workInProgressRootExitStatus = 1;
		      logUncaughtError(
		        root,
		        createCapturedValueAtFiber(thrownValue, root.current)
		      );
		      workInProgress = null;
		      return;
		    }
		  } catch (error) {
		    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
		    workInProgressRootExitStatus = 1;
		    logUncaughtError(
		      root,
		      createCapturedValueAtFiber(thrownValue, root.current)
		    );
		    workInProgress = null;
		    return;
		  }
		  if (unitOfWork.flags & 32768) {
		    if (isHydrating || 1 === suspendedReason) root = true;
		    else if (
		      workInProgressRootIsPrerendering ||
		      0 !== (workInProgressRootRenderLanes & 536870912)
		    )
		      root = false;
		    else if (
		      ((workInProgressRootDidSkipSuspendedSiblings = root = true),
		      2 === suspendedReason ||
		        9 === suspendedReason ||
		        3 === suspendedReason ||
		        6 === suspendedReason)
		    )
		      (suspendedReason = suspenseHandlerStackCursor.current),
		        null !== suspendedReason &&
		          13 === suspendedReason.tag &&
		          (suspendedReason.flags |= 16384);
		    unwindUnitOfWork(unitOfWork, root);
		  } else completeUnitOfWork(unitOfWork);
		}
		function completeUnitOfWork(unitOfWork) {
		  var completedWork = unitOfWork;
		  do {
		    if (0 !== (completedWork.flags & 32768)) {
		      unwindUnitOfWork(
		        completedWork,
		        workInProgressRootDidSkipSuspendedSiblings
		      );
		      return;
		    }
		    unitOfWork = completedWork.return;
		    var next = completeWork(
		      completedWork.alternate,
		      completedWork,
		      entangledRenderLanes
		    );
		    if (null !== next) {
		      workInProgress = next;
		      return;
		    }
		    completedWork = completedWork.sibling;
		    if (null !== completedWork) {
		      workInProgress = completedWork;
		      return;
		    }
		    workInProgress = completedWork = unitOfWork;
		  } while (null !== completedWork);
		  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
		}
		function unwindUnitOfWork(unitOfWork, skipSiblings) {
		  do {
		    var next = unwindWork(unitOfWork.alternate, unitOfWork);
		    if (null !== next) {
		      next.flags &= 32767;
		      workInProgress = next;
		      return;
		    }
		    next = unitOfWork.return;
		    null !== next &&
		      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
		    if (
		      !skipSiblings &&
		      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
		    ) {
		      workInProgress = unitOfWork;
		      return;
		    }
		    workInProgress = unitOfWork = next;
		  } while (null !== unitOfWork);
		  workInProgressRootExitStatus = 6;
		  workInProgress = null;
		}
		function commitRoot(
		  root,
		  finishedWork,
		  lanes,
		  recoverableErrors,
		  transitions,
		  didIncludeRenderPhaseUpdate,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes
		) {
		  root.cancelPendingCommit = null;
		  do flushPendingEffects();
		  while (0 !== pendingEffectsStatus);
		  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		  if (null !== finishedWork) {
		    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
		    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
		    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
		    markRootFinished(
		      root,
		      lanes,
		      didIncludeRenderPhaseUpdate,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes
		    );
		    root === workInProgressRoot &&
		      ((workInProgress = workInProgressRoot = null),
		      (workInProgressRootRenderLanes = 0));
		    pendingFinishedWork = finishedWork;
		    pendingEffectsRoot = root;
		    pendingEffectsLanes = lanes;
		    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
		    pendingPassiveTransitions = transitions;
		    pendingRecoverableErrors = recoverableErrors;
		    0 !== (finishedWork.subtreeFlags & 10256) ||
		    0 !== (finishedWork.flags & 10256)
		      ? ((root.callbackNode = null),
		        (root.callbackPriority = 0),
		        scheduleCallback$1(NormalPriority$1, function () {
		          flushPassiveEffects();
		          return null;
		        }))
		      : ((root.callbackNode = null), (root.callbackPriority = 0));
		    recoverableErrors = 0 !== (finishedWork.flags & 13878);
		    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
		      recoverableErrors = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      transitions = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      spawnedLane = executionContext;
		      executionContext |= 4;
		      try {
		        commitBeforeMutationEffects(root, finishedWork, lanes);
		      } finally {
		        (executionContext = spawnedLane),
		          (ReactDOMSharedInternals.p = transitions),
		          (ReactSharedInternals.T = recoverableErrors);
		      }
		    }
		    pendingEffectsStatus = 1;
		    flushMutationEffects();
		    flushLayoutEffects();
		    flushSpawnedWork();
		  }
		}
		function flushMutationEffects() {
		  if (1 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
		    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
		      rootMutationHasEffect = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      var previousPriority = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      var prevExecutionContext = executionContext;
		      executionContext |= 4;
		      try {
		        commitMutationEffectsOnFiber(finishedWork, root);
		        var priorSelectionInformation = selectionInformation,
		          curFocusedElem = getActiveElementDeep(root.containerInfo),
		          priorFocusedElem = priorSelectionInformation.focusedElem,
		          priorSelectionRange = priorSelectionInformation.selectionRange;
		        if (
		          curFocusedElem !== priorFocusedElem &&
		          priorFocusedElem &&
		          priorFocusedElem.ownerDocument &&
		          containsNode(
		            priorFocusedElem.ownerDocument.documentElement,
		            priorFocusedElem
		          )
		        ) {
		          if (
		            null !== priorSelectionRange &&
		            hasSelectionCapabilities(priorFocusedElem)
		          ) {
		            var start = priorSelectionRange.start,
		              end = priorSelectionRange.end;
		            void 0 === end && (end = start);
		            if ("selectionStart" in priorFocusedElem)
		              (priorFocusedElem.selectionStart = start),
		                (priorFocusedElem.selectionEnd = Math.min(
		                  end,
		                  priorFocusedElem.value.length
		                ));
		            else {
		              var doc = priorFocusedElem.ownerDocument || document,
		                win = (doc && doc.defaultView) || window;
		              if (win.getSelection) {
		                var selection = win.getSelection(),
		                  length = priorFocusedElem.textContent.length,
		                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
		                  end$jscomp$0 =
		                    void 0 === priorSelectionRange.end
		                      ? start$jscomp$0
		                      : Math.min(priorSelectionRange.end, length);
		                !selection.extend &&
		                  start$jscomp$0 > end$jscomp$0 &&
		                  ((curFocusedElem = end$jscomp$0),
		                  (end$jscomp$0 = start$jscomp$0),
		                  (start$jscomp$0 = curFocusedElem));
		                var startMarker = getNodeForCharacterOffset(
		                    priorFocusedElem,
		                    start$jscomp$0
		                  ),
		                  endMarker = getNodeForCharacterOffset(
		                    priorFocusedElem,
		                    end$jscomp$0
		                  );
		                if (
		                  startMarker &&
		                  endMarker &&
		                  (1 !== selection.rangeCount ||
		                    selection.anchorNode !== startMarker.node ||
		                    selection.anchorOffset !== startMarker.offset ||
		                    selection.focusNode !== endMarker.node ||
		                    selection.focusOffset !== endMarker.offset)
		                ) {
		                  var range = doc.createRange();
		                  range.setStart(startMarker.node, startMarker.offset);
		                  selection.removeAllRanges();
		                  start$jscomp$0 > end$jscomp$0
		                    ? (selection.addRange(range),
		                      selection.extend(endMarker.node, endMarker.offset))
		                    : (range.setEnd(endMarker.node, endMarker.offset),
		                      selection.addRange(range));
		                }
		              }
		            }
		          }
		          doc = [];
		          for (
		            selection = priorFocusedElem;
		            (selection = selection.parentNode);

		          )
		            1 === selection.nodeType &&
		              doc.push({
		                element: selection,
		                left: selection.scrollLeft,
		                top: selection.scrollTop
		              });
		          "function" === typeof priorFocusedElem.focus &&
		            priorFocusedElem.focus();
		          for (
		            priorFocusedElem = 0;
		            priorFocusedElem < doc.length;
		            priorFocusedElem++
		          ) {
		            var info = doc[priorFocusedElem];
		            info.element.scrollLeft = info.left;
		            info.element.scrollTop = info.top;
		          }
		        }
		        _enabled = !!eventsEnabled;
		        selectionInformation = eventsEnabled = null;
		      } finally {
		        (executionContext = prevExecutionContext),
		          (ReactDOMSharedInternals.p = previousPriority),
		          (ReactSharedInternals.T = rootMutationHasEffect);
		      }
		    }
		    root.current = finishedWork;
		    pendingEffectsStatus = 2;
		  }
		}
		function flushLayoutEffects() {
		  if (2 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
		    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
		      rootHasLayoutEffect = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      var previousPriority = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      var prevExecutionContext = executionContext;
		      executionContext |= 4;
		      try {
		        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
		      } finally {
		        (executionContext = prevExecutionContext),
		          (ReactDOMSharedInternals.p = previousPriority),
		          (ReactSharedInternals.T = rootHasLayoutEffect);
		      }
		    }
		    pendingEffectsStatus = 3;
		  }
		}
		function flushSpawnedWork() {
		  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    requestPaint();
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      lanes = pendingEffectsLanes,
		      recoverableErrors = pendingRecoverableErrors;
		    0 !== (finishedWork.subtreeFlags & 10256) ||
		    0 !== (finishedWork.flags & 10256)
		      ? (pendingEffectsStatus = 5)
		      : ((pendingEffectsStatus = 0),
		        (pendingFinishedWork = pendingEffectsRoot = null),
		        releaseRootPooledCache(root, root.pendingLanes));
		    var remainingLanes = root.pendingLanes;
		    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
		    lanesToEventPriority(lanes);
		    finishedWork = finishedWork.stateNode;
		    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
		      try {
		        injectedHook.onCommitFiberRoot(
		          rendererID,
		          finishedWork,
		          void 0,
		          128 === (finishedWork.current.flags & 128)
		        );
		      } catch (err) {}
		    if (null !== recoverableErrors) {
		      finishedWork = ReactSharedInternals.T;
		      remainingLanes = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      ReactSharedInternals.T = null;
		      try {
		        for (
		          var onRecoverableError = root.onRecoverableError, i = 0;
		          i < recoverableErrors.length;
		          i++
		        ) {
		          var recoverableError = recoverableErrors[i];
		          onRecoverableError(recoverableError.value, {
		            componentStack: recoverableError.stack
		          });
		        }
		      } finally {
		        (ReactSharedInternals.T = finishedWork),
		          (ReactDOMSharedInternals.p = remainingLanes);
		      }
		    }
		    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
		    ensureRootIsScheduled(root);
		    remainingLanes = root.pendingLanes;
		    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)
		      ? root === rootWithNestedUpdates
		        ? nestedUpdateCount++
		        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
		      : (nestedUpdateCount = 0);
		    flushSyncWorkAcrossRoots_impl(0);
		  }
		}
		function releaseRootPooledCache(root, remainingLanes) {
		  0 === (root.pooledCacheLanes &= remainingLanes) &&
		    ((remainingLanes = root.pooledCache),
		    null != remainingLanes &&
		      ((root.pooledCache = null), releaseCache(remainingLanes)));
		}
		function flushPendingEffects(wasDelayedCommit) {
		  flushMutationEffects();
		  flushLayoutEffects();
		  flushSpawnedWork();
		  return flushPassiveEffects();
		}
		function flushPassiveEffects() {
		  if (5 !== pendingEffectsStatus) return false;
		  var root = pendingEffectsRoot,
		    remainingLanes = pendingEffectsRemainingLanes;
		  pendingEffectsRemainingLanes = 0;
		  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
		    prevTransition = ReactSharedInternals.T,
		    previousPriority = ReactDOMSharedInternals.p;
		  try {
		    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
		    ReactSharedInternals.T = null;
		    renderPriority = pendingPassiveTransitions;
		    pendingPassiveTransitions = null;
		    var root$jscomp$0 = pendingEffectsRoot,
		      lanes = pendingEffectsLanes;
		    pendingEffectsStatus = 0;
		    pendingFinishedWork = pendingEffectsRoot = null;
		    pendingEffectsLanes = 0;
		    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
		    var prevExecutionContext = executionContext;
		    executionContext |= 4;
		    commitPassiveUnmountOnFiber(root$jscomp$0.current);
		    commitPassiveMountOnFiber(
		      root$jscomp$0,
		      root$jscomp$0.current,
		      lanes,
		      renderPriority
		    );
		    executionContext = prevExecutionContext;
		    flushSyncWorkAcrossRoots_impl(0, !1);
		    if (
		      injectedHook &&
		      "function" === typeof injectedHook.onPostCommitFiberRoot
		    )
		      try {
		        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
		      } catch (err) {}
		    return !0;
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition),
		      releaseRootPooledCache(root, remainingLanes);
		  }
		}
		function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		  null !== rootFiber &&
		    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
		}
		function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
		  if (3 === sourceFiber.tag)
		    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		  else
		    for (; null !== nearestMountedAncestor; ) {
		      if (3 === nearestMountedAncestor.tag) {
		        captureCommitPhaseErrorOnRoot(
		          nearestMountedAncestor,
		          sourceFiber,
		          error
		        );
		        break;
		      } else if (1 === nearestMountedAncestor.tag) {
		        var instance = nearestMountedAncestor.stateNode;
		        if (
		          "function" ===
		            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
		          ("function" === typeof instance.componentDidCatch &&
		            (null === legacyErrorBoundariesThatAlreadyFailed ||
		              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
		        ) {
		          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		          error = createClassErrorUpdate(2);
		          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
		          null !== instance &&
		            (initializeClassErrorUpdate(
		              error,
		              instance,
		              nearestMountedAncestor,
		              sourceFiber
		            ),
		            markRootUpdated$1(instance, 2),
		            ensureRootIsScheduled(instance));
		          break;
		        }
		      }
		      nearestMountedAncestor = nearestMountedAncestor.return;
		    }
		}
		function attachPingListener(root, wakeable, lanes) {
		  var pingCache = root.pingCache;
		  if (null === pingCache) {
		    pingCache = root.pingCache = new PossiblyWeakMap();
		    var threadIDs = new Set();
		    pingCache.set(wakeable, threadIDs);
		  } else
		    (threadIDs = pingCache.get(wakeable)),
		      void 0 === threadIDs &&
		        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
		  threadIDs.has(lanes) ||
		    ((workInProgressRootDidAttachPingListener = true),
		    threadIDs.add(lanes),
		    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
		    wakeable.then(root, root));
		}
		function pingSuspendedRoot(root, wakeable, pingedLanes) {
		  var pingCache = root.pingCache;
		  null !== pingCache && pingCache.delete(wakeable);
		  root.pingedLanes |= root.suspendedLanes & pingedLanes;
		  root.warmLanes &= ~pingedLanes;
		  workInProgressRoot === root &&
		    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
		    (4 === workInProgressRootExitStatus ||
		    (3 === workInProgressRootExitStatus &&
		      (workInProgressRootRenderLanes & 62914560) ===
		        workInProgressRootRenderLanes &&
		      300 > now() - globalMostRecentFallbackTime)
		      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
		      : (workInProgressRootPingedLanes |= pingedLanes),
		    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
		      (workInProgressSuspendedRetryLanes = 0));
		  ensureRootIsScheduled(root);
		}
		function retryTimedOutBoundary(boundaryFiber, retryLane) {
		  0 === retryLane && (retryLane = claimNextRetryLane());
		  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		  null !== boundaryFiber &&
		    (markRootUpdated$1(boundaryFiber, retryLane),
		    ensureRootIsScheduled(boundaryFiber));
		}
		function retryDehydratedSuspenseBoundary(boundaryFiber) {
		  var suspenseState = boundaryFiber.memoizedState,
		    retryLane = 0;
		  null !== suspenseState && (retryLane = suspenseState.retryLane);
		  retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function resolveRetryWakeable(boundaryFiber, wakeable) {
		  var retryLane = 0;
		  switch (boundaryFiber.tag) {
		    case 13:
		      var retryCache = boundaryFiber.stateNode;
		      var suspenseState = boundaryFiber.memoizedState;
		      null !== suspenseState && (retryLane = suspenseState.retryLane);
		      break;
		    case 19:
		      retryCache = boundaryFiber.stateNode;
		      break;
		    case 22:
		      retryCache = boundaryFiber.stateNode._retryCache;
		      break;
		    default:
		      throw Error(formatProdErrorMessage(314));
		  }
		  null !== retryCache && retryCache.delete(wakeable);
		  retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function scheduleCallback$1(priorityLevel, callback) {
		  return scheduleCallback$3(priorityLevel, callback);
		}
		var firstScheduledRoot = null,
		  lastScheduledRoot = null,
		  didScheduleMicrotask = false,
		  mightHavePendingSyncWork = false,
		  isFlushingWork = false,
		  currentEventTransitionLane = 0;
		function ensureRootIsScheduled(root) {
		  root !== lastScheduledRoot &&
		    null === root.next &&
		    (null === lastScheduledRoot
		      ? (firstScheduledRoot = lastScheduledRoot = root)
		      : (lastScheduledRoot = lastScheduledRoot.next = root));
		  mightHavePendingSyncWork = true;
		  didScheduleMicrotask ||
		    ((didScheduleMicrotask = true), scheduleImmediateRootScheduleTask());
		}
		function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
		  if (!isFlushingWork && mightHavePendingSyncWork) {
		    isFlushingWork = true;
		    do {
		      var didPerformSomeWork = false;
		      for (var root$174 = firstScheduledRoot; null !== root$174; ) {
		        if (0 !== syncTransitionLanes) {
		            var pendingLanes = root$174.pendingLanes;
		            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
		            else {
		              var suspendedLanes = root$174.suspendedLanes,
		                pingedLanes = root$174.pingedLanes;
		              JSCompiler_inline_result =
		                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
		              JSCompiler_inline_result &=
		                pendingLanes & ~(suspendedLanes & ~pingedLanes);
		              JSCompiler_inline_result =
		                JSCompiler_inline_result & 201326741
		                  ? (JSCompiler_inline_result & 201326741) | 1
		                  : JSCompiler_inline_result
		                    ? JSCompiler_inline_result | 2
		                    : 0;
		            }
		            0 !== JSCompiler_inline_result &&
		              ((didPerformSomeWork = true),
		              performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
		          } else
		            (JSCompiler_inline_result = workInProgressRootRenderLanes),
		              (JSCompiler_inline_result = getNextLanes(
		                root$174,
		                root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
		                null !== root$174.cancelPendingCommit ||
		                  -1 !== root$174.timeoutHandle
		              )),
		              0 === (JSCompiler_inline_result & 3) ||
		                checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) ||
		                ((didPerformSomeWork = true),
		                performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
		        root$174 = root$174.next;
		      }
		    } while (didPerformSomeWork);
		    isFlushingWork = false;
		  }
		}
		function processRootScheduleInImmediateTask() {
		  processRootScheduleInMicrotask();
		}
		function processRootScheduleInMicrotask() {
		  mightHavePendingSyncWork = didScheduleMicrotask = false;
		  var syncTransitionLanes = 0;
		  0 !== currentEventTransitionLane &&
		    (shouldAttemptEagerTransition() &&
		      (syncTransitionLanes = currentEventTransitionLane),
		    (currentEventTransitionLane = 0));
		  for (
		    var currentTime = now(), prev = null, root = firstScheduledRoot;
		    null !== root;

		  ) {
		    var next = root.next,
		      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
		    if (0 === nextLanes)
		      (root.next = null),
		        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
		        null === next && (lastScheduledRoot = prev);
		    else if (
		      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
		    )
		      mightHavePendingSyncWork = true;
		    root = next;
		  }
		  flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
		}
		function scheduleTaskForRootDuringMicrotask(root, currentTime) {
		  for (
		    var suspendedLanes = root.suspendedLanes,
		      pingedLanes = root.pingedLanes,
		      expirationTimes = root.expirationTimes,
		      lanes = root.pendingLanes & -62914561;
		    0 < lanes;

		  ) {
		    var index$3 = 31 - clz32(lanes),
		      lane = 1 << index$3,
		      expirationTime = expirationTimes[index$3];
		    if (-1 === expirationTime) {
		      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
		        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
		    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
		    lanes &= ~lane;
		  }
		  currentTime = workInProgressRoot;
		  suspendedLanes = workInProgressRootRenderLanes;
		  suspendedLanes = getNextLanes(
		    root,
		    root === currentTime ? suspendedLanes : 0,
		    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
		  );
		  pingedLanes = root.callbackNode;
		  if (
		    0 === suspendedLanes ||
		    (root === currentTime &&
		      (2 === workInProgressSuspendedReason ||
		        9 === workInProgressSuspendedReason)) ||
		    null !== root.cancelPendingCommit
		  )
		    return (
		      null !== pingedLanes &&
		        null !== pingedLanes &&
		        cancelCallback$1(pingedLanes),
		      (root.callbackNode = null),
		      (root.callbackPriority = 0)
		    );
		  if (
		    0 === (suspendedLanes & 3) ||
		    checkIfRootIsPrerendering(root, suspendedLanes)
		  ) {
		    currentTime = suspendedLanes & -suspendedLanes;
		    if (currentTime === root.callbackPriority) return currentTime;
		    null !== pingedLanes && cancelCallback$1(pingedLanes);
		    switch (lanesToEventPriority(suspendedLanes)) {
		      case 2:
		      case 8:
		        suspendedLanes = UserBlockingPriority;
		        break;
		      case 32:
		        suspendedLanes = NormalPriority$1;
		        break;
		      case 268435456:
		        suspendedLanes = IdlePriority;
		        break;
		      default:
		        suspendedLanes = NormalPriority$1;
		    }
		    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
		    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
		    root.callbackPriority = currentTime;
		    root.callbackNode = suspendedLanes;
		    return currentTime;
		  }
		  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
		  root.callbackPriority = 2;
		  root.callbackNode = null;
		  return 2;
		}
		function performWorkOnRootViaSchedulerTask(root, didTimeout) {
		  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
		    return (root.callbackNode = null), (root.callbackPriority = 0), null;
		  var originalCallbackNode = root.callbackNode;
		  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
		    return null;
		  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
		  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
		    root,
		    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
		    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
		  );
		  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
		  scheduleTaskForRootDuringMicrotask(root, now());
		  return null != root.callbackNode && root.callbackNode === originalCallbackNode
		    ? performWorkOnRootViaSchedulerTask.bind(null, root)
		    : null;
		}
		function performSyncWorkOnRoot(root, lanes) {
		  if (flushPendingEffects()) return null;
		  performWorkOnRoot(root, lanes, true);
		}
		function scheduleImmediateRootScheduleTask() {
		  scheduleMicrotask(function () {
		    0 !== (executionContext & 6)
		      ? scheduleCallback$3(
		          ImmediatePriority,
		          processRootScheduleInImmediateTask
		        )
		      : processRootScheduleInMicrotask();
		  });
		}
		function requestTransitionLane() {
		  0 === currentEventTransitionLane &&
		    (currentEventTransitionLane = claimNextTransitionLane());
		  return currentEventTransitionLane;
		}
		function coerceFormActionProp(actionProp) {
		  return null == actionProp ||
		    "symbol" === typeof actionProp ||
		    "boolean" === typeof actionProp
		    ? null
		    : "function" === typeof actionProp
		      ? actionProp
		      : sanitizeURL("" + actionProp);
		}
		function createFormDataWithSubmitter(form, submitter) {
		  var temp = submitter.ownerDocument.createElement("input");
		  temp.name = submitter.name;
		  temp.value = submitter.value;
		  form.id && temp.setAttribute("form", form.id);
		  submitter.parentNode.insertBefore(temp, submitter);
		  form = new FormData(form);
		  temp.parentNode.removeChild(temp);
		  return form;
		}
		function extractEvents$1(
		  dispatchQueue,
		  domEventName,
		  maybeTargetInst,
		  nativeEvent,
		  nativeEventTarget
		) {
		  if (
		    "submit" === domEventName &&
		    maybeTargetInst &&
		    maybeTargetInst.stateNode === nativeEventTarget
		  ) {
		    var action = coerceFormActionProp(
		        (nativeEventTarget[internalPropsKey] || null).action
		      ),
		      submitter = nativeEvent.submitter;
		    submitter &&
		      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
		        ? coerceFormActionProp(domEventName.formAction)
		        : submitter.getAttribute("formAction")),
		      null !== domEventName && ((action = domEventName), (submitter = null)));
		    var event = new SyntheticEvent(
		      "action",
		      "action",
		      null,
		      nativeEvent,
		      nativeEventTarget
		    );
		    dispatchQueue.push({
		      event: event,
		      listeners: [
		        {
		          instance: null,
		          listener: function () {
		            if (nativeEvent.defaultPrevented) {
		              if (0 !== currentEventTransitionLane) {
		                var formData = submitter
		                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
		                  : new FormData(nativeEventTarget);
		                startHostTransition(
		                  maybeTargetInst,
		                  {
		                    pending: true,
		                    data: formData,
		                    method: nativeEventTarget.method,
		                    action: action
		                  },
		                  null,
		                  formData
		                );
		              }
		            } else
		              "function" === typeof action &&
		                (event.preventDefault(),
		                (formData = submitter
		                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
		                  : new FormData(nativeEventTarget)),
		                startHostTransition(
		                  maybeTargetInst,
		                  {
		                    pending: true,
		                    data: formData,
		                    method: nativeEventTarget.method,
		                    action: action
		                  },
		                  action,
		                  formData
		                ));
		          },
		          currentTarget: nativeEventTarget
		        }
		      ]
		    });
		  }
		}
		for (
		  var i$jscomp$inline_1528 = 0;
		  i$jscomp$inline_1528 < simpleEventPluginEvents.length;
		  i$jscomp$inline_1528++
		) {
		  var eventName$jscomp$inline_1529 =
		      simpleEventPluginEvents[i$jscomp$inline_1528],
		    domEventName$jscomp$inline_1530 =
		      eventName$jscomp$inline_1529.toLowerCase(),
		    capitalizedEvent$jscomp$inline_1531 =
		      eventName$jscomp$inline_1529[0].toUpperCase() +
		      eventName$jscomp$inline_1529.slice(1);
		  registerSimpleEvent(
		    domEventName$jscomp$inline_1530,
		    "on" + capitalizedEvent$jscomp$inline_1531
		  );
		}
		registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
		registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
		registerSimpleEvent(ANIMATION_START, "onAnimationStart");
		registerSimpleEvent("dblclick", "onDoubleClick");
		registerSimpleEvent("focusin", "onFocus");
		registerSimpleEvent("focusout", "onBlur");
		registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
		registerSimpleEvent(TRANSITION_START, "onTransitionStart");
		registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
		registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
		registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
		registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
		registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
		registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
		registerTwoPhaseEvent(
		  "onChange",
		  "change click focusin focusout input keydown keyup selectionchange".split(" ")
		);
		registerTwoPhaseEvent(
		  "onSelect",
		  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
		    " "
		  )
		);
		registerTwoPhaseEvent("onBeforeInput", [
		  "compositionend",
		  "keypress",
		  "textInput",
		  "paste"
		]);
		registerTwoPhaseEvent(
		  "onCompositionEnd",
		  "compositionend focusout keydown keypress keyup mousedown".split(" ")
		);
		registerTwoPhaseEvent(
		  "onCompositionStart",
		  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
		);
		registerTwoPhaseEvent(
		  "onCompositionUpdate",
		  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
		);
		var mediaEventTypes =
		    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
		      " "
		    ),
		  nonDelegatedEvents = new Set(
		    "beforetoggle cancel close invalid load scroll scrollend toggle"
		      .split(" ")
		      .concat(mediaEventTypes)
		  );
		function processDispatchQueue(dispatchQueue, eventSystemFlags) {
		  eventSystemFlags = 0 !== (eventSystemFlags & 4);
		  for (var i = 0; i < dispatchQueue.length; i++) {
		    var _dispatchQueue$i = dispatchQueue[i],
		      event = _dispatchQueue$i.event;
		    _dispatchQueue$i = _dispatchQueue$i.listeners;
		    a: {
		      var previousInstance = void 0;
		      if (eventSystemFlags)
		        for (
		          var i$jscomp$0 = _dispatchQueue$i.length - 1;
		          0 <= i$jscomp$0;
		          i$jscomp$0--
		        ) {
		          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
		            instance = _dispatchListeners$i.instance,
		            currentTarget = _dispatchListeners$i.currentTarget;
		          _dispatchListeners$i = _dispatchListeners$i.listener;
		          if (instance !== previousInstance && event.isPropagationStopped())
		            break a;
		          previousInstance = _dispatchListeners$i;
		          event.currentTarget = currentTarget;
		          try {
		            previousInstance(event);
		          } catch (error) {
		            reportGlobalError(error);
		          }
		          event.currentTarget = null;
		          previousInstance = instance;
		        }
		      else
		        for (
		          i$jscomp$0 = 0;
		          i$jscomp$0 < _dispatchQueue$i.length;
		          i$jscomp$0++
		        ) {
		          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
		          instance = _dispatchListeners$i.instance;
		          currentTarget = _dispatchListeners$i.currentTarget;
		          _dispatchListeners$i = _dispatchListeners$i.listener;
		          if (instance !== previousInstance && event.isPropagationStopped())
		            break a;
		          previousInstance = _dispatchListeners$i;
		          event.currentTarget = currentTarget;
		          try {
		            previousInstance(event);
		          } catch (error) {
		            reportGlobalError(error);
		          }
		          event.currentTarget = null;
		          previousInstance = instance;
		        }
		    }
		  }
		}
		function listenToNonDelegatedEvent(domEventName, targetElement) {
		  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
		  void 0 === JSCompiler_inline_result &&
		    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
		      new Set());
		  var listenerSetKey = domEventName + "__bubble";
		  JSCompiler_inline_result.has(listenerSetKey) ||
		    (addTrappedEventListener(targetElement, domEventName, 2, false),
		    JSCompiler_inline_result.add(listenerSetKey));
		}
		function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
		  var eventSystemFlags = 0;
		  isCapturePhaseListener && (eventSystemFlags |= 4);
		  addTrappedEventListener(
		    target,
		    domEventName,
		    eventSystemFlags,
		    isCapturePhaseListener
		  );
		}
		var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
		function listenToAllSupportedEvents(rootContainerElement) {
		  if (!rootContainerElement[listeningMarker]) {
		    rootContainerElement[listeningMarker] = true;
		    allNativeEvents.forEach(function (domEventName) {
		      "selectionchange" !== domEventName &&
		        (nonDelegatedEvents.has(domEventName) ||
		          listenToNativeEvent(domEventName, false, rootContainerElement),
		        listenToNativeEvent(domEventName, true, rootContainerElement));
		    });
		    var ownerDocument =
		      9 === rootContainerElement.nodeType
		        ? rootContainerElement
		        : rootContainerElement.ownerDocument;
		    null === ownerDocument ||
		      ownerDocument[listeningMarker] ||
		      ((ownerDocument[listeningMarker] = true),
		      listenToNativeEvent("selectionchange", false, ownerDocument));
		  }
		}
		function addTrappedEventListener(
		  targetContainer,
		  domEventName,
		  eventSystemFlags,
		  isCapturePhaseListener
		) {
		  switch (getEventPriority(domEventName)) {
		    case 2:
		      var listenerWrapper = dispatchDiscreteEvent;
		      break;
		    case 8:
		      listenerWrapper = dispatchContinuousEvent;
		      break;
		    default:
		      listenerWrapper = dispatchEvent;
		  }
		  eventSystemFlags = listenerWrapper.bind(
		    null,
		    domEventName,
		    eventSystemFlags,
		    targetContainer
		  );
		  listenerWrapper = void 0;
		  !passiveBrowserEventsSupported ||
		    ("touchstart" !== domEventName &&
		      "touchmove" !== domEventName &&
		      "wheel" !== domEventName) ||
		    (listenerWrapper = true);
		  isCapturePhaseListener
		    ? void 0 !== listenerWrapper
		      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
		          capture: true,
		          passive: listenerWrapper
		        })
		      : targetContainer.addEventListener(domEventName, eventSystemFlags, true)
		    : void 0 !== listenerWrapper
		      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
		          passive: listenerWrapper
		        })
		      : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
		}
		function dispatchEventForPluginEventSystem(
		  domEventName,
		  eventSystemFlags,
		  nativeEvent,
		  targetInst$jscomp$0,
		  targetContainer
		) {
		  var ancestorInst = targetInst$jscomp$0;
		  if (
		    0 === (eventSystemFlags & 1) &&
		    0 === (eventSystemFlags & 2) &&
		    null !== targetInst$jscomp$0
		  )
		    a: for (;;) {
		      if (null === targetInst$jscomp$0) return;
		      var nodeTag = targetInst$jscomp$0.tag;
		      if (3 === nodeTag || 4 === nodeTag) {
		        var container = targetInst$jscomp$0.stateNode.containerInfo;
		        if (container === targetContainer) break;
		        if (4 === nodeTag)
		          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
		            var grandTag = nodeTag.tag;
		            if (
		              (3 === grandTag || 4 === grandTag) &&
		              nodeTag.stateNode.containerInfo === targetContainer
		            )
		              return;
		            nodeTag = nodeTag.return;
		          }
		        for (; null !== container; ) {
		          nodeTag = getClosestInstanceFromNode(container);
		          if (null === nodeTag) return;
		          grandTag = nodeTag.tag;
		          if (
		            5 === grandTag ||
		            6 === grandTag ||
		            26 === grandTag ||
		            27 === grandTag
		          ) {
		            targetInst$jscomp$0 = ancestorInst = nodeTag;
		            continue a;
		          }
		          container = container.parentNode;
		        }
		      }
		      targetInst$jscomp$0 = targetInst$jscomp$0.return;
		    }
		  batchedUpdates$1(function () {
		    var targetInst = ancestorInst,
		      nativeEventTarget = getEventTarget(nativeEvent),
		      dispatchQueue = [];
		    a: {
		      var reactName = topLevelEventsToReactNames.get(domEventName);
		      if (void 0 !== reactName) {
		        var SyntheticEventCtor = SyntheticEvent,
		          reactEventType = domEventName;
		        switch (domEventName) {
		          case "keypress":
		            if (0 === getEventCharCode(nativeEvent)) break a;
		          case "keydown":
		          case "keyup":
		            SyntheticEventCtor = SyntheticKeyboardEvent;
		            break;
		          case "focusin":
		            reactEventType = "focus";
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "focusout":
		            reactEventType = "blur";
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "beforeblur":
		          case "afterblur":
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "click":
		            if (2 === nativeEvent.button) break a;
		          case "auxclick":
		          case "dblclick":
		          case "mousedown":
		          case "mousemove":
		          case "mouseup":
		          case "mouseout":
		          case "mouseover":
		          case "contextmenu":
		            SyntheticEventCtor = SyntheticMouseEvent;
		            break;
		          case "drag":
		          case "dragend":
		          case "dragenter":
		          case "dragexit":
		          case "dragleave":
		          case "dragover":
		          case "dragstart":
		          case "drop":
		            SyntheticEventCtor = SyntheticDragEvent;
		            break;
		          case "touchcancel":
		          case "touchend":
		          case "touchmove":
		          case "touchstart":
		            SyntheticEventCtor = SyntheticTouchEvent;
		            break;
		          case ANIMATION_END:
		          case ANIMATION_ITERATION:
		          case ANIMATION_START:
		            SyntheticEventCtor = SyntheticAnimationEvent;
		            break;
		          case TRANSITION_END:
		            SyntheticEventCtor = SyntheticTransitionEvent;
		            break;
		          case "scroll":
		          case "scrollend":
		            SyntheticEventCtor = SyntheticUIEvent;
		            break;
		          case "wheel":
		            SyntheticEventCtor = SyntheticWheelEvent;
		            break;
		          case "copy":
		          case "cut":
		          case "paste":
		            SyntheticEventCtor = SyntheticClipboardEvent;
		            break;
		          case "gotpointercapture":
		          case "lostpointercapture":
		          case "pointercancel":
		          case "pointerdown":
		          case "pointermove":
		          case "pointerout":
		          case "pointerover":
		          case "pointerup":
		            SyntheticEventCtor = SyntheticPointerEvent;
		            break;
		          case "toggle":
		          case "beforetoggle":
		            SyntheticEventCtor = SyntheticToggleEvent;
		        }
		        var inCapturePhase = 0 !== (eventSystemFlags & 4),
		          accumulateTargetOnly =
		            !inCapturePhase &&
		            ("scroll" === domEventName || "scrollend" === domEventName),
		          reactEventName = inCapturePhase
		            ? null !== reactName
		              ? reactName + "Capture"
		              : null
		            : reactName;
		        inCapturePhase = [];
		        for (
		          var instance = targetInst, lastHostComponent;
		          null !== instance;

		        ) {
		          var _instance = instance;
		          lastHostComponent = _instance.stateNode;
		          _instance = _instance.tag;
		          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
		            null === lastHostComponent ||
		            null === reactEventName ||
		            ((_instance = getListener(instance, reactEventName)),
		            null != _instance &&
		              inCapturePhase.push(
		                createDispatchListener(instance, _instance, lastHostComponent)
		              ));
		          if (accumulateTargetOnly) break;
		          instance = instance.return;
		        }
		        0 < inCapturePhase.length &&
		          ((reactName = new SyntheticEventCtor(
		            reactName,
		            reactEventType,
		            null,
		            nativeEvent,
		            nativeEventTarget
		          )),
		          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
		      }
		    }
		    if (0 === (eventSystemFlags & 7)) {
		      a: {
		        reactName =
		          "mouseover" === domEventName || "pointerover" === domEventName;
		        SyntheticEventCtor =
		          "mouseout" === domEventName || "pointerout" === domEventName;
		        if (
		          reactName &&
		          nativeEvent !== currentReplayingEvent &&
		          (reactEventType =
		            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
		          (getClosestInstanceFromNode(reactEventType) ||
		            reactEventType[internalContainerInstanceKey])
		        )
		          break a;
		        if (SyntheticEventCtor || reactName) {
		          reactName =
		            nativeEventTarget.window === nativeEventTarget
		              ? nativeEventTarget
		              : (reactName = nativeEventTarget.ownerDocument)
		                ? reactName.defaultView || reactName.parentWindow
		                : window;
		          if (SyntheticEventCtor) {
		            if (
		              ((reactEventType =
		                nativeEvent.relatedTarget || nativeEvent.toElement),
		              (SyntheticEventCtor = targetInst),
		              (reactEventType = reactEventType
		                ? getClosestInstanceFromNode(reactEventType)
		                : null),
		              null !== reactEventType &&
		                ((accumulateTargetOnly =
		                  getNearestMountedFiber(reactEventType)),
		                (inCapturePhase = reactEventType.tag),
		                reactEventType !== accumulateTargetOnly ||
		                  (5 !== inCapturePhase &&
		                    27 !== inCapturePhase &&
		                    6 !== inCapturePhase)))
		            )
		              reactEventType = null;
		          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
		          if (SyntheticEventCtor !== reactEventType) {
		            inCapturePhase = SyntheticMouseEvent;
		            _instance = "onMouseLeave";
		            reactEventName = "onMouseEnter";
		            instance = "mouse";
		            if ("pointerout" === domEventName || "pointerover" === domEventName)
		              (inCapturePhase = SyntheticPointerEvent),
		                (_instance = "onPointerLeave"),
		                (reactEventName = "onPointerEnter"),
		                (instance = "pointer");
		            accumulateTargetOnly =
		              null == SyntheticEventCtor
		                ? reactName
		                : getNodeFromInstance(SyntheticEventCtor);
		            lastHostComponent =
		              null == reactEventType
		                ? reactName
		                : getNodeFromInstance(reactEventType);
		            reactName = new inCapturePhase(
		              _instance,
		              instance + "leave",
		              SyntheticEventCtor,
		              nativeEvent,
		              nativeEventTarget
		            );
		            reactName.target = accumulateTargetOnly;
		            reactName.relatedTarget = lastHostComponent;
		            _instance = null;
		            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
		              ((inCapturePhase = new inCapturePhase(
		                reactEventName,
		                instance + "enter",
		                reactEventType,
		                nativeEvent,
		                nativeEventTarget
		              )),
		              (inCapturePhase.target = lastHostComponent),
		              (inCapturePhase.relatedTarget = accumulateTargetOnly),
		              (_instance = inCapturePhase));
		            accumulateTargetOnly = _instance;
		            if (SyntheticEventCtor && reactEventType)
		              b: {
		                inCapturePhase = SyntheticEventCtor;
		                reactEventName = reactEventType;
		                instance = 0;
		                for (
		                  lastHostComponent = inCapturePhase;
		                  lastHostComponent;
		                  lastHostComponent = getParent(lastHostComponent)
		                )
		                  instance++;
		                lastHostComponent = 0;
		                for (
		                  _instance = reactEventName;
		                  _instance;
		                  _instance = getParent(_instance)
		                )
		                  lastHostComponent++;
		                for (; 0 < instance - lastHostComponent; )
		                  (inCapturePhase = getParent(inCapturePhase)), instance--;
		                for (; 0 < lastHostComponent - instance; )
		                  (reactEventName = getParent(reactEventName)),
		                    lastHostComponent--;
		                for (; instance--; ) {
		                  if (
		                    inCapturePhase === reactEventName ||
		                    (null !== reactEventName &&
		                      inCapturePhase === reactEventName.alternate)
		                  )
		                    break b;
		                  inCapturePhase = getParent(inCapturePhase);
		                  reactEventName = getParent(reactEventName);
		                }
		                inCapturePhase = null;
		              }
		            else inCapturePhase = null;
		            null !== SyntheticEventCtor &&
		              accumulateEnterLeaveListenersForEvent(
		                dispatchQueue,
		                reactName,
		                SyntheticEventCtor,
		                inCapturePhase,
		                !1
		              );
		            null !== reactEventType &&
		              null !== accumulateTargetOnly &&
		              accumulateEnterLeaveListenersForEvent(
		                dispatchQueue,
		                accumulateTargetOnly,
		                reactEventType,
		                inCapturePhase,
		                !0
		              );
		          }
		        }
		      }
		      a: {
		        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
		        SyntheticEventCtor =
		          reactName.nodeName && reactName.nodeName.toLowerCase();
		        if (
		          "select" === SyntheticEventCtor ||
		          ("input" === SyntheticEventCtor && "file" === reactName.type)
		        )
		          var getTargetInstFunc = getTargetInstForChangeEvent;
		        else if (isTextInputElement(reactName))
		          if (isInputEventSupported)
		            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
		          else {
		            getTargetInstFunc = getTargetInstForInputEventPolyfill;
		            var handleEventFunc = handleEventsForInputEventPolyfill;
		          }
		        else
		          (SyntheticEventCtor = reactName.nodeName),
		            !SyntheticEventCtor ||
		            "input" !== SyntheticEventCtor.toLowerCase() ||
		            ("checkbox" !== reactName.type && "radio" !== reactName.type)
		              ? targetInst &&
		                isCustomElement(targetInst.elementType) &&
		                (getTargetInstFunc = getTargetInstForChangeEvent)
		              : (getTargetInstFunc = getTargetInstForClickEvent);
		        if (
		          getTargetInstFunc &&
		          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
		        ) {
		          createAndAccumulateChangeEvent(
		            dispatchQueue,
		            getTargetInstFunc,
		            nativeEvent,
		            nativeEventTarget
		          );
		          break a;
		        }
		        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
		        "focusout" === domEventName &&
		          targetInst &&
		          "number" === reactName.type &&
		          null != targetInst.memoizedProps.value &&
		          setDefaultValue(reactName, "number", reactName.value);
		      }
		      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
		      switch (domEventName) {
		        case "focusin":
		          if (
		            isTextInputElement(handleEventFunc) ||
		            "true" === handleEventFunc.contentEditable
		          )
		            (activeElement = handleEventFunc),
		              (activeElementInst = targetInst),
		              (lastSelection = null);
		          break;
		        case "focusout":
		          lastSelection = activeElementInst = activeElement = null;
		          break;
		        case "mousedown":
		          mouseDown = !0;
		          break;
		        case "contextmenu":
		        case "mouseup":
		        case "dragend":
		          mouseDown = !1;
		          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
		          break;
		        case "selectionchange":
		          if (skipSelectionChangeEvent) break;
		        case "keydown":
		        case "keyup":
		          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
		      }
		      var fallbackData;
		      if (canUseCompositionEvent)
		        b: {
		          switch (domEventName) {
		            case "compositionstart":
		              var eventType = "onCompositionStart";
		              break b;
		            case "compositionend":
		              eventType = "onCompositionEnd";
		              break b;
		            case "compositionupdate":
		              eventType = "onCompositionUpdate";
		              break b;
		          }
		          eventType = void 0;
		        }
		      else
		        isComposing
		          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
		            (eventType = "onCompositionEnd")
		          : "keydown" === domEventName &&
		            229 === nativeEvent.keyCode &&
		            (eventType = "onCompositionStart");
		      eventType &&
		        (useFallbackCompositionData &&
		          "ko" !== nativeEvent.locale &&
		          (isComposing || "onCompositionStart" !== eventType
		            ? "onCompositionEnd" === eventType &&
		              isComposing &&
		              (fallbackData = getData())
		            : ((root = nativeEventTarget),
		              (startText = "value" in root ? root.value : root.textContent),
		              (isComposing = !0))),
		        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
		        0 < handleEventFunc.length &&
		          ((eventType = new SyntheticCompositionEvent(
		            eventType,
		            domEventName,
		            null,
		            nativeEvent,
		            nativeEventTarget
		          )),
		          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
		          fallbackData
		            ? (eventType.data = fallbackData)
		            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
		              null !== fallbackData && (eventType.data = fallbackData))));
		      if (
		        (fallbackData = canUseTextInputEvent
		          ? getNativeBeforeInputChars(domEventName, nativeEvent)
		          : getFallbackBeforeInputChars(domEventName, nativeEvent))
		      )
		        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
		          0 < eventType.length &&
		            ((handleEventFunc = new SyntheticCompositionEvent(
		              "onBeforeInput",
		              "beforeinput",
		              null,
		              nativeEvent,
		              nativeEventTarget
		            )),
		            dispatchQueue.push({
		              event: handleEventFunc,
		              listeners: eventType
		            }),
		            (handleEventFunc.data = fallbackData));
		      extractEvents$1(
		        dispatchQueue,
		        domEventName,
		        targetInst,
		        nativeEvent,
		        nativeEventTarget
		      );
		    }
		    processDispatchQueue(dispatchQueue, eventSystemFlags);
		  });
		}
		function createDispatchListener(instance, listener, currentTarget) {
		  return {
		    instance: instance,
		    listener: listener,
		    currentTarget: currentTarget
		  };
		}
		function accumulateTwoPhaseListeners(targetFiber, reactName) {
		  for (
		    var captureName = reactName + "Capture", listeners = [];
		    null !== targetFiber;

		  ) {
		    var _instance2 = targetFiber,
		      stateNode = _instance2.stateNode;
		    _instance2 = _instance2.tag;
		    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
		      null === stateNode ||
		      ((_instance2 = getListener(targetFiber, captureName)),
		      null != _instance2 &&
		        listeners.unshift(
		          createDispatchListener(targetFiber, _instance2, stateNode)
		        ),
		      (_instance2 = getListener(targetFiber, reactName)),
		      null != _instance2 &&
		        listeners.push(
		          createDispatchListener(targetFiber, _instance2, stateNode)
		        ));
		    if (3 === targetFiber.tag) return listeners;
		    targetFiber = targetFiber.return;
		  }
		  return [];
		}
		function getParent(inst) {
		  if (null === inst) return null;
		  do inst = inst.return;
		  while (inst && 5 !== inst.tag && 27 !== inst.tag);
		  return inst ? inst : null;
		}
		function accumulateEnterLeaveListenersForEvent(
		  dispatchQueue,
		  event,
		  target,
		  common,
		  inCapturePhase
		) {
		  for (
		    var registrationName = event._reactName, listeners = [];
		    null !== target && target !== common;

		  ) {
		    var _instance3 = target,
		      alternate = _instance3.alternate,
		      stateNode = _instance3.stateNode;
		    _instance3 = _instance3.tag;
		    if (null !== alternate && alternate === common) break;
		    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
		      null === stateNode ||
		      ((alternate = stateNode),
		      inCapturePhase
		        ? ((stateNode = getListener(target, registrationName)),
		          null != stateNode &&
		            listeners.unshift(
		              createDispatchListener(target, stateNode, alternate)
		            ))
		        : inCapturePhase ||
		          ((stateNode = getListener(target, registrationName)),
		          null != stateNode &&
		            listeners.push(
		              createDispatchListener(target, stateNode, alternate)
		            )));
		    target = target.return;
		  }
		  0 !== listeners.length &&
		    dispatchQueue.push({ event: event, listeners: listeners });
		}
		var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
		  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
		function normalizeMarkupForTextOrAttribute(markup) {
		  return ("string" === typeof markup ? markup : "" + markup)
		    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
		    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
		}
		function checkForUnmatchedText(serverText, clientText) {
		  clientText = normalizeMarkupForTextOrAttribute(clientText);
		  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
		}
		function noop$1() {}
		function setProp(domElement, tag, key, value, props, prevValue) {
		  switch (key) {
		    case "children":
		      "string" === typeof value
		        ? "body" === tag ||
		          ("textarea" === tag && "" === value) ||
		          setTextContent(domElement, value)
		        : ("number" === typeof value || "bigint" === typeof value) &&
		          "body" !== tag &&
		          setTextContent(domElement, "" + value);
		      break;
		    case "className":
		      setValueForKnownAttribute(domElement, "class", value);
		      break;
		    case "tabIndex":
		      setValueForKnownAttribute(domElement, "tabindex", value);
		      break;
		    case "dir":
		    case "role":
		    case "viewBox":
		    case "width":
		    case "height":
		      setValueForKnownAttribute(domElement, key, value);
		      break;
		    case "style":
		      setValueForStyles(domElement, value, prevValue);
		      break;
		    case "data":
		      if ("object" !== tag) {
		        setValueForKnownAttribute(domElement, "data", value);
		        break;
		      }
		    case "src":
		    case "href":
		      if ("" === value && ("a" !== tag || "href" !== key)) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      if (
		        null == value ||
		        "function" === typeof value ||
		        "symbol" === typeof value ||
		        "boolean" === typeof value
		      ) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      value = sanitizeURL("" + value);
		      domElement.setAttribute(key, value);
		      break;
		    case "action":
		    case "formAction":
		      if ("function" === typeof value) {
		        domElement.setAttribute(
		          key,
		          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
		        );
		        break;
		      } else
		        "function" === typeof prevValue &&
		          ("formAction" === key
		            ? ("input" !== tag &&
		                setProp(domElement, tag, "name", props.name, props, null),
		              setProp(
		                domElement,
		                tag,
		                "formEncType",
		                props.formEncType,
		                props,
		                null
		              ),
		              setProp(
		                domElement,
		                tag,
		                "formMethod",
		                props.formMethod,
		                props,
		                null
		              ),
		              setProp(
		                domElement,
		                tag,
		                "formTarget",
		                props.formTarget,
		                props,
		                null
		              ))
		            : (setProp(domElement, tag, "encType", props.encType, props, null),
		              setProp(domElement, tag, "method", props.method, props, null),
		              setProp(domElement, tag, "target", props.target, props, null)));
		      if (
		        null == value ||
		        "symbol" === typeof value ||
		        "boolean" === typeof value
		      ) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      value = sanitizeURL("" + value);
		      domElement.setAttribute(key, value);
		      break;
		    case "onClick":
		      null != value && (domElement.onclick = noop$1);
		      break;
		    case "onScroll":
		      null != value && listenToNonDelegatedEvent("scroll", domElement);
		      break;
		    case "onScrollEnd":
		      null != value && listenToNonDelegatedEvent("scrollend", domElement);
		      break;
		    case "dangerouslySetInnerHTML":
		      if (null != value) {
		        if ("object" !== typeof value || !("__html" in value))
		          throw Error(formatProdErrorMessage(61));
		        key = value.__html;
		        if (null != key) {
		          if (null != props.children) throw Error(formatProdErrorMessage(60));
		          domElement.innerHTML = key;
		        }
		      }
		      break;
		    case "multiple":
		      domElement.multiple =
		        value && "function" !== typeof value && "symbol" !== typeof value;
		      break;
		    case "muted":
		      domElement.muted =
		        value && "function" !== typeof value && "symbol" !== typeof value;
		      break;
		    case "suppressContentEditableWarning":
		    case "suppressHydrationWarning":
		    case "defaultValue":
		    case "defaultChecked":
		    case "innerHTML":
		    case "ref":
		      break;
		    case "autoFocus":
		      break;
		    case "xlinkHref":
		      if (
		        null == value ||
		        "function" === typeof value ||
		        "boolean" === typeof value ||
		        "symbol" === typeof value
		      ) {
		        domElement.removeAttribute("xlink:href");
		        break;
		      }
		      key = sanitizeURL("" + value);
		      domElement.setAttributeNS(
		        "http://www.w3.org/1999/xlink",
		        "xlink:href",
		        key
		      );
		      break;
		    case "contentEditable":
		    case "spellCheck":
		    case "draggable":
		    case "value":
		    case "autoReverse":
		    case "externalResourcesRequired":
		    case "focusable":
		    case "preserveAlpha":
		      null != value && "function" !== typeof value && "symbol" !== typeof value
		        ? domElement.setAttribute(key, "" + value)
		        : domElement.removeAttribute(key);
		      break;
		    case "inert":
		    case "allowFullScreen":
		    case "async":
		    case "autoPlay":
		    case "controls":
		    case "default":
		    case "defer":
		    case "disabled":
		    case "disablePictureInPicture":
		    case "disableRemotePlayback":
		    case "formNoValidate":
		    case "hidden":
		    case "loop":
		    case "noModule":
		    case "noValidate":
		    case "open":
		    case "playsInline":
		    case "readOnly":
		    case "required":
		    case "reversed":
		    case "scoped":
		    case "seamless":
		    case "itemScope":
		      value && "function" !== typeof value && "symbol" !== typeof value
		        ? domElement.setAttribute(key, "")
		        : domElement.removeAttribute(key);
		      break;
		    case "capture":
		    case "download":
		      true === value
		        ? domElement.setAttribute(key, "")
		        : false !== value &&
		            null != value &&
		            "function" !== typeof value &&
		            "symbol" !== typeof value
		          ? domElement.setAttribute(key, value)
		          : domElement.removeAttribute(key);
		      break;
		    case "cols":
		    case "rows":
		    case "size":
		    case "span":
		      null != value &&
		      "function" !== typeof value &&
		      "symbol" !== typeof value &&
		      !isNaN(value) &&
		      1 <= value
		        ? domElement.setAttribute(key, value)
		        : domElement.removeAttribute(key);
		      break;
		    case "rowSpan":
		    case "start":
		      null == value ||
		      "function" === typeof value ||
		      "symbol" === typeof value ||
		      isNaN(value)
		        ? domElement.removeAttribute(key)
		        : domElement.setAttribute(key, value);
		      break;
		    case "popover":
		      listenToNonDelegatedEvent("beforetoggle", domElement);
		      listenToNonDelegatedEvent("toggle", domElement);
		      setValueForAttribute(domElement, "popover", value);
		      break;
		    case "xlinkActuate":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:actuate",
		        value
		      );
		      break;
		    case "xlinkArcrole":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:arcrole",
		        value
		      );
		      break;
		    case "xlinkRole":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:role",
		        value
		      );
		      break;
		    case "xlinkShow":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:show",
		        value
		      );
		      break;
		    case "xlinkTitle":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:title",
		        value
		      );
		      break;
		    case "xlinkType":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:type",
		        value
		      );
		      break;
		    case "xmlBase":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:base",
		        value
		      );
		      break;
		    case "xmlLang":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:lang",
		        value
		      );
		      break;
		    case "xmlSpace":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:space",
		        value
		      );
		      break;
		    case "is":
		      setValueForAttribute(domElement, "is", value);
		      break;
		    case "innerText":
		    case "textContent":
		      break;
		    default:
		      if (
		        !(2 < key.length) ||
		        ("o" !== key[0] && "O" !== key[0]) ||
		        ("n" !== key[1] && "N" !== key[1])
		      )
		        (key = aliases.get(key) || key),
		          setValueForAttribute(domElement, key, value);
		  }
		}
		function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
		  switch (key) {
		    case "style":
		      setValueForStyles(domElement, value, prevValue);
		      break;
		    case "dangerouslySetInnerHTML":
		      if (null != value) {
		        if ("object" !== typeof value || !("__html" in value))
		          throw Error(formatProdErrorMessage(61));
		        key = value.__html;
		        if (null != key) {
		          if (null != props.children) throw Error(formatProdErrorMessage(60));
		          domElement.innerHTML = key;
		        }
		      }
		      break;
		    case "children":
		      "string" === typeof value
		        ? setTextContent(domElement, value)
		        : ("number" === typeof value || "bigint" === typeof value) &&
		          setTextContent(domElement, "" + value);
		      break;
		    case "onScroll":
		      null != value && listenToNonDelegatedEvent("scroll", domElement);
		      break;
		    case "onScrollEnd":
		      null != value && listenToNonDelegatedEvent("scrollend", domElement);
		      break;
		    case "onClick":
		      null != value && (domElement.onclick = noop$1);
		      break;
		    case "suppressContentEditableWarning":
		    case "suppressHydrationWarning":
		    case "innerHTML":
		    case "ref":
		      break;
		    case "innerText":
		    case "textContent":
		      break;
		    default:
		      if (!registrationNameDependencies.hasOwnProperty(key))
		        a: {
		          if (
		            "o" === key[0] &&
		            "n" === key[1] &&
		            ((props = key.endsWith("Capture")),
		            (tag = key.slice(2, props ? key.length - 7 : void 0)),
		            (prevValue = domElement[internalPropsKey] || null),
		            (prevValue = null != prevValue ? prevValue[key] : null),
		            "function" === typeof prevValue &&
		              domElement.removeEventListener(tag, prevValue, props),
		            "function" === typeof value)
		          ) {
		            "function" !== typeof prevValue &&
		              null !== prevValue &&
		              (key in domElement
		                ? (domElement[key] = null)
		                : domElement.hasAttribute(key) &&
		                  domElement.removeAttribute(key));
		            domElement.addEventListener(tag, value, props);
		            break a;
		          }
		          key in domElement
		            ? (domElement[key] = value)
		            : true === value
		              ? domElement.setAttribute(key, "")
		              : setValueForAttribute(domElement, key, value);
		        }
		  }
		}
		function setInitialProperties(domElement, tag, props) {
		  switch (tag) {
		    case "div":
		    case "span":
		    case "svg":
		    case "path":
		    case "a":
		    case "g":
		    case "p":
		    case "li":
		      break;
		    case "img":
		      listenToNonDelegatedEvent("error", domElement);
		      listenToNonDelegatedEvent("load", domElement);
		      var hasSrc = false,
		        hasSrcSet = false,
		        propKey;
		      for (propKey in props)
		        if (props.hasOwnProperty(propKey)) {
		          var propValue = props[propKey];
		          if (null != propValue)
		            switch (propKey) {
		              case "src":
		                hasSrc = true;
		                break;
		              case "srcSet":
		                hasSrcSet = true;
		                break;
		              case "children":
		              case "dangerouslySetInnerHTML":
		                throw Error(formatProdErrorMessage(137, tag));
		              default:
		                setProp(domElement, tag, propKey, propValue, props, null);
		            }
		        }
		      hasSrcSet &&
		        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
		      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
		      return;
		    case "input":
		      listenToNonDelegatedEvent("invalid", domElement);
		      var defaultValue = (propKey = propValue = hasSrcSet = null),
		        checked = null,
		        defaultChecked = null;
		      for (hasSrc in props)
		        if (props.hasOwnProperty(hasSrc)) {
		          var propValue$188 = props[hasSrc];
		          if (null != propValue$188)
		            switch (hasSrc) {
		              case "name":
		                hasSrcSet = propValue$188;
		                break;
		              case "type":
		                propValue = propValue$188;
		                break;
		              case "checked":
		                checked = propValue$188;
		                break;
		              case "defaultChecked":
		                defaultChecked = propValue$188;
		                break;
		              case "value":
		                propKey = propValue$188;
		                break;
		              case "defaultValue":
		                defaultValue = propValue$188;
		                break;
		              case "children":
		              case "dangerouslySetInnerHTML":
		                if (null != propValue$188)
		                  throw Error(formatProdErrorMessage(137, tag));
		                break;
		              default:
		                setProp(domElement, tag, hasSrc, propValue$188, props, null);
		            }
		        }
		      initInput(
		        domElement,
		        propKey,
		        defaultValue,
		        checked,
		        defaultChecked,
		        propValue,
		        hasSrcSet,
		        false
		      );
		      track(domElement);
		      return;
		    case "select":
		      listenToNonDelegatedEvent("invalid", domElement);
		      hasSrc = propValue = propKey = null;
		      for (hasSrcSet in props)
		        if (
		          props.hasOwnProperty(hasSrcSet) &&
		          ((defaultValue = props[hasSrcSet]), null != defaultValue)
		        )
		          switch (hasSrcSet) {
		            case "value":
		              propKey = defaultValue;
		              break;
		            case "defaultValue":
		              propValue = defaultValue;
		              break;
		            case "multiple":
		              hasSrc = defaultValue;
		            default:
		              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
		          }
		      tag = propKey;
		      props = propValue;
		      domElement.multiple = !!hasSrc;
		      null != tag
		        ? updateOptions(domElement, !!hasSrc, tag, false)
		        : null != props && updateOptions(domElement, !!hasSrc, props, true);
		      return;
		    case "textarea":
		      listenToNonDelegatedEvent("invalid", domElement);
		      propKey = hasSrcSet = hasSrc = null;
		      for (propValue in props)
		        if (
		          props.hasOwnProperty(propValue) &&
		          ((defaultValue = props[propValue]), null != defaultValue)
		        )
		          switch (propValue) {
		            case "value":
		              hasSrc = defaultValue;
		              break;
		            case "defaultValue":
		              hasSrcSet = defaultValue;
		              break;
		            case "children":
		              propKey = defaultValue;
		              break;
		            case "dangerouslySetInnerHTML":
		              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
		              break;
		            default:
		              setProp(domElement, tag, propValue, defaultValue, props, null);
		          }
		      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
		      track(domElement);
		      return;
		    case "option":
		      for (checked in props)
		        if (
		          props.hasOwnProperty(checked) &&
		          ((hasSrc = props[checked]), null != hasSrc)
		        )
		          switch (checked) {
		            case "selected":
		              domElement.selected =
		                hasSrc &&
		                "function" !== typeof hasSrc &&
		                "symbol" !== typeof hasSrc;
		              break;
		            default:
		              setProp(domElement, tag, checked, hasSrc, props, null);
		          }
		      return;
		    case "dialog":
		      listenToNonDelegatedEvent("beforetoggle", domElement);
		      listenToNonDelegatedEvent("toggle", domElement);
		      listenToNonDelegatedEvent("cancel", domElement);
		      listenToNonDelegatedEvent("close", domElement);
		      break;
		    case "iframe":
		    case "object":
		      listenToNonDelegatedEvent("load", domElement);
		      break;
		    case "video":
		    case "audio":
		      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
		        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
		      break;
		    case "image":
		      listenToNonDelegatedEvent("error", domElement);
		      listenToNonDelegatedEvent("load", domElement);
		      break;
		    case "details":
		      listenToNonDelegatedEvent("toggle", domElement);
		      break;
		    case "embed":
		    case "source":
		    case "link":
		      listenToNonDelegatedEvent("error", domElement),
		        listenToNonDelegatedEvent("load", domElement);
		    case "area":
		    case "base":
		    case "br":
		    case "col":
		    case "hr":
		    case "keygen":
		    case "meta":
		    case "param":
		    case "track":
		    case "wbr":
		    case "menuitem":
		      for (defaultChecked in props)
		        if (
		          props.hasOwnProperty(defaultChecked) &&
		          ((hasSrc = props[defaultChecked]), null != hasSrc)
		        )
		          switch (defaultChecked) {
		            case "children":
		            case "dangerouslySetInnerHTML":
		              throw Error(formatProdErrorMessage(137, tag));
		            default:
		              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
		          }
		      return;
		    default:
		      if (isCustomElement(tag)) {
		        for (propValue$188 in props)
		          props.hasOwnProperty(propValue$188) &&
		            ((hasSrc = props[propValue$188]),
		            void 0 !== hasSrc &&
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                propValue$188,
		                hasSrc,
		                props,
		                void 0
		              ));
		        return;
		      }
		  }
		  for (defaultValue in props)
		    props.hasOwnProperty(defaultValue) &&
		      ((hasSrc = props[defaultValue]),
		      null != hasSrc &&
		        setProp(domElement, tag, defaultValue, hasSrc, props, null));
		}
		function updateProperties(domElement, tag, lastProps, nextProps) {
		  switch (tag) {
		    case "div":
		    case "span":
		    case "svg":
		    case "path":
		    case "a":
		    case "g":
		    case "p":
		    case "li":
		      break;
		    case "input":
		      var name = null,
		        type = null,
		        value = null,
		        defaultValue = null,
		        lastDefaultValue = null,
		        checked = null,
		        defaultChecked = null;
		      for (propKey in lastProps) {
		        var lastProp = lastProps[propKey];
		        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
		          switch (propKey) {
		            case "checked":
		              break;
		            case "value":
		              break;
		            case "defaultValue":
		              lastDefaultValue = lastProp;
		            default:
		              nextProps.hasOwnProperty(propKey) ||
		                setProp(domElement, tag, propKey, null, nextProps, lastProp);
		          }
		      }
		      for (var propKey$205 in nextProps) {
		        var propKey = nextProps[propKey$205];
		        lastProp = lastProps[propKey$205];
		        if (
		          nextProps.hasOwnProperty(propKey$205) &&
		          (null != propKey || null != lastProp)
		        )
		          switch (propKey$205) {
		            case "type":
		              type = propKey;
		              break;
		            case "name":
		              name = propKey;
		              break;
		            case "checked":
		              checked = propKey;
		              break;
		            case "defaultChecked":
		              defaultChecked = propKey;
		              break;
		            case "value":
		              value = propKey;
		              break;
		            case "defaultValue":
		              defaultValue = propKey;
		              break;
		            case "children":
		            case "dangerouslySetInnerHTML":
		              if (null != propKey)
		                throw Error(formatProdErrorMessage(137, tag));
		              break;
		            default:
		              propKey !== lastProp &&
		                setProp(
		                  domElement,
		                  tag,
		                  propKey$205,
		                  propKey,
		                  nextProps,
		                  lastProp
		                );
		          }
		      }
		      updateInput(
		        domElement,
		        value,
		        defaultValue,
		        lastDefaultValue,
		        checked,
		        defaultChecked,
		        type,
		        name
		      );
		      return;
		    case "select":
		      propKey = value = defaultValue = propKey$205 = null;
		      for (type in lastProps)
		        if (
		          ((lastDefaultValue = lastProps[type]),
		          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
		        )
		          switch (type) {
		            case "value":
		              break;
		            case "multiple":
		              propKey = lastDefaultValue;
		            default:
		              nextProps.hasOwnProperty(type) ||
		                setProp(
		                  domElement,
		                  tag,
		                  type,
		                  null,
		                  nextProps,
		                  lastDefaultValue
		                );
		          }
		      for (name in nextProps)
		        if (
		          ((type = nextProps[name]),
		          (lastDefaultValue = lastProps[name]),
		          nextProps.hasOwnProperty(name) &&
		            (null != type || null != lastDefaultValue))
		        )
		          switch (name) {
		            case "value":
		              propKey$205 = type;
		              break;
		            case "defaultValue":
		              defaultValue = type;
		              break;
		            case "multiple":
		              value = type;
		            default:
		              type !== lastDefaultValue &&
		                setProp(
		                  domElement,
		                  tag,
		                  name,
		                  type,
		                  nextProps,
		                  lastDefaultValue
		                );
		          }
		      tag = defaultValue;
		      lastProps = value;
		      nextProps = propKey;
		      null != propKey$205
		        ? updateOptions(domElement, !!lastProps, propKey$205, false)
		        : !!nextProps !== !!lastProps &&
		          (null != tag
		            ? updateOptions(domElement, !!lastProps, tag, true)
		            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
		      return;
		    case "textarea":
		      propKey = propKey$205 = null;
		      for (defaultValue in lastProps)
		        if (
		          ((name = lastProps[defaultValue]),
		          lastProps.hasOwnProperty(defaultValue) &&
		            null != name &&
		            !nextProps.hasOwnProperty(defaultValue))
		        )
		          switch (defaultValue) {
		            case "value":
		              break;
		            case "children":
		              break;
		            default:
		              setProp(domElement, tag, defaultValue, null, nextProps, name);
		          }
		      for (value in nextProps)
		        if (
		          ((name = nextProps[value]),
		          (type = lastProps[value]),
		          nextProps.hasOwnProperty(value) && (null != name || null != type))
		        )
		          switch (value) {
		            case "value":
		              propKey$205 = name;
		              break;
		            case "defaultValue":
		              propKey = name;
		              break;
		            case "children":
		              break;
		            case "dangerouslySetInnerHTML":
		              if (null != name) throw Error(formatProdErrorMessage(91));
		              break;
		            default:
		              name !== type &&
		                setProp(domElement, tag, value, name, nextProps, type);
		          }
		      updateTextarea(domElement, propKey$205, propKey);
		      return;
		    case "option":
		      for (var propKey$221 in lastProps)
		        if (
		          ((propKey$205 = lastProps[propKey$221]),
		          lastProps.hasOwnProperty(propKey$221) &&
		            null != propKey$205 &&
		            !nextProps.hasOwnProperty(propKey$221))
		        )
		          switch (propKey$221) {
		            case "selected":
		              domElement.selected = false;
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                propKey$221,
		                null,
		                nextProps,
		                propKey$205
		              );
		          }
		      for (lastDefaultValue in nextProps)
		        if (
		          ((propKey$205 = nextProps[lastDefaultValue]),
		          (propKey = lastProps[lastDefaultValue]),
		          nextProps.hasOwnProperty(lastDefaultValue) &&
		            propKey$205 !== propKey &&
		            (null != propKey$205 || null != propKey))
		        )
		          switch (lastDefaultValue) {
		            case "selected":
		              domElement.selected =
		                propKey$205 &&
		                "function" !== typeof propKey$205 &&
		                "symbol" !== typeof propKey$205;
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                lastDefaultValue,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		          }
		      return;
		    case "img":
		    case "link":
		    case "area":
		    case "base":
		    case "br":
		    case "col":
		    case "embed":
		    case "hr":
		    case "keygen":
		    case "meta":
		    case "param":
		    case "source":
		    case "track":
		    case "wbr":
		    case "menuitem":
		      for (var propKey$226 in lastProps)
		        (propKey$205 = lastProps[propKey$226]),
		          lastProps.hasOwnProperty(propKey$226) &&
		            null != propKey$205 &&
		            !nextProps.hasOwnProperty(propKey$226) &&
		            setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
		      for (checked in nextProps)
		        if (
		          ((propKey$205 = nextProps[checked]),
		          (propKey = lastProps[checked]),
		          nextProps.hasOwnProperty(checked) &&
		            propKey$205 !== propKey &&
		            (null != propKey$205 || null != propKey))
		        )
		          switch (checked) {
		            case "children":
		            case "dangerouslySetInnerHTML":
		              if (null != propKey$205)
		                throw Error(formatProdErrorMessage(137, tag));
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                checked,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		          }
		      return;
		    default:
		      if (isCustomElement(tag)) {
		        for (var propKey$231 in lastProps)
		          (propKey$205 = lastProps[propKey$231]),
		            lastProps.hasOwnProperty(propKey$231) &&
		              void 0 !== propKey$205 &&
		              !nextProps.hasOwnProperty(propKey$231) &&
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                propKey$231,
		                void 0,
		                nextProps,
		                propKey$205
		              );
		        for (defaultChecked in nextProps)
		          (propKey$205 = nextProps[defaultChecked]),
		            (propKey = lastProps[defaultChecked]),
		            !nextProps.hasOwnProperty(defaultChecked) ||
		              propKey$205 === propKey ||
		              (void 0 === propKey$205 && void 0 === propKey) ||
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                defaultChecked,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		        return;
		      }
		  }
		  for (var propKey$236 in lastProps)
		    (propKey$205 = lastProps[propKey$236]),
		      lastProps.hasOwnProperty(propKey$236) &&
		        null != propKey$205 &&
		        !nextProps.hasOwnProperty(propKey$236) &&
		        setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
		  for (lastProp in nextProps)
		    (propKey$205 = nextProps[lastProp]),
		      (propKey = lastProps[lastProp]),
		      !nextProps.hasOwnProperty(lastProp) ||
		        propKey$205 === propKey ||
		        (null == propKey$205 && null == propKey) ||
		        setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
		}
		var eventsEnabled = null,
		  selectionInformation = null;
		function getOwnerDocumentFromRootContainer(rootContainerElement) {
		  return 9 === rootContainerElement.nodeType
		    ? rootContainerElement
		    : rootContainerElement.ownerDocument;
		}
		function getOwnHostContext(namespaceURI) {
		  switch (namespaceURI) {
		    case "http://www.w3.org/2000/svg":
		      return 1;
		    case "http://www.w3.org/1998/Math/MathML":
		      return 2;
		    default:
		      return 0;
		  }
		}
		function getChildHostContextProd(parentNamespace, type) {
		  if (0 === parentNamespace)
		    switch (type) {
		      case "svg":
		        return 1;
		      case "math":
		        return 2;
		      default:
		        return 0;
		    }
		  return 1 === parentNamespace && "foreignObject" === type
		    ? 0
		    : parentNamespace;
		}
		function shouldSetTextContent(type, props) {
		  return (
		    "textarea" === type ||
		    "noscript" === type ||
		    "string" === typeof props.children ||
		    "number" === typeof props.children ||
		    "bigint" === typeof props.children ||
		    ("object" === typeof props.dangerouslySetInnerHTML &&
		      null !== props.dangerouslySetInnerHTML &&
		      null != props.dangerouslySetInnerHTML.__html)
		  );
		}
		var currentPopstateTransitionEvent = null;
		function shouldAttemptEagerTransition() {
		  var event = window.event;
		  if (event && "popstate" === event.type) {
		    if (event === currentPopstateTransitionEvent) return false;
		    currentPopstateTransitionEvent = event;
		    return true;
		  }
		  currentPopstateTransitionEvent = null;
		  return false;
		}
		var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
		  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
		  localPromise = "function" === typeof Promise ? Promise : void 0,
		  scheduleMicrotask =
		    "function" === typeof queueMicrotask
		      ? queueMicrotask
		      : "undefined" !== typeof localPromise
		        ? function (callback) {
		            return localPromise
		              .resolve(null)
		              .then(callback)
		              .catch(handleErrorInNextTick);
		          }
		        : scheduleTimeout;
		function handleErrorInNextTick(error) {
		  setTimeout(function () {
		    throw error;
		  });
		}
		function isSingletonScope(type) {
		  return "head" === type;
		}
		function clearSuspenseBoundary(parentInstance, suspenseInstance) {
		  var node = suspenseInstance,
		    possiblePreambleContribution = 0,
		    depth = 0;
		  do {
		    var nextNode = node.nextSibling;
		    parentInstance.removeChild(node);
		    if (nextNode && 8 === nextNode.nodeType)
		      if (((node = nextNode.data), "/$" === node)) {
		        if (
		          0 < possiblePreambleContribution &&
		          8 > possiblePreambleContribution
		        ) {
		          node = possiblePreambleContribution;
		          var ownerDocument = parentInstance.ownerDocument;
		          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
		          node & 2 && releaseSingletonInstance(ownerDocument.body);
		          if (node & 4)
		            for (
		              node = ownerDocument.head,
		                releaseSingletonInstance(node),
		                ownerDocument = node.firstChild;
		              ownerDocument;

		            ) {
		              var nextNode$jscomp$0 = ownerDocument.nextSibling,
		                nodeName = ownerDocument.nodeName;
		              ownerDocument[internalHoistableMarker] ||
		                "SCRIPT" === nodeName ||
		                "STYLE" === nodeName ||
		                ("LINK" === nodeName &&
		                  "stylesheet" === ownerDocument.rel.toLowerCase()) ||
		                node.removeChild(ownerDocument);
		              ownerDocument = nextNode$jscomp$0;
		            }
		        }
		        if (0 === depth) {
		          parentInstance.removeChild(nextNode);
		          retryIfBlockedOn(suspenseInstance);
		          return;
		        }
		        depth--;
		      } else
		        "$" === node || "$?" === node || "$!" === node
		          ? depth++
		          : (possiblePreambleContribution = node.charCodeAt(0) - 48);
		    else possiblePreambleContribution = 0;
		    node = nextNode;
		  } while (node);
		  retryIfBlockedOn(suspenseInstance);
		}
		function clearContainerSparingly(container) {
		  var nextNode = container.firstChild;
		  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
		  for (; nextNode; ) {
		    var node = nextNode;
		    nextNode = nextNode.nextSibling;
		    switch (node.nodeName) {
		      case "HTML":
		      case "HEAD":
		      case "BODY":
		        clearContainerSparingly(node);
		        detachDeletedInstance(node);
		        continue;
		      case "SCRIPT":
		      case "STYLE":
		        continue;
		      case "LINK":
		        if ("stylesheet" === node.rel.toLowerCase()) continue;
		    }
		    container.removeChild(node);
		  }
		}
		function canHydrateInstance(instance, type, props, inRootOrSingleton) {
		  for (; 1 === instance.nodeType; ) {
		    var anyProps = props;
		    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
		      if (
		        !inRootOrSingleton &&
		        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
		      )
		        break;
		    } else if (!inRootOrSingleton)
		      if ("input" === type && "hidden" === instance.type) {
		        var name = null == anyProps.name ? null : "" + anyProps.name;
		        if (
		          "hidden" === anyProps.type &&
		          instance.getAttribute("name") === name
		        )
		          return instance;
		      } else return instance;
		    else if (!instance[internalHoistableMarker])
		      switch (type) {
		        case "meta":
		          if (!instance.hasAttribute("itemprop")) break;
		          return instance;
		        case "link":
		          name = instance.getAttribute("rel");
		          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
		            break;
		          else if (
		            name !== anyProps.rel ||
		            instance.getAttribute("href") !==
		              (null == anyProps.href || "" === anyProps.href
		                ? null
		                : anyProps.href) ||
		            instance.getAttribute("crossorigin") !==
		              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
		            instance.getAttribute("title") !==
		              (null == anyProps.title ? null : anyProps.title)
		          )
		            break;
		          return instance;
		        case "style":
		          if (instance.hasAttribute("data-precedence")) break;
		          return instance;
		        case "script":
		          name = instance.getAttribute("src");
		          if (
		            (name !== (null == anyProps.src ? null : anyProps.src) ||
		              instance.getAttribute("type") !==
		                (null == anyProps.type ? null : anyProps.type) ||
		              instance.getAttribute("crossorigin") !==
		                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
		            name &&
		            instance.hasAttribute("async") &&
		            !instance.hasAttribute("itemprop")
		          )
		            break;
		          return instance;
		        default:
		          return instance;
		      }
		    instance = getNextHydratable(instance.nextSibling);
		    if (null === instance) break;
		  }
		  return null;
		}
		function canHydrateTextInstance(instance, text, inRootOrSingleton) {
		  if ("" === text) return null;
		  for (; 3 !== instance.nodeType; ) {
		    if (
		      (1 !== instance.nodeType ||
		        "INPUT" !== instance.nodeName ||
		        "hidden" !== instance.type) &&
		      !inRootOrSingleton
		    )
		      return null;
		    instance = getNextHydratable(instance.nextSibling);
		    if (null === instance) return null;
		  }
		  return instance;
		}
		function isSuspenseInstanceFallback(instance) {
		  return (
		    "$!" === instance.data ||
		    ("$?" === instance.data && "complete" === instance.ownerDocument.readyState)
		  );
		}
		function registerSuspenseInstanceRetry(instance, callback) {
		  var ownerDocument = instance.ownerDocument;
		  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
		    callback();
		  else {
		    var listener = function () {
		      callback();
		      ownerDocument.removeEventListener("DOMContentLoaded", listener);
		    };
		    ownerDocument.addEventListener("DOMContentLoaded", listener);
		    instance._reactRetry = listener;
		  }
		}
		function getNextHydratable(node) {
		  for (; null != node; node = node.nextSibling) {
		    var nodeType = node.nodeType;
		    if (1 === nodeType || 3 === nodeType) break;
		    if (8 === nodeType) {
		      nodeType = node.data;
		      if (
		        "$" === nodeType ||
		        "$!" === nodeType ||
		        "$?" === nodeType ||
		        "F!" === nodeType ||
		        "F" === nodeType
		      )
		        break;
		      if ("/$" === nodeType) return null;
		    }
		  }
		  return node;
		}
		var previousHydratableOnEnteringScopedSingleton = null;
		function getParentSuspenseInstance(targetInstance) {
		  targetInstance = targetInstance.previousSibling;
		  for (var depth = 0; targetInstance; ) {
		    if (8 === targetInstance.nodeType) {
		      var data = targetInstance.data;
		      if ("$" === data || "$!" === data || "$?" === data) {
		        if (0 === depth) return targetInstance;
		        depth--;
		      } else "/$" === data && depth++;
		    }
		    targetInstance = targetInstance.previousSibling;
		  }
		  return null;
		}
		function resolveSingletonInstance(type, props, rootContainerInstance) {
		  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
		  switch (type) {
		    case "html":
		      type = props.documentElement;
		      if (!type) throw Error(formatProdErrorMessage(452));
		      return type;
		    case "head":
		      type = props.head;
		      if (!type) throw Error(formatProdErrorMessage(453));
		      return type;
		    case "body":
		      type = props.body;
		      if (!type) throw Error(formatProdErrorMessage(454));
		      return type;
		    default:
		      throw Error(formatProdErrorMessage(451));
		  }
		}
		function releaseSingletonInstance(instance) {
		  for (var attributes = instance.attributes; attributes.length; )
		    instance.removeAttributeNode(attributes[0]);
		  detachDeletedInstance(instance);
		}
		var preloadPropsMap = new Map(),
		  preconnectsSet = new Set();
		function getHoistableRoot(container) {
		  return "function" === typeof container.getRootNode
		    ? container.getRootNode()
		    : 9 === container.nodeType
		      ? container
		      : container.ownerDocument;
		}
		var previousDispatcher = ReactDOMSharedInternals.d;
		ReactDOMSharedInternals.d = {
		  f: flushSyncWork,
		  r: requestFormReset,
		  D: prefetchDNS,
		  C: preconnect,
		  L: preload,
		  m: preloadModule,
		  X: preinitScript,
		  S: preinitStyle,
		  M: preinitModuleScript
		};
		function flushSyncWork() {
		  var previousWasRendering = previousDispatcher.f(),
		    wasRendering = flushSyncWork$1();
		  return previousWasRendering || wasRendering;
		}
		function requestFormReset(form) {
		  var formInst = getInstanceFromNode(form);
		  null !== formInst && 5 === formInst.tag && "form" === formInst.type
		    ? requestFormReset$1(formInst)
		    : previousDispatcher.r(form);
		}
		var globalDocument = "undefined" === typeof document ? null : document;
		function preconnectAs(rel, href, crossOrigin) {
		  var ownerDocument = globalDocument;
		  if (ownerDocument && "string" === typeof href && href) {
		    var limitedEscapedHref =
		      escapeSelectorAttributeValueInsideDoubleQuotes(href);
		    limitedEscapedHref =
		      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
		    "string" === typeof crossOrigin &&
		      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
		    preconnectsSet.has(limitedEscapedHref) ||
		      (preconnectsSet.add(limitedEscapedHref),
		      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
		      null === ownerDocument.querySelector(limitedEscapedHref) &&
		        ((href = ownerDocument.createElement("link")),
		        setInitialProperties(href, "link", rel),
		        markNodeAsHoistable(href),
		        ownerDocument.head.appendChild(href)));
		  }
		}
		function prefetchDNS(href) {
		  previousDispatcher.D(href);
		  preconnectAs("dns-prefetch", href, null);
		}
		function preconnect(href, crossOrigin) {
		  previousDispatcher.C(href, crossOrigin);
		  preconnectAs("preconnect", href, crossOrigin);
		}
		function preload(href, as, options) {
		  previousDispatcher.L(href, as, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href && as) {
		    var preloadSelector =
		      'link[rel="preload"][as="' +
		      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
		      '"]';
		    "image" === as
		      ? options && options.imageSrcSet
		        ? ((preloadSelector +=
		            '[imagesrcset="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(
		              options.imageSrcSet
		            ) +
		            '"]'),
		          "string" === typeof options.imageSizes &&
		            (preloadSelector +=
		              '[imagesizes="' +
		              escapeSelectorAttributeValueInsideDoubleQuotes(
		                options.imageSizes
		              ) +
		              '"]'))
		        : (preloadSelector +=
		            '[href="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		            '"]')
		      : (preloadSelector +=
		          '[href="' +
		          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		          '"]');
		    var key = preloadSelector;
		    switch (as) {
		      case "style":
		        key = getStyleKey(href);
		        break;
		      case "script":
		        key = getScriptKey(href);
		    }
		    preloadPropsMap.has(key) ||
		      ((href = assign(
		        {
		          rel: "preload",
		          href:
		            "image" === as && options && options.imageSrcSet ? void 0 : href,
		          as: as
		        },
		        options
		      )),
		      preloadPropsMap.set(key, href),
		      null !== ownerDocument.querySelector(preloadSelector) ||
		        ("style" === as &&
		          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
		        ("script" === as &&
		          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
		        ((as = ownerDocument.createElement("link")),
		        setInitialProperties(as, "link", href),
		        markNodeAsHoistable(as),
		        ownerDocument.head.appendChild(as)));
		  }
		}
		function preloadModule(href, options) {
		  previousDispatcher.m(href, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href) {
		    var as = options && "string" === typeof options.as ? options.as : "script",
		      preloadSelector =
		        'link[rel="modulepreload"][as="' +
		        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
		        '"][href="' +
		        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		        '"]',
		      key = preloadSelector;
		    switch (as) {
		      case "audioworklet":
		      case "paintworklet":
		      case "serviceworker":
		      case "sharedworker":
		      case "worker":
		      case "script":
		        key = getScriptKey(href);
		    }
		    if (
		      !preloadPropsMap.has(key) &&
		      ((href = assign({ rel: "modulepreload", href: href }, options)),
		      preloadPropsMap.set(key, href),
		      null === ownerDocument.querySelector(preloadSelector))
		    ) {
		      switch (as) {
		        case "audioworklet":
		        case "paintworklet":
		        case "serviceworker":
		        case "sharedworker":
		        case "worker":
		        case "script":
		          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
		            return;
		      }
		      as = ownerDocument.createElement("link");
		      setInitialProperties(as, "link", href);
		      markNodeAsHoistable(as);
		      ownerDocument.head.appendChild(as);
		    }
		  }
		}
		function preinitStyle(href, precedence, options) {
		  previousDispatcher.S(href, precedence, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href) {
		    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
		      key = getStyleKey(href);
		    precedence = precedence || "default";
		    var resource = styles.get(key);
		    if (!resource) {
		      var state = { loading: 0, preload: null };
		      if (
		        (resource = ownerDocument.querySelector(
		          getStylesheetSelectorFromKey(key)
		        ))
		      )
		        state.loading = 5;
		      else {
		        href = assign(
		          { rel: "stylesheet", href: href, "data-precedence": precedence },
		          options
		        );
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForStylesheet(href, options);
		        var link = (resource = ownerDocument.createElement("link"));
		        markNodeAsHoistable(link);
		        setInitialProperties(link, "link", href);
		        link._p = new Promise(function (resolve, reject) {
		          link.onload = resolve;
		          link.onerror = reject;
		        });
		        link.addEventListener("load", function () {
		          state.loading |= 1;
		        });
		        link.addEventListener("error", function () {
		          state.loading |= 2;
		        });
		        state.loading |= 4;
		        insertStylesheet(resource, precedence, ownerDocument);
		      }
		      resource = {
		        type: "stylesheet",
		        instance: resource,
		        count: 1,
		        state: state
		      };
		      styles.set(key, resource);
		    }
		  }
		}
		function preinitScript(src, options) {
		  previousDispatcher.X(src, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && src) {
		    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
		      key = getScriptKey(src),
		      resource = scripts.get(key);
		    resource ||
		      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
		      resource ||
		        ((src = assign({ src: src, async: true }, options)),
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForScript(src, options),
		        (resource = ownerDocument.createElement("script")),
		        markNodeAsHoistable(resource),
		        setInitialProperties(resource, "link", src),
		        ownerDocument.head.appendChild(resource)),
		      (resource = {
		        type: "script",
		        instance: resource,
		        count: 1,
		        state: null
		      }),
		      scripts.set(key, resource));
		  }
		}
		function preinitModuleScript(src, options) {
		  previousDispatcher.M(src, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && src) {
		    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
		      key = getScriptKey(src),
		      resource = scripts.get(key);
		    resource ||
		      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
		      resource ||
		        ((src = assign({ src: src, async: true, type: "module" }, options)),
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForScript(src, options),
		        (resource = ownerDocument.createElement("script")),
		        markNodeAsHoistable(resource),
		        setInitialProperties(resource, "link", src),
		        ownerDocument.head.appendChild(resource)),
		      (resource = {
		        type: "script",
		        instance: resource,
		        count: 1,
		        state: null
		      }),
		      scripts.set(key, resource));
		  }
		}
		function getResource(type, currentProps, pendingProps, currentResource) {
		  var JSCompiler_inline_result = (JSCompiler_inline_result =
		    rootInstanceStackCursor.current)
		    ? getHoistableRoot(JSCompiler_inline_result)
		    : null;
		  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
		  switch (type) {
		    case "meta":
		    case "title":
		      return null;
		    case "style":
		      return "string" === typeof pendingProps.precedence &&
		        "string" === typeof pendingProps.href
		        ? ((currentProps = getStyleKey(pendingProps.href)),
		          (pendingProps = getResourcesFromRoot(
		            JSCompiler_inline_result
		          ).hoistableStyles),
		          (currentResource = pendingProps.get(currentProps)),
		          currentResource ||
		            ((currentResource = {
		              type: "style",
		              instance: null,
		              count: 0,
		              state: null
		            }),
		            pendingProps.set(currentProps, currentResource)),
		          currentResource)
		        : { type: "void", instance: null, count: 0, state: null };
		    case "link":
		      if (
		        "stylesheet" === pendingProps.rel &&
		        "string" === typeof pendingProps.href &&
		        "string" === typeof pendingProps.precedence
		      ) {
		        type = getStyleKey(pendingProps.href);
		        var styles$244 = getResourcesFromRoot(
		            JSCompiler_inline_result
		          ).hoistableStyles,
		          resource$245 = styles$244.get(type);
		        resource$245 ||
		          ((JSCompiler_inline_result =
		            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
		          (resource$245 = {
		            type: "stylesheet",
		            instance: null,
		            count: 0,
		            state: { loading: 0, preload: null }
		          }),
		          styles$244.set(type, resource$245),
		          (styles$244 = JSCompiler_inline_result.querySelector(
		            getStylesheetSelectorFromKey(type)
		          )) &&
		            !styles$244._p &&
		            ((resource$245.instance = styles$244),
		            (resource$245.state.loading = 5)),
		          preloadPropsMap.has(type) ||
		            ((pendingProps = {
		              rel: "preload",
		              as: "style",
		              href: pendingProps.href,
		              crossOrigin: pendingProps.crossOrigin,
		              integrity: pendingProps.integrity,
		              media: pendingProps.media,
		              hrefLang: pendingProps.hrefLang,
		              referrerPolicy: pendingProps.referrerPolicy
		            }),
		            preloadPropsMap.set(type, pendingProps),
		            styles$244 ||
		              preloadStylesheet(
		                JSCompiler_inline_result,
		                type,
		                pendingProps,
		                resource$245.state
		              )));
		        if (currentProps && null === currentResource)
		          throw Error(formatProdErrorMessage(528, ""));
		        return resource$245;
		      }
		      if (currentProps && null !== currentResource)
		        throw Error(formatProdErrorMessage(529, ""));
		      return null;
		    case "script":
		      return (
		        (currentProps = pendingProps.async),
		        (pendingProps = pendingProps.src),
		        "string" === typeof pendingProps &&
		        currentProps &&
		        "function" !== typeof currentProps &&
		        "symbol" !== typeof currentProps
		          ? ((currentProps = getScriptKey(pendingProps)),
		            (pendingProps = getResourcesFromRoot(
		              JSCompiler_inline_result
		            ).hoistableScripts),
		            (currentResource = pendingProps.get(currentProps)),
		            currentResource ||
		              ((currentResource = {
		                type: "script",
		                instance: null,
		                count: 0,
		                state: null
		              }),
		              pendingProps.set(currentProps, currentResource)),
		            currentResource)
		          : { type: "void", instance: null, count: 0, state: null }
		      );
		    default:
		      throw Error(formatProdErrorMessage(444, type));
		  }
		}
		function getStyleKey(href) {
		  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
		}
		function getStylesheetSelectorFromKey(key) {
		  return 'link[rel="stylesheet"][' + key + "]";
		}
		function stylesheetPropsFromRawProps(rawProps) {
		  return assign({}, rawProps, {
		    "data-precedence": rawProps.precedence,
		    precedence: null
		  });
		}
		function preloadStylesheet(ownerDocument, key, preloadProps, state) {
		  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
		    ? (state.loading = 1)
		    : ((key = ownerDocument.createElement("link")),
		      (state.preload = key),
		      key.addEventListener("load", function () {
		        return (state.loading |= 1);
		      }),
		      key.addEventListener("error", function () {
		        return (state.loading |= 2);
		      }),
		      setInitialProperties(key, "link", preloadProps),
		      markNodeAsHoistable(key),
		      ownerDocument.head.appendChild(key));
		}
		function getScriptKey(src) {
		  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
		}
		function getScriptSelectorFromKey(key) {
		  return "script[async]" + key;
		}
		function acquireResource(hoistableRoot, resource, props) {
		  resource.count++;
		  if (null === resource.instance)
		    switch (resource.type) {
		      case "style":
		        var instance = hoistableRoot.querySelector(
		          'style[data-href~="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
		            '"]'
		        );
		        if (instance)
		          return (
		            (resource.instance = instance),
		            markNodeAsHoistable(instance),
		            instance
		          );
		        var styleProps = assign({}, props, {
		          "data-href": props.href,
		          "data-precedence": props.precedence,
		          href: null,
		          precedence: null
		        });
		        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
		          "style"
		        );
		        markNodeAsHoistable(instance);
		        setInitialProperties(instance, "style", styleProps);
		        insertStylesheet(instance, props.precedence, hoistableRoot);
		        return (resource.instance = instance);
		      case "stylesheet":
		        styleProps = getStyleKey(props.href);
		        var instance$250 = hoistableRoot.querySelector(
		          getStylesheetSelectorFromKey(styleProps)
		        );
		        if (instance$250)
		          return (
		            (resource.state.loading |= 4),
		            (resource.instance = instance$250),
		            markNodeAsHoistable(instance$250),
		            instance$250
		          );
		        instance = stylesheetPropsFromRawProps(props);
		        (styleProps = preloadPropsMap.get(styleProps)) &&
		          adoptPreloadPropsForStylesheet(instance, styleProps);
		        instance$250 = (
		          hoistableRoot.ownerDocument || hoistableRoot
		        ).createElement("link");
		        markNodeAsHoistable(instance$250);
		        var linkInstance = instance$250;
		        linkInstance._p = new Promise(function (resolve, reject) {
		          linkInstance.onload = resolve;
		          linkInstance.onerror = reject;
		        });
		        setInitialProperties(instance$250, "link", instance);
		        resource.state.loading |= 4;
		        insertStylesheet(instance$250, props.precedence, hoistableRoot);
		        return (resource.instance = instance$250);
		      case "script":
		        instance$250 = getScriptKey(props.src);
		        if (
		          (styleProps = hoistableRoot.querySelector(
		            getScriptSelectorFromKey(instance$250)
		          ))
		        )
		          return (
		            (resource.instance = styleProps),
		            markNodeAsHoistable(styleProps),
		            styleProps
		          );
		        instance = props;
		        if ((styleProps = preloadPropsMap.get(instance$250)))
		          (instance = assign({}, props)),
		            adoptPreloadPropsForScript(instance, styleProps);
		        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		        styleProps = hoistableRoot.createElement("script");
		        markNodeAsHoistable(styleProps);
		        setInitialProperties(styleProps, "link", instance);
		        hoistableRoot.head.appendChild(styleProps);
		        return (resource.instance = styleProps);
		      case "void":
		        return null;
		      default:
		        throw Error(formatProdErrorMessage(443, resource.type));
		    }
		  else
		    "stylesheet" === resource.type &&
		      0 === (resource.state.loading & 4) &&
		      ((instance = resource.instance),
		      (resource.state.loading |= 4),
		      insertStylesheet(instance, props.precedence, hoistableRoot));
		  return resource.instance;
		}
		function insertStylesheet(instance, precedence, root) {
		  for (
		    var nodes = root.querySelectorAll(
		        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
		      ),
		      last = nodes.length ? nodes[nodes.length - 1] : null,
		      prior = last,
		      i = 0;
		    i < nodes.length;
		    i++
		  ) {
		    var node = nodes[i];
		    if (node.dataset.precedence === precedence) prior = node;
		    else if (prior !== last) break;
		  }
		  prior
		    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
		    : ((precedence = 9 === root.nodeType ? root.head : root),
		      precedence.insertBefore(instance, precedence.firstChild));
		}
		function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
		  null == stylesheetProps.crossOrigin &&
		    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
		  null == stylesheetProps.referrerPolicy &&
		    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
		  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
		}
		function adoptPreloadPropsForScript(scriptProps, preloadProps) {
		  null == scriptProps.crossOrigin &&
		    (scriptProps.crossOrigin = preloadProps.crossOrigin);
		  null == scriptProps.referrerPolicy &&
		    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
		  null == scriptProps.integrity &&
		    (scriptProps.integrity = preloadProps.integrity);
		}
		var tagCaches = null;
		function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
		  if (null === tagCaches) {
		    var cache = new Map();
		    var caches = (tagCaches = new Map());
		    caches.set(ownerDocument, cache);
		  } else
		    (caches = tagCaches),
		      (cache = caches.get(ownerDocument)),
		      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
		  if (cache.has(type)) return cache;
		  cache.set(type, null);
		  ownerDocument = ownerDocument.getElementsByTagName(type);
		  for (caches = 0; caches < ownerDocument.length; caches++) {
		    var node = ownerDocument[caches];
		    if (
		      !(
		        node[internalHoistableMarker] ||
		        node[internalInstanceKey] ||
		        ("link" === type && "stylesheet" === node.getAttribute("rel"))
		      ) &&
		      "http://www.w3.org/2000/svg" !== node.namespaceURI
		    ) {
		      var nodeKey = node.getAttribute(keyAttribute) || "";
		      nodeKey = type + nodeKey;
		      var existing = cache.get(nodeKey);
		      existing ? existing.push(node) : cache.set(nodeKey, [node]);
		    }
		  }
		  return cache;
		}
		function mountHoistable(hoistableRoot, type, instance) {
		  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		  hoistableRoot.head.insertBefore(
		    instance,
		    "title" === type ? hoistableRoot.querySelector("head > title") : null
		  );
		}
		function isHostHoistableType(type, props, hostContext) {
		  if (1 === hostContext || null != props.itemProp) return false;
		  switch (type) {
		    case "meta":
		    case "title":
		      return true;
		    case "style":
		      if (
		        "string" !== typeof props.precedence ||
		        "string" !== typeof props.href ||
		        "" === props.href
		      )
		        break;
		      return true;
		    case "link":
		      if (
		        "string" !== typeof props.rel ||
		        "string" !== typeof props.href ||
		        "" === props.href ||
		        props.onLoad ||
		        props.onError
		      )
		        break;
		      switch (props.rel) {
		        case "stylesheet":
		          return (
		            (type = props.disabled),
		            "string" === typeof props.precedence && null == type
		          );
		        default:
		          return true;
		      }
		    case "script":
		      if (
		        props.async &&
		        "function" !== typeof props.async &&
		        "symbol" !== typeof props.async &&
		        !props.onLoad &&
		        !props.onError &&
		        props.src &&
		        "string" === typeof props.src
		      )
		        return true;
		  }
		  return false;
		}
		function preloadResource(resource) {
		  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
		    ? false
		    : true;
		}
		var suspendedState = null;
		function noop() {}
		function suspendResource(hoistableRoot, resource, props) {
		  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
		  var state = suspendedState;
		  if (
		    "stylesheet" === resource.type &&
		    ("string" !== typeof props.media ||
		      false !== matchMedia(props.media).matches) &&
		    0 === (resource.state.loading & 4)
		  ) {
		    if (null === resource.instance) {
		      var key = getStyleKey(props.href),
		        instance = hoistableRoot.querySelector(
		          getStylesheetSelectorFromKey(key)
		        );
		      if (instance) {
		        hoistableRoot = instance._p;
		        null !== hoistableRoot &&
		          "object" === typeof hoistableRoot &&
		          "function" === typeof hoistableRoot.then &&
		          (state.count++,
		          (state = onUnsuspend.bind(state)),
		          hoistableRoot.then(state, state));
		        resource.state.loading |= 4;
		        resource.instance = instance;
		        markNodeAsHoistable(instance);
		        return;
		      }
		      instance = hoistableRoot.ownerDocument || hoistableRoot;
		      props = stylesheetPropsFromRawProps(props);
		      (key = preloadPropsMap.get(key)) &&
		        adoptPreloadPropsForStylesheet(props, key);
		      instance = instance.createElement("link");
		      markNodeAsHoistable(instance);
		      var linkInstance = instance;
		      linkInstance._p = new Promise(function (resolve, reject) {
		        linkInstance.onload = resolve;
		        linkInstance.onerror = reject;
		      });
		      setInitialProperties(instance, "link", props);
		      resource.instance = instance;
		    }
		    null === state.stylesheets && (state.stylesheets = new Map());
		    state.stylesheets.set(resource, hoistableRoot);
		    (hoistableRoot = resource.state.preload) &&
		      0 === (resource.state.loading & 3) &&
		      (state.count++,
		      (resource = onUnsuspend.bind(state)),
		      hoistableRoot.addEventListener("load", resource),
		      hoistableRoot.addEventListener("error", resource));
		  }
		}
		function waitForCommitToBeReady() {
		  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
		  var state = suspendedState;
		  state.stylesheets &&
		    0 === state.count &&
		    insertSuspendedStylesheets(state, state.stylesheets);
		  return 0 < state.count
		    ? function (commit) {
		        var stylesheetTimer = setTimeout(function () {
		          state.stylesheets &&
		            insertSuspendedStylesheets(state, state.stylesheets);
		          if (state.unsuspend) {
		            var unsuspend = state.unsuspend;
		            state.unsuspend = null;
		            unsuspend();
		          }
		        }, 6e4);
		        state.unsuspend = commit;
		        return function () {
		          state.unsuspend = null;
		          clearTimeout(stylesheetTimer);
		        };
		      }
		    : null;
		}
		function onUnsuspend() {
		  this.count--;
		  if (0 === this.count)
		    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
		    else if (this.unsuspend) {
		      var unsuspend = this.unsuspend;
		      this.unsuspend = null;
		      unsuspend();
		    }
		}
		var precedencesByRoot = null;
		function insertSuspendedStylesheets(state, resources) {
		  state.stylesheets = null;
		  null !== state.unsuspend &&
		    (state.count++,
		    (precedencesByRoot = new Map()),
		    resources.forEach(insertStylesheetIntoRoot, state),
		    (precedencesByRoot = null),
		    onUnsuspend.call(state));
		}
		function insertStylesheetIntoRoot(root, resource) {
		  if (!(resource.state.loading & 4)) {
		    var precedences = precedencesByRoot.get(root);
		    if (precedences) var last = precedences.get(null);
		    else {
		      precedences = new Map();
		      precedencesByRoot.set(root, precedences);
		      for (
		        var nodes = root.querySelectorAll(
		            "link[data-precedence],style[data-precedence]"
		          ),
		          i = 0;
		        i < nodes.length;
		        i++
		      ) {
		        var node = nodes[i];
		        if (
		          "LINK" === node.nodeName ||
		          "not all" !== node.getAttribute("media")
		        )
		          precedences.set(node.dataset.precedence, node), (last = node);
		      }
		      last && precedences.set(null, last);
		    }
		    nodes = resource.instance;
		    node = nodes.getAttribute("data-precedence");
		    i = precedences.get(node) || last;
		    i === last && precedences.set(null, nodes);
		    precedences.set(node, nodes);
		    this.count++;
		    last = onUnsuspend.bind(this);
		    nodes.addEventListener("load", last);
		    nodes.addEventListener("error", last);
		    i
		      ? i.parentNode.insertBefore(nodes, i.nextSibling)
		      : ((root = 9 === root.nodeType ? root.head : root),
		        root.insertBefore(nodes, root.firstChild));
		    resource.state.loading |= 4;
		  }
		}
		var HostTransitionContext = {
		  $$typeof: REACT_CONTEXT_TYPE,
		  Provider: null,
		  Consumer: null,
		  _currentValue: sharedNotPendingObject,
		  _currentValue2: sharedNotPendingObject,
		  _threadCount: 0
		};
		function FiberRootNode(
		  containerInfo,
		  tag,
		  hydrate,
		  identifierPrefix,
		  onUncaughtError,
		  onCaughtError,
		  onRecoverableError,
		  formState
		) {
		  this.tag = 1;
		  this.containerInfo = containerInfo;
		  this.pingCache = this.current = this.pendingChildren = null;
		  this.timeoutHandle = -1;
		  this.callbackNode =
		    this.next =
		    this.pendingContext =
		    this.context =
		    this.cancelPendingCommit =
		      null;
		  this.callbackPriority = 0;
		  this.expirationTimes = createLaneMap(-1);
		  this.entangledLanes =
		    this.shellSuspendCounter =
		    this.errorRecoveryDisabledLanes =
		    this.expiredLanes =
		    this.warmLanes =
		    this.pingedLanes =
		    this.suspendedLanes =
		    this.pendingLanes =
		      0;
		  this.entanglements = createLaneMap(0);
		  this.hiddenUpdates = createLaneMap(null);
		  this.identifierPrefix = identifierPrefix;
		  this.onUncaughtError = onUncaughtError;
		  this.onCaughtError = onCaughtError;
		  this.onRecoverableError = onRecoverableError;
		  this.pooledCache = null;
		  this.pooledCacheLanes = 0;
		  this.formState = formState;
		  this.incompleteTransitions = new Map();
		}
		function createFiberRoot(
		  containerInfo,
		  tag,
		  hydrate,
		  initialChildren,
		  hydrationCallbacks,
		  isStrictMode,
		  identifierPrefix,
		  onUncaughtError,
		  onCaughtError,
		  onRecoverableError,
		  transitionCallbacks,
		  formState
		) {
		  containerInfo = new FiberRootNode(
		    containerInfo,
		    tag,
		    hydrate,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    formState
		  );
		  tag = 1;
		  true === isStrictMode && (tag |= 24);
		  isStrictMode = createFiberImplClass(3, null, null, tag);
		  containerInfo.current = isStrictMode;
		  isStrictMode.stateNode = containerInfo;
		  tag = createCache();
		  tag.refCount++;
		  containerInfo.pooledCache = tag;
		  tag.refCount++;
		  isStrictMode.memoizedState = {
		    element: initialChildren,
		    isDehydrated: hydrate,
		    cache: tag
		  };
		  initializeUpdateQueue(isStrictMode);
		  return containerInfo;
		}
		function getContextForSubtree(parentComponent) {
		  if (!parentComponent) return emptyContextObject;
		  parentComponent = emptyContextObject;
		  return parentComponent;
		}
		function updateContainerImpl(
		  rootFiber,
		  lane,
		  element,
		  container,
		  parentComponent,
		  callback
		) {
		  parentComponent = getContextForSubtree(parentComponent);
		  null === container.context
		    ? (container.context = parentComponent)
		    : (container.pendingContext = parentComponent);
		  container = createUpdate(lane);
		  container.payload = { element: element };
		  callback = void 0 === callback ? null : callback;
		  null !== callback && (container.callback = callback);
		  element = enqueueUpdate(rootFiber, container, lane);
		  null !== element &&
		    (scheduleUpdateOnFiber(element, rootFiber, lane),
		    entangleTransitions(element, rootFiber, lane));
		}
		function markRetryLaneImpl(fiber, retryLane) {
		  fiber = fiber.memoizedState;
		  if (null !== fiber && null !== fiber.dehydrated) {
		    var a = fiber.retryLane;
		    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		  }
		}
		function markRetryLaneIfNotHydrated(fiber, retryLane) {
		  markRetryLaneImpl(fiber, retryLane);
		  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
		}
		function attemptContinuousHydration(fiber) {
		  if (13 === fiber.tag) {
		    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
		    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
		    markRetryLaneIfNotHydrated(fiber, 67108864);
		  }
		}
		var _enabled = true;
		function dispatchDiscreteEvent(
		  domEventName,
		  eventSystemFlags,
		  container,
		  nativeEvent
		) {
		  var prevTransition = ReactSharedInternals.T;
		  ReactSharedInternals.T = null;
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    (ReactDOMSharedInternals.p = 2),
		      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function dispatchContinuousEvent(
		  domEventName,
		  eventSystemFlags,
		  container,
		  nativeEvent
		) {
		  var prevTransition = ReactSharedInternals.T;
		  ReactSharedInternals.T = null;
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    (ReactDOMSharedInternals.p = 8),
		      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function dispatchEvent(
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  if (_enabled) {
		    var blockedOn = findInstanceBlockingEvent(nativeEvent);
		    if (null === blockedOn)
		      dispatchEventForPluginEventSystem(
		        domEventName,
		        eventSystemFlags,
		        nativeEvent,
		        return_targetInst,
		        targetContainer
		      ),
		        clearIfContinuousEvent(domEventName, nativeEvent);
		    else if (
		      queueIfContinuousEvent(
		        blockedOn,
		        domEventName,
		        eventSystemFlags,
		        targetContainer,
		        nativeEvent
		      )
		    )
		      nativeEvent.stopPropagation();
		    else if (
		      (clearIfContinuousEvent(domEventName, nativeEvent),
		      eventSystemFlags & 4 &&
		        -1 < discreteReplayableEvents.indexOf(domEventName))
		    ) {
		      for (; null !== blockedOn; ) {
		        var fiber = getInstanceFromNode(blockedOn);
		        if (null !== fiber)
		          switch (fiber.tag) {
		            case 3:
		              fiber = fiber.stateNode;
		              if (fiber.current.memoizedState.isDehydrated) {
		                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
		                if (0 !== lanes) {
		                  var root = fiber;
		                  root.pendingLanes |= 2;
		                  for (root.entangledLanes |= 2; lanes; ) {
		                    var lane = 1 << (31 - clz32(lanes));
		                    root.entanglements[1] |= lane;
		                    lanes &= ~lane;
		                  }
		                  ensureRootIsScheduled(fiber);
		                  0 === (executionContext & 6) &&
		                    ((workInProgressRootRenderTargetTime = now() + 500),
		                    flushSyncWorkAcrossRoots_impl(0));
		                }
		              }
		              break;
		            case 13:
		              (root = enqueueConcurrentRenderForLane(fiber, 2)),
		                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
		                flushSyncWork$1(),
		                markRetryLaneIfNotHydrated(fiber, 2);
		          }
		        fiber = findInstanceBlockingEvent(nativeEvent);
		        null === fiber &&
		          dispatchEventForPluginEventSystem(
		            domEventName,
		            eventSystemFlags,
		            nativeEvent,
		            return_targetInst,
		            targetContainer
		          );
		        if (fiber === blockedOn) break;
		        blockedOn = fiber;
		      }
		      null !== blockedOn && nativeEvent.stopPropagation();
		    } else
		      dispatchEventForPluginEventSystem(
		        domEventName,
		        eventSystemFlags,
		        nativeEvent,
		        null,
		        targetContainer
		      );
		  }
		}
		function findInstanceBlockingEvent(nativeEvent) {
		  nativeEvent = getEventTarget(nativeEvent);
		  return findInstanceBlockingTarget(nativeEvent);
		}
		var return_targetInst = null;
		function findInstanceBlockingTarget(targetNode) {
		  return_targetInst = null;
		  targetNode = getClosestInstanceFromNode(targetNode);
		  if (null !== targetNode) {
		    var nearestMounted = getNearestMountedFiber(targetNode);
		    if (null === nearestMounted) targetNode = null;
		    else {
		      var tag = nearestMounted.tag;
		      if (13 === tag) {
		        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
		        if (null !== targetNode) return targetNode;
		        targetNode = null;
		      } else if (3 === tag) {
		        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
		          return 3 === nearestMounted.tag
		            ? nearestMounted.stateNode.containerInfo
		            : null;
		        targetNode = null;
		      } else nearestMounted !== targetNode && (targetNode = null);
		    }
		  }
		  return_targetInst = targetNode;
		  return null;
		}
		function getEventPriority(domEventName) {
		  switch (domEventName) {
		    case "beforetoggle":
		    case "cancel":
		    case "click":
		    case "close":
		    case "contextmenu":
		    case "copy":
		    case "cut":
		    case "auxclick":
		    case "dblclick":
		    case "dragend":
		    case "dragstart":
		    case "drop":
		    case "focusin":
		    case "focusout":
		    case "input":
		    case "invalid":
		    case "keydown":
		    case "keypress":
		    case "keyup":
		    case "mousedown":
		    case "mouseup":
		    case "paste":
		    case "pause":
		    case "play":
		    case "pointercancel":
		    case "pointerdown":
		    case "pointerup":
		    case "ratechange":
		    case "reset":
		    case "resize":
		    case "seeked":
		    case "submit":
		    case "toggle":
		    case "touchcancel":
		    case "touchend":
		    case "touchstart":
		    case "volumechange":
		    case "change":
		    case "selectionchange":
		    case "textInput":
		    case "compositionstart":
		    case "compositionend":
		    case "compositionupdate":
		    case "beforeblur":
		    case "afterblur":
		    case "beforeinput":
		    case "blur":
		    case "fullscreenchange":
		    case "focus":
		    case "hashchange":
		    case "popstate":
		    case "select":
		    case "selectstart":
		      return 2;
		    case "drag":
		    case "dragenter":
		    case "dragexit":
		    case "dragleave":
		    case "dragover":
		    case "mousemove":
		    case "mouseout":
		    case "mouseover":
		    case "pointermove":
		    case "pointerout":
		    case "pointerover":
		    case "scroll":
		    case "touchmove":
		    case "wheel":
		    case "mouseenter":
		    case "mouseleave":
		    case "pointerenter":
		    case "pointerleave":
		      return 8;
		    case "message":
		      switch (getCurrentPriorityLevel()) {
		        case ImmediatePriority:
		          return 2;
		        case UserBlockingPriority:
		          return 8;
		        case NormalPriority$1:
		        case LowPriority:
		          return 32;
		        case IdlePriority:
		          return 268435456;
		        default:
		          return 32;
		      }
		    default:
		      return 32;
		  }
		}
		var hasScheduledReplayAttempt = false,
		  queuedFocus = null,
		  queuedDrag = null,
		  queuedMouse = null,
		  queuedPointers = new Map(),
		  queuedPointerCaptures = new Map(),
		  queuedExplicitHydrationTargets = [],
		  discreteReplayableEvents =
		    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
		      " "
		    );
		function clearIfContinuousEvent(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "focusin":
		    case "focusout":
		      queuedFocus = null;
		      break;
		    case "dragenter":
		    case "dragleave":
		      queuedDrag = null;
		      break;
		    case "mouseover":
		    case "mouseout":
		      queuedMouse = null;
		      break;
		    case "pointerover":
		    case "pointerout":
		      queuedPointers.delete(nativeEvent.pointerId);
		      break;
		    case "gotpointercapture":
		    case "lostpointercapture":
		      queuedPointerCaptures.delete(nativeEvent.pointerId);
		  }
		}
		function accumulateOrCreateContinuousQueuedReplayableEvent(
		  existingQueuedEvent,
		  blockedOn,
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  if (
		    null === existingQueuedEvent ||
		    existingQueuedEvent.nativeEvent !== nativeEvent
		  )
		    return (
		      (existingQueuedEvent = {
		        blockedOn: blockedOn,
		        domEventName: domEventName,
		        eventSystemFlags: eventSystemFlags,
		        nativeEvent: nativeEvent,
		        targetContainers: [targetContainer]
		      }),
		      null !== blockedOn &&
		        ((blockedOn = getInstanceFromNode(blockedOn)),
		        null !== blockedOn && attemptContinuousHydration(blockedOn)),
		      existingQueuedEvent
		    );
		  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
		  blockedOn = existingQueuedEvent.targetContainers;
		  null !== targetContainer &&
		    -1 === blockedOn.indexOf(targetContainer) &&
		    blockedOn.push(targetContainer);
		  return existingQueuedEvent;
		}
		function queueIfContinuousEvent(
		  blockedOn,
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  switch (domEventName) {
		    case "focusin":
		      return (
		        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedFocus,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "dragenter":
		      return (
		        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedDrag,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "mouseover":
		      return (
		        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedMouse,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "pointerover":
		      var pointerId = nativeEvent.pointerId;
		      queuedPointers.set(
		        pointerId,
		        accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedPointers.get(pointerId) || null,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )
		      );
		      return true;
		    case "gotpointercapture":
		      return (
		        (pointerId = nativeEvent.pointerId),
		        queuedPointerCaptures.set(
		          pointerId,
		          accumulateOrCreateContinuousQueuedReplayableEvent(
		            queuedPointerCaptures.get(pointerId) || null,
		            blockedOn,
		            domEventName,
		            eventSystemFlags,
		            targetContainer,
		            nativeEvent
		          )
		        ),
		        true
		      );
		  }
		  return false;
		}
		function attemptExplicitHydrationTarget(queuedTarget) {
		  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
		  if (null !== targetInst) {
		    var nearestMounted = getNearestMountedFiber(targetInst);
		    if (null !== nearestMounted)
		      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
		        if (
		          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
		          null !== targetInst)
		        ) {
		          queuedTarget.blockedOn = targetInst;
		          runWithPriority(queuedTarget.priority, function () {
		            if (13 === nearestMounted.tag) {
		              var lane = requestUpdateLane();
		              lane = getBumpedLaneForHydrationByLane(lane);
		              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
		              null !== root &&
		                scheduleUpdateOnFiber(root, nearestMounted, lane);
		              markRetryLaneIfNotHydrated(nearestMounted, lane);
		            }
		          });
		          return;
		        }
		      } else if (
		        3 === targetInst &&
		        nearestMounted.stateNode.current.memoizedState.isDehydrated
		      ) {
		        queuedTarget.blockedOn =
		          3 === nearestMounted.tag
		            ? nearestMounted.stateNode.containerInfo
		            : null;
		        return;
		      }
		  }
		  queuedTarget.blockedOn = null;
		}
		function attemptReplayContinuousQueuedEvent(queuedEvent) {
		  if (null !== queuedEvent.blockedOn) return false;
		  for (
		    var targetContainers = queuedEvent.targetContainers;
		    0 < targetContainers.length;

		  ) {
		    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
		    if (null === nextBlockedOn) {
		      nextBlockedOn = queuedEvent.nativeEvent;
		      var nativeEventClone = new nextBlockedOn.constructor(
		        nextBlockedOn.type,
		        nextBlockedOn
		      );
		      currentReplayingEvent = nativeEventClone;
		      nextBlockedOn.target.dispatchEvent(nativeEventClone);
		      currentReplayingEvent = null;
		    } else
		      return (
		        (targetContainers = getInstanceFromNode(nextBlockedOn)),
		        null !== targetContainers &&
		          attemptContinuousHydration(targetContainers),
		        (queuedEvent.blockedOn = nextBlockedOn),
		        false
		      );
		    targetContainers.shift();
		  }
		  return true;
		}
		function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
		  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
		}
		function replayUnblockedEvents() {
		  hasScheduledReplayAttempt = false;
		  null !== queuedFocus &&
		    attemptReplayContinuousQueuedEvent(queuedFocus) &&
		    (queuedFocus = null);
		  null !== queuedDrag &&
		    attemptReplayContinuousQueuedEvent(queuedDrag) &&
		    (queuedDrag = null);
		  null !== queuedMouse &&
		    attemptReplayContinuousQueuedEvent(queuedMouse) &&
		    (queuedMouse = null);
		  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
		  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
		}
		function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
		  queuedEvent.blockedOn === unblocked &&
		    ((queuedEvent.blockedOn = null),
		    hasScheduledReplayAttempt ||
		      ((hasScheduledReplayAttempt = true),
		      Scheduler.unstable_scheduleCallback(
		        Scheduler.unstable_NormalPriority,
		        replayUnblockedEvents
		      )));
		}
		var lastScheduledReplayQueue = null;
		function scheduleReplayQueueIfNeeded(formReplayingQueue) {
		  lastScheduledReplayQueue !== formReplayingQueue &&
		    ((lastScheduledReplayQueue = formReplayingQueue),
		    Scheduler.unstable_scheduleCallback(
		      Scheduler.unstable_NormalPriority,
		      function () {
		        lastScheduledReplayQueue === formReplayingQueue &&
		          (lastScheduledReplayQueue = null);
		        for (var i = 0; i < formReplayingQueue.length; i += 3) {
		          var form = formReplayingQueue[i],
		            submitterOrAction = formReplayingQueue[i + 1],
		            formData = formReplayingQueue[i + 2];
		          if ("function" !== typeof submitterOrAction)
		            if (null === findInstanceBlockingTarget(submitterOrAction || form))
		              continue;
		            else break;
		          var formInst = getInstanceFromNode(form);
		          null !== formInst &&
		            (formReplayingQueue.splice(i, 3),
		            (i -= 3),
		            startHostTransition(
		              formInst,
		              {
		                pending: true,
		                data: formData,
		                method: form.method,
		                action: submitterOrAction
		              },
		              submitterOrAction,
		              formData
		            ));
		        }
		      }
		    ));
		}
		function retryIfBlockedOn(unblocked) {
		  function unblock(queuedEvent) {
		    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
		  }
		  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
		  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
		  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
		  queuedPointers.forEach(unblock);
		  queuedPointerCaptures.forEach(unblock);
		  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
		    var queuedTarget = queuedExplicitHydrationTargets[i];
		    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
		  }
		  for (
		    ;
		    0 < queuedExplicitHydrationTargets.length &&
		    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

		  )
		    attemptExplicitHydrationTarget(i),
		      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
		  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
		  if (null != i)
		    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
		      var form = i[queuedTarget],
		        submitterOrAction = i[queuedTarget + 1],
		        formProps = form[internalPropsKey] || null;
		      if ("function" === typeof submitterOrAction)
		        formProps || scheduleReplayQueueIfNeeded(i);
		      else if (formProps) {
		        var action = null;
		        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
		          if (
		            ((form = submitterOrAction),
		            (formProps = submitterOrAction[internalPropsKey] || null))
		          )
		            action = formProps.formAction;
		          else {
		            if (null !== findInstanceBlockingTarget(form)) continue;
		          }
		        else action = formProps.action;
		        "function" === typeof action
		          ? (i[queuedTarget + 1] = action)
		          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
		        scheduleReplayQueueIfNeeded(i);
		      }
		    }
		}
		function ReactDOMRoot(internalRoot) {
		  this._internalRoot = internalRoot;
		}
		ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
		  function (children) {
		    var root = this._internalRoot;
		    if (null === root) throw Error(formatProdErrorMessage(409));
		    var current = root.current,
		      lane = requestUpdateLane();
		    updateContainerImpl(current, lane, children, root, null, null);
		  };
		ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
		  function () {
		    var root = this._internalRoot;
		    if (null !== root) {
		      this._internalRoot = null;
		      var container = root.containerInfo;
		      updateContainerImpl(root.current, 2, null, root, null, null);
		      flushSyncWork$1();
		      container[internalContainerInstanceKey] = null;
		    }
		  };
		function ReactDOMHydrationRoot(internalRoot) {
		  this._internalRoot = internalRoot;
		}
		ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
		  if (target) {
		    var updatePriority = resolveUpdatePriority();
		    target = { blockedOn: null, target: target, priority: updatePriority };
		    for (
		      var i = 0;
		      i < queuedExplicitHydrationTargets.length &&
		      0 !== updatePriority &&
		      updatePriority < queuedExplicitHydrationTargets[i].priority;
		      i++
		    );
		    queuedExplicitHydrationTargets.splice(i, 0, target);
		    0 === i && attemptExplicitHydrationTarget(target);
		  }
		};
		var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
		if (
		  "19.1.0" !==
		  isomorphicReactPackageVersion$jscomp$inline_1785
		)
		  throw Error(
		    formatProdErrorMessage(
		      527,
		      isomorphicReactPackageVersion$jscomp$inline_1785,
		      "19.1.0"
		    )
		  );
		ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
		  var fiber = componentOrElement._reactInternals;
		  if (void 0 === fiber) {
		    if ("function" === typeof componentOrElement.render)
		      throw Error(formatProdErrorMessage(188));
		    componentOrElement = Object.keys(componentOrElement).join(",");
		    throw Error(formatProdErrorMessage(268, componentOrElement));
		  }
		  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
		  componentOrElement =
		    null !== componentOrElement
		      ? findCurrentHostFiberImpl(componentOrElement)
		      : null;
		  componentOrElement =
		    null === componentOrElement ? null : componentOrElement.stateNode;
		  return componentOrElement;
		};
		var internals$jscomp$inline_2256 = {
		  bundleType: 0,
		  version: "19.1.0",
		  rendererPackageName: "react-dom",
		  currentDispatcherRef: ReactSharedInternals,
		  reconcilerVersion: "19.1.0"
		};
		if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
		  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		  if (
		    !hook$jscomp$inline_2257.isDisabled &&
		    hook$jscomp$inline_2257.supportsFiber
		  )
		    try {
		      (rendererID = hook$jscomp$inline_2257.inject(
		        internals$jscomp$inline_2256
		      )),
		        (injectedHook = hook$jscomp$inline_2257);
		    } catch (err) {}
		}
		reactDomClient_production.createRoot = function (container, options) {
		  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		  var isStrictMode = false,
		    identifierPrefix = "",
		    onUncaughtError = defaultOnUncaughtError,
		    onCaughtError = defaultOnCaughtError,
		    onRecoverableError = defaultOnRecoverableError,
		    transitionCallbacks = null;
		  null !== options &&
		    void 0 !== options &&
		    (true === options.unstable_strictMode && (isStrictMode = true),
		    void 0 !== options.identifierPrefix &&
		      (identifierPrefix = options.identifierPrefix),
		    void 0 !== options.onUncaughtError &&
		      (onUncaughtError = options.onUncaughtError),
		    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
		    void 0 !== options.onRecoverableError &&
		      (onRecoverableError = options.onRecoverableError),
		    void 0 !== options.unstable_transitionCallbacks &&
		      (transitionCallbacks = options.unstable_transitionCallbacks));
		  options = createFiberRoot(
		    container,
		    1,
		    false,
		    null,
		    null,
		    isStrictMode,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    null
		  );
		  container[internalContainerInstanceKey] = options.current;
		  listenToAllSupportedEvents(container);
		  return new ReactDOMRoot(options);
		};
		reactDomClient_production.hydrateRoot = function (container, initialChildren, options) {
		  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		  var isStrictMode = false,
		    identifierPrefix = "",
		    onUncaughtError = defaultOnUncaughtError,
		    onCaughtError = defaultOnCaughtError,
		    onRecoverableError = defaultOnRecoverableError,
		    transitionCallbacks = null,
		    formState = null;
		  null !== options &&
		    void 0 !== options &&
		    (true === options.unstable_strictMode && (isStrictMode = true),
		    void 0 !== options.identifierPrefix &&
		      (identifierPrefix = options.identifierPrefix),
		    void 0 !== options.onUncaughtError &&
		      (onUncaughtError = options.onUncaughtError),
		    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
		    void 0 !== options.onRecoverableError &&
		      (onRecoverableError = options.onRecoverableError),
		    void 0 !== options.unstable_transitionCallbacks &&
		      (transitionCallbacks = options.unstable_transitionCallbacks),
		    void 0 !== options.formState && (formState = options.formState));
		  initialChildren = createFiberRoot(
		    container,
		    1,
		    true,
		    initialChildren,
		    null != options ? options : null,
		    isStrictMode,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    formState
		  );
		  initialChildren.context = getContextForSubtree(null);
		  options = initialChildren.current;
		  isStrictMode = requestUpdateLane();
		  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
		  identifierPrefix = createUpdate(isStrictMode);
		  identifierPrefix.callback = null;
		  enqueueUpdate(options, identifierPrefix, isStrictMode);
		  options = isStrictMode;
		  initialChildren.current.lanes = options;
		  markRootUpdated$1(initialChildren, options);
		  ensureRootIsScheduled(initialChildren);
		  container[internalContainerInstanceKey] = initialChildren.current;
		  listenToAllSupportedEvents(container);
		  return new ReactDOMHydrationRoot(initialChildren);
		};
		reactDomClient_production.version = "19.1.0";
		return reactDomClient_production;
	}

	var hasRequiredClient;

	function requireClient () {
		if (hasRequiredClient) return client.exports;
		hasRequiredClient = 1;

		function checkDCE() {
		  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		  if (
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
		  ) {
		    return;
		  }
		  try {
		    // Verify that the code above has been dead code eliminated (DCE'd).
		    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		  } catch (err) {
		    // DevTools shouldn't crash React, no matter what.
		    // We should still report in case we break this code.
		    console.error(err);
		  }
		}

		{
		  // DCE check should happen before ReactDOM bundle executes so that
		  // DevTools can report bad minification during injection.
		  checkDCE();
		  client.exports = requireReactDomClient_production();
		}
		return client.exports;
	}

	var clientExports = requireClient();

	/**
	 * WARNING: Don't import this directly. It's imported by the code generated by
	 * `@mui/interal-babel-plugin-minify-errors`. Make sure to always use string literals in `Error`
	 * constructors to ensure the plugin works as expected. Supported patterns include:
	 *   throw new Error('My message');
	 *   throw new Error(`My message: ${foo}`);
	 *   throw new Error(`My message: ${foo}` + 'another string');
	 *   ...
	 * @param {number} code
	 */
	function formatMuiErrorMessage(code, ...args) {
	  const url = new URL(`https://mui.com/production-error/?code=${code}`);
	  args.forEach(arg => url.searchParams.append('args[]', arg));
	  return `Minified MUI error #${code}; visit ${url} for the full message.`;
	}

	// It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
	//
	// A strict capitalization should uppercase the first letter of each word in the sentence.
	// We only handle the first word.
	function capitalize(string) {
	  if (typeof string !== 'string') {
	    throw new Error(formatMuiErrorMessage(7));
	  }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

	var reactIs$1 = {exports: {}};

	var reactIs_production = {};

	/**
	 * @license React
	 * react-is.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactIs_production;

	function requireReactIs_production () {
		if (hasRequiredReactIs_production) return reactIs_production;
		hasRequiredReactIs_production = 1;
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		  REACT_PROFILER_TYPE = Symbol.for("react.profiler");
		var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
		  REACT_MEMO_TYPE = Symbol.for("react.memo"),
		  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
		  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
		  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		function typeOf(object) {
		  if ("object" === typeof object && null !== object) {
		    var $$typeof = object.$$typeof;
		    switch ($$typeof) {
		      case REACT_ELEMENT_TYPE:
		        switch (((object = object.type), object)) {
		          case REACT_FRAGMENT_TYPE:
		          case REACT_PROFILER_TYPE:
		          case REACT_STRICT_MODE_TYPE:
		          case REACT_SUSPENSE_TYPE:
		          case REACT_SUSPENSE_LIST_TYPE:
		          case REACT_VIEW_TRANSITION_TYPE:
		            return object;
		          default:
		            switch (((object = object && object.$$typeof), object)) {
		              case REACT_CONTEXT_TYPE:
		              case REACT_FORWARD_REF_TYPE:
		              case REACT_LAZY_TYPE:
		              case REACT_MEMO_TYPE:
		                return object;
		              case REACT_CONSUMER_TYPE:
		                return object;
		              default:
		                return $$typeof;
		            }
		        }
		      case REACT_PORTAL_TYPE:
		        return $$typeof;
		    }
		  }
		}
		reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
		reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
		reactIs_production.Element = REACT_ELEMENT_TYPE;
		reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
		reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
		reactIs_production.Lazy = REACT_LAZY_TYPE;
		reactIs_production.Memo = REACT_MEMO_TYPE;
		reactIs_production.Portal = REACT_PORTAL_TYPE;
		reactIs_production.Profiler = REACT_PROFILER_TYPE;
		reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
		reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
		reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		reactIs_production.isContextConsumer = function (object) {
		  return typeOf(object) === REACT_CONSUMER_TYPE;
		};
		reactIs_production.isContextProvider = function (object) {
		  return typeOf(object) === REACT_CONTEXT_TYPE;
		};
		reactIs_production.isElement = function (object) {
		  return (
		    "object" === typeof object &&
		    null !== object &&
		    object.$$typeof === REACT_ELEMENT_TYPE
		  );
		};
		reactIs_production.isForwardRef = function (object) {
		  return typeOf(object) === REACT_FORWARD_REF_TYPE;
		};
		reactIs_production.isFragment = function (object) {
		  return typeOf(object) === REACT_FRAGMENT_TYPE;
		};
		reactIs_production.isLazy = function (object) {
		  return typeOf(object) === REACT_LAZY_TYPE;
		};
		reactIs_production.isMemo = function (object) {
		  return typeOf(object) === REACT_MEMO_TYPE;
		};
		reactIs_production.isPortal = function (object) {
		  return typeOf(object) === REACT_PORTAL_TYPE;
		};
		reactIs_production.isProfiler = function (object) {
		  return typeOf(object) === REACT_PROFILER_TYPE;
		};
		reactIs_production.isStrictMode = function (object) {
		  return typeOf(object) === REACT_STRICT_MODE_TYPE;
		};
		reactIs_production.isSuspense = function (object) {
		  return typeOf(object) === REACT_SUSPENSE_TYPE;
		};
		reactIs_production.isSuspenseList = function (object) {
		  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
		};
		reactIs_production.isValidElementType = function (type) {
		  return "string" === typeof type ||
		    "function" === typeof type ||
		    type === REACT_FRAGMENT_TYPE ||
		    type === REACT_PROFILER_TYPE ||
		    type === REACT_STRICT_MODE_TYPE ||
		    type === REACT_SUSPENSE_TYPE ||
		    type === REACT_SUSPENSE_LIST_TYPE ||
		    ("object" === typeof type &&
		      null !== type &&
		      (type.$$typeof === REACT_LAZY_TYPE ||
		        type.$$typeof === REACT_MEMO_TYPE ||
		        type.$$typeof === REACT_CONTEXT_TYPE ||
		        type.$$typeof === REACT_CONSUMER_TYPE ||
		        type.$$typeof === REACT_FORWARD_REF_TYPE ||
		        type.$$typeof === REACT_CLIENT_REFERENCE ||
		        void 0 !== type.getModuleId))
		    ? true
		    : false;
		};
		reactIs_production.typeOf = typeOf;
		return reactIs_production;
	}

	var hasRequiredReactIs$1;

	function requireReactIs$1 () {
		if (hasRequiredReactIs$1) return reactIs$1.exports;
		hasRequiredReactIs$1 = 1;

		{
		  reactIs$1.exports = /*@__PURE__*/ requireReactIs_production();
		}
		return reactIs$1.exports;
	}

	var reactIsExports = /*@__PURE__*/ requireReactIs$1();

	// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
	function isPlainObject(item) {
	  if (typeof item !== 'object' || item === null) {
	    return false;
	  }
	  const prototype = Object.getPrototypeOf(item);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
	}
	function deepClone(source) {
	  if (/*#__PURE__*/reactExports.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject(source)) {
	    return source;
	  }
	  const output = {};
	  Object.keys(source).forEach(key => {
	    output[key] = deepClone(source[key]);
	  });
	  return output;
	}

	/**
	 * Merge objects deeply.
	 * It will shallow copy React elements.
	 *
	 * If `options.clone` is set to `false` the source object will be merged directly into the target object.
	 *
	 * @example
	 * ```ts
	 * deepmerge({ a: { b: 1 }, d: 2 }, { a: { c: 2 }, d: 4 });
	 * // => { a: { b: 1, c: 2 }, d: 4 }
	 * ````
	 *
	 * @param target The target object.
	 * @param source The source object.
	 * @param options The merge options.
	 * @param options.clone Set to `false` to merge the source object directly into the target object.
	 * @returns The merged object.
	 */
	function deepmerge(target, source, options = {
	  clone: true
	}) {
	  const output = options.clone ? {
	    ...target
	  } : target;
	  if (isPlainObject(target) && isPlainObject(source)) {
	    Object.keys(source).forEach(key => {
	      if (/*#__PURE__*/reactExports.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
	        output[key] = source[key];
	      } else if (isPlainObject(source[key]) &&
	      // Avoid prototype pollution
	      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
	        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
	        output[key] = deepmerge(target[key], source[key], options);
	      } else if (options.clone) {
	        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
	      } else {
	        output[key] = source[key];
	      }
	    });
	  }
	  return output;
	}

	function merge(acc, item) {
	  if (!item) {
	    return acc;
	  }
	  return deepmerge(acc, item, {
	    clone: false // No need to clone deep, it's way faster.
	  });
	}

	/**
	 * For using in `sx` prop to sort the breakpoint from low to high.
	 * Note: this function does not work and will not support multiple units.
	 *       e.g. input: { '@container (min-width:300px)': '1rem', '@container (min-width:40rem)': '2rem' }
	 *            output: { '@container (min-width:40rem)': '2rem', '@container (min-width:300px)': '1rem' } // since 40 < 300 eventhough 40rem > 300px
	 */
	function sortContainerQueries(theme, css) {
	  if (!theme.containerQueries) {
	    return css;
	  }
	  const sorted = Object.keys(css).filter(key => key.startsWith('@container')).sort((a, b) => {
	    const regex = /min-width:\s*([0-9.]+)/;
	    return +(a.match(regex)?.[1] || 0) - +(b.match(regex)?.[1] || 0);
	  });
	  if (!sorted.length) {
	    return css;
	  }
	  return sorted.reduce((acc, key) => {
	    const value = css[key];
	    delete acc[key];
	    acc[key] = value;
	    return acc;
	  }, {
	    ...css
	  });
	}
	function isCqShorthand(breakpointKeys, value) {
	  return value === '@' || value.startsWith('@') && (breakpointKeys.some(key => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
	}
	function getContainerQuery(theme, shorthand) {
	  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
	  if (!matches) {
	    return null;
	  }
	  const [, containerQuery, containerName] = matches;
	  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
	  return theme.containerQueries(containerName).up(value);
	}
	function cssContainerQueries(themeInput) {
	  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace('@media', name ? `@container ${name}` : '@container');
	  function attachCq(node, name) {
	    node.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
	    node.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
	    node.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
	    node.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
	    node.not = (...args) => {
	      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
	      if (result.includes('not all and')) {
	        // `@container` does not work with `not all and`, so need to invert the logic
	        return result.replace('not all and ', '').replace('min-width:', 'width<').replace('max-width:', 'width>').replace('and', 'or');
	      }
	      return result;
	    };
	  }
	  const node = {};
	  const containerQueries = name => {
	    attachCq(node, name);
	    return node;
	  };
	  attachCq(containerQueries);
	  return {
	    ...themeInput,
	    containerQueries
	  };
	}

	// The breakpoint **start** at this value.
	// For instance with the first breakpoint xs: [xs, sm[.
	const values$1 = {
	  xs: 0,
	  // phone
	  sm: 600,
	  // tablet
	  md: 900,
	  // small laptop
	  lg: 1200,
	  // desktop
	  xl: 1536 // large screen
	};
	const defaultBreakpoints = {
	  // Sorted ASC by size. That's important.
	  // It can't be configured as it's used statically for propTypes.
	  keys: ['xs', 'sm', 'md', 'lg', 'xl'],
	  up: key => `@media (min-width:${values$1[key]}px)`
	};
	const defaultContainerQueries = {
	  containerQueries: containerName => ({
	    up: key => {
	      let result = typeof key === 'number' ? key : values$1[key] || key;
	      if (typeof result === 'number') {
	        result = `${result}px`;
	      }
	      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
	    }
	  })
	};
	function handleBreakpoints(props, propValue, styleFromPropValue) {
	  const theme = props.theme || {};
	  if (Array.isArray(propValue)) {
	    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
	    return propValue.reduce((acc, item, index) => {
	      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
	      return acc;
	    }, {});
	  }
	  if (typeof propValue === 'object') {
	    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
	    return Object.keys(propValue).reduce((acc, breakpoint) => {
	      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
	        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
	        if (containerKey) {
	          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
	        }
	      }
	      // key is breakpoint
	      else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
	        const mediaKey = themeBreakpoints.up(breakpoint);
	        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
	      } else {
	        const cssKey = breakpoint;
	        acc[cssKey] = propValue[cssKey];
	      }
	      return acc;
	    }, {});
	  }
	  const output = styleFromPropValue(propValue);
	  return output;
	}
	function createEmptyBreakpointObject(breakpointsInput = {}) {
	  const breakpointsInOrder = breakpointsInput.keys?.reduce((acc, key) => {
	    const breakpointStyleKey = breakpointsInput.up(key);
	    acc[breakpointStyleKey] = {};
	    return acc;
	  }, {});
	  return breakpointsInOrder || {};
	}
	function removeUnusedBreakpoints(breakpointKeys, style) {
	  return breakpointKeys.reduce((acc, key) => {
	    const breakpointOutput = acc[key];
	    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
	    if (isBreakpointUnused) {
	      delete acc[key];
	    }
	    return acc;
	  }, style);
	}

	function getPath(obj, path, checkVars = true) {
	  if (!path || typeof path !== 'string') {
	    return null;
	  }

	  // Check if CSS variables are used
	  if (obj && obj.vars && checkVars) {
	    const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
	    if (val != null) {
	      return val;
	    }
	  }
	  return path.split('.').reduce((acc, item) => {
	    if (acc && acc[item] != null) {
	      return acc[item];
	    }
	    return null;
	  }, obj);
	}
	function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
	  let value;
	  if (typeof themeMapping === 'function') {
	    value = themeMapping(propValueFinal);
	  } else if (Array.isArray(themeMapping)) {
	    value = themeMapping[propValueFinal] || userValue;
	  } else {
	    value = getPath(themeMapping, propValueFinal) || userValue;
	  }
	  if (transform) {
	    value = transform(value, userValue, themeMapping);
	  }
	  return value;
	}
	function style$k(options) {
	  const {
	    prop,
	    cssProperty = options.prop,
	    themeKey,
	    transform
	  } = options;

	  // false positive
	  // eslint-disable-next-line react/function-component-definition
	  const fn = props => {
	    if (props[prop] == null) {
	      return null;
	    }
	    const propValue = props[prop];
	    const theme = props.theme;
	    const themeMapping = getPath(theme, themeKey) || {};
	    const styleFromPropValue = propValueFinal => {
	      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
	      if (propValueFinal === value && typeof propValueFinal === 'string') {
	        // Haven't found value
	        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
	      }
	      if (cssProperty === false) {
	        return value;
	      }
	      return {
	        [cssProperty]: value
	      };
	    };
	    return handleBreakpoints(props, propValue, styleFromPropValue);
	  };
	  fn.propTypes = {};
	  fn.filterProps = [prop];
	  return fn;
	}

	function memoize$1(fn) {
	  const cache = {};
	  return arg => {
	    if (cache[arg] === undefined) {
	      cache[arg] = fn(arg);
	    }
	    return cache[arg];
	  };
	}

	const properties = {
	  m: 'margin',
	  p: 'padding'
	};
	const directions = {
	  t: 'Top',
	  r: 'Right',
	  b: 'Bottom',
	  l: 'Left',
	  x: ['Left', 'Right'],
	  y: ['Top', 'Bottom']
	};
	const aliases = {
	  marginX: 'mx',
	  marginY: 'my',
	  paddingX: 'px',
	  paddingY: 'py'
	};

	// memoize() impact:
	// From 300,000 ops/sec
	// To 350,000 ops/sec
	const getCssProperties = memoize$1(prop => {
	  // It's not a shorthand notation.
	  if (prop.length > 2) {
	    if (aliases[prop]) {
	      prop = aliases[prop];
	    } else {
	      return [prop];
	    }
	  }
	  const [a, b] = prop.split('');
	  const property = properties[a];
	  const direction = directions[b] || '';
	  return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
	});
	const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
	const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
	[...marginKeys, ...paddingKeys];
	function createUnaryUnit(theme, themeKey, defaultValue, propName) {
	  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
	  if (typeof themeSpacing === 'number' || typeof themeSpacing === 'string') {
	    return val => {
	      if (typeof val === 'string') {
	        return val;
	      }
	      if (typeof themeSpacing === 'string') {
	        if (themeSpacing.startsWith('var(') && val === 0) {
	          return 0;
	        }
	        if (themeSpacing.startsWith('var(') && val === 1) {
	          return themeSpacing;
	        }
	        return `calc(${val} * ${themeSpacing})`;
	      }
	      return themeSpacing * val;
	    };
	  }
	  if (Array.isArray(themeSpacing)) {
	    return val => {
	      if (typeof val === 'string') {
	        return val;
	      }
	      const abs = Math.abs(val);
	      const transformed = themeSpacing[abs];
	      if (val >= 0) {
	        return transformed;
	      }
	      if (typeof transformed === 'number') {
	        return -transformed;
	      }
	      if (typeof transformed === 'string' && transformed.startsWith('var(')) {
	        return `calc(-1 * ${transformed})`;
	      }
	      return `-${transformed}`;
	    };
	  }
	  if (typeof themeSpacing === 'function') {
	    return themeSpacing;
	  }
	  return () => undefined;
	}
	function createUnarySpacing(theme) {
	  return createUnaryUnit(theme, 'spacing', 8);
	}
	function getValue(transformer, propValue) {
	  if (typeof propValue === 'string' || propValue == null) {
	    return propValue;
	  }
	  return transformer(propValue);
	}
	function getStyleFromPropValue(cssProperties, transformer) {
	  return propValue => cssProperties.reduce((acc, cssProperty) => {
	    acc[cssProperty] = getValue(transformer, propValue);
	    return acc;
	  }, {});
	}
	function resolveCssProperty(props, keys, prop, transformer) {
	  // Using a hash computation over an array iteration could be faster, but with only 28 items,
	  // it's doesn't worth the bundle size.
	  if (!keys.includes(prop)) {
	    return null;
	  }
	  const cssProperties = getCssProperties(prop);
	  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
	  const propValue = props[prop];
	  return handleBreakpoints(props, propValue, styleFromPropValue);
	}
	function style$j(props, keys) {
	  const transformer = createUnarySpacing(props.theme);
	  return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
	}
	function margin(props) {
	  return style$j(props, marginKeys);
	}
	margin.propTypes = {};
	margin.filterProps = marginKeys;
	function padding(props) {
	  return style$j(props, paddingKeys);
	}
	padding.propTypes = {};
	padding.filterProps = paddingKeys;

	function compose(...styles) {
	  const handlers = styles.reduce((acc, style) => {
	    style.filterProps.forEach(prop => {
	      acc[prop] = style;
	    });
	    return acc;
	  }, {});

	  // false positive
	  // eslint-disable-next-line react/function-component-definition
	  const fn = props => {
	    return Object.keys(props).reduce((acc, prop) => {
	      if (handlers[prop]) {
	        return merge(acc, handlers[prop](props));
	      }
	      return acc;
	    }, {});
	  };
	  fn.propTypes = {};
	  fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
	  return fn;
	}

	function borderTransform(value) {
	  if (typeof value !== 'number') {
	    return value;
	  }
	  return `${value}px solid`;
	}
	function createBorderStyle(prop, transform) {
	  return style$k({
	    prop,
	    themeKey: 'borders',
	    transform
	  });
	}
	const border = createBorderStyle('border', borderTransform);
	const borderTop = createBorderStyle('borderTop', borderTransform);
	const borderRight = createBorderStyle('borderRight', borderTransform);
	const borderBottom = createBorderStyle('borderBottom', borderTransform);
	const borderLeft = createBorderStyle('borderLeft', borderTransform);
	const borderColor = createBorderStyle('borderColor');
	const borderTopColor = createBorderStyle('borderTopColor');
	const borderRightColor = createBorderStyle('borderRightColor');
	const borderBottomColor = createBorderStyle('borderBottomColor');
	const borderLeftColor = createBorderStyle('borderLeftColor');
	const outline = createBorderStyle('outline', borderTransform);
	const outlineColor = createBorderStyle('outlineColor');

	// false positive
	// eslint-disable-next-line react/function-component-definition
	const borderRadius$1 = props => {
	  if (props.borderRadius !== undefined && props.borderRadius !== null) {
	    const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4);
	    const styleFromPropValue = propValue => ({
	      borderRadius: getValue(transformer, propValue)
	    });
	    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
	  }
	  return null;
	};
	borderRadius$1.propTypes = {};
	borderRadius$1.filterProps = ['borderRadius'];
	compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius$1, outline, outlineColor);

	// false positive
	// eslint-disable-next-line react/function-component-definition
	const gap = props => {
	  if (props.gap !== undefined && props.gap !== null) {
	    const transformer = createUnaryUnit(props.theme, 'spacing', 8);
	    const styleFromPropValue = propValue => ({
	      gap: getValue(transformer, propValue)
	    });
	    return handleBreakpoints(props, props.gap, styleFromPropValue);
	  }
	  return null;
	};
	gap.propTypes = {};
	gap.filterProps = ['gap'];

	// false positive
	// eslint-disable-next-line react/function-component-definition
	const columnGap = props => {
	  if (props.columnGap !== undefined && props.columnGap !== null) {
	    const transformer = createUnaryUnit(props.theme, 'spacing', 8);
	    const styleFromPropValue = propValue => ({
	      columnGap: getValue(transformer, propValue)
	    });
	    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
	  }
	  return null;
	};
	columnGap.propTypes = {};
	columnGap.filterProps = ['columnGap'];

	// false positive
	// eslint-disable-next-line react/function-component-definition
	const rowGap = props => {
	  if (props.rowGap !== undefined && props.rowGap !== null) {
	    const transformer = createUnaryUnit(props.theme, 'spacing', 8);
	    const styleFromPropValue = propValue => ({
	      rowGap: getValue(transformer, propValue)
	    });
	    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
	  }
	  return null;
	};
	rowGap.propTypes = {};
	rowGap.filterProps = ['rowGap'];
	const gridColumn = style$k({
	  prop: 'gridColumn'
	});
	const gridRow = style$k({
	  prop: 'gridRow'
	});
	const gridAutoFlow = style$k({
	  prop: 'gridAutoFlow'
	});
	const gridAutoColumns = style$k({
	  prop: 'gridAutoColumns'
	});
	const gridAutoRows = style$k({
	  prop: 'gridAutoRows'
	});
	const gridTemplateColumns = style$k({
	  prop: 'gridTemplateColumns'
	});
	const gridTemplateRows = style$k({
	  prop: 'gridTemplateRows'
	});
	const gridTemplateAreas = style$k({
	  prop: 'gridTemplateAreas'
	});
	const gridArea = style$k({
	  prop: 'gridArea'
	});
	compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

	function paletteTransform(value, userValue) {
	  if (userValue === 'grey') {
	    return userValue;
	  }
	  return value;
	}
	const color = style$k({
	  prop: 'color',
	  themeKey: 'palette',
	  transform: paletteTransform
	});
	const bgcolor = style$k({
	  prop: 'bgcolor',
	  cssProperty: 'backgroundColor',
	  themeKey: 'palette',
	  transform: paletteTransform
	});
	const backgroundColor = style$k({
	  prop: 'backgroundColor',
	  themeKey: 'palette',
	  transform: paletteTransform
	});
	compose(color, bgcolor, backgroundColor);

	function sizingTransform(value) {
	  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
	}
	const width = style$k({
	  prop: 'width',
	  transform: sizingTransform
	});
	const maxWidth = props => {
	  if (props.maxWidth !== undefined && props.maxWidth !== null) {
	    const styleFromPropValue = propValue => {
	      const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values$1[propValue];
	      if (!breakpoint) {
	        return {
	          maxWidth: sizingTransform(propValue)
	        };
	      }
	      if (props.theme?.breakpoints?.unit !== 'px') {
	        return {
	          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
	        };
	      }
	      return {
	        maxWidth: breakpoint
	      };
	    };
	    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
	  }
	  return null;
	};
	maxWidth.filterProps = ['maxWidth'];
	const minWidth = style$k({
	  prop: 'minWidth',
	  transform: sizingTransform
	});
	const height = style$k({
	  prop: 'height',
	  transform: sizingTransform
	});
	const maxHeight = style$k({
	  prop: 'maxHeight',
	  transform: sizingTransform
	});
	const minHeight = style$k({
	  prop: 'minHeight',
	  transform: sizingTransform
	});
	style$k({
	  prop: 'size',
	  cssProperty: 'width',
	  transform: sizingTransform
	});
	style$k({
	  prop: 'size',
	  cssProperty: 'height',
	  transform: sizingTransform
	});
	const boxSizing = style$k({
	  prop: 'boxSizing'
	});
	compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

	const defaultSxConfig = {
	  // borders
	  border: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  borderTop: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  borderRight: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  borderBottom: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  borderLeft: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  borderColor: {
	    themeKey: 'palette'
	  },
	  borderTopColor: {
	    themeKey: 'palette'
	  },
	  borderRightColor: {
	    themeKey: 'palette'
	  },
	  borderBottomColor: {
	    themeKey: 'palette'
	  },
	  borderLeftColor: {
	    themeKey: 'palette'
	  },
	  outline: {
	    themeKey: 'borders',
	    transform: borderTransform
	  },
	  outlineColor: {
	    themeKey: 'palette'
	  },
	  borderRadius: {
	    themeKey: 'shape.borderRadius',
	    style: borderRadius$1
	  },
	  // palette
	  color: {
	    themeKey: 'palette',
	    transform: paletteTransform
	  },
	  bgcolor: {
	    themeKey: 'palette',
	    cssProperty: 'backgroundColor',
	    transform: paletteTransform
	  },
	  backgroundColor: {
	    themeKey: 'palette',
	    transform: paletteTransform
	  },
	  // spacing
	  p: {
	    style: padding
	  },
	  pt: {
	    style: padding
	  },
	  pr: {
	    style: padding
	  },
	  pb: {
	    style: padding
	  },
	  pl: {
	    style: padding
	  },
	  px: {
	    style: padding
	  },
	  py: {
	    style: padding
	  },
	  padding: {
	    style: padding
	  },
	  paddingTop: {
	    style: padding
	  },
	  paddingRight: {
	    style: padding
	  },
	  paddingBottom: {
	    style: padding
	  },
	  paddingLeft: {
	    style: padding
	  },
	  paddingX: {
	    style: padding
	  },
	  paddingY: {
	    style: padding
	  },
	  paddingInline: {
	    style: padding
	  },
	  paddingInlineStart: {
	    style: padding
	  },
	  paddingInlineEnd: {
	    style: padding
	  },
	  paddingBlock: {
	    style: padding
	  },
	  paddingBlockStart: {
	    style: padding
	  },
	  paddingBlockEnd: {
	    style: padding
	  },
	  m: {
	    style: margin
	  },
	  mt: {
	    style: margin
	  },
	  mr: {
	    style: margin
	  },
	  mb: {
	    style: margin
	  },
	  ml: {
	    style: margin
	  },
	  mx: {
	    style: margin
	  },
	  my: {
	    style: margin
	  },
	  margin: {
	    style: margin
	  },
	  marginTop: {
	    style: margin
	  },
	  marginRight: {
	    style: margin
	  },
	  marginBottom: {
	    style: margin
	  },
	  marginLeft: {
	    style: margin
	  },
	  marginX: {
	    style: margin
	  },
	  marginY: {
	    style: margin
	  },
	  marginInline: {
	    style: margin
	  },
	  marginInlineStart: {
	    style: margin
	  },
	  marginInlineEnd: {
	    style: margin
	  },
	  marginBlock: {
	    style: margin
	  },
	  marginBlockStart: {
	    style: margin
	  },
	  marginBlockEnd: {
	    style: margin
	  },
	  // display
	  displayPrint: {
	    cssProperty: false,
	    transform: value => ({
	      '@media print': {
	        display: value
	      }
	    })
	  },
	  display: {},
	  overflow: {},
	  textOverflow: {},
	  visibility: {},
	  whiteSpace: {},
	  // flexbox
	  flexBasis: {},
	  flexDirection: {},
	  flexWrap: {},
	  justifyContent: {},
	  alignItems: {},
	  alignContent: {},
	  order: {},
	  flex: {},
	  flexGrow: {},
	  flexShrink: {},
	  alignSelf: {},
	  justifyItems: {},
	  justifySelf: {},
	  // grid
	  gap: {
	    style: gap
	  },
	  rowGap: {
	    style: rowGap
	  },
	  columnGap: {
	    style: columnGap
	  },
	  gridColumn: {},
	  gridRow: {},
	  gridAutoFlow: {},
	  gridAutoColumns: {},
	  gridAutoRows: {},
	  gridTemplateColumns: {},
	  gridTemplateRows: {},
	  gridTemplateAreas: {},
	  gridArea: {},
	  // positions
	  position: {},
	  zIndex: {
	    themeKey: 'zIndex'
	  },
	  top: {},
	  right: {},
	  bottom: {},
	  left: {},
	  // shadows
	  boxShadow: {
	    themeKey: 'shadows'
	  },
	  // sizing
	  width: {
	    transform: sizingTransform
	  },
	  maxWidth: {
	    style: maxWidth
	  },
	  minWidth: {
	    transform: sizingTransform
	  },
	  height: {
	    transform: sizingTransform
	  },
	  maxHeight: {
	    transform: sizingTransform
	  },
	  minHeight: {
	    transform: sizingTransform
	  },
	  boxSizing: {},
	  // typography
	  font: {
	    themeKey: 'font'
	  },
	  fontFamily: {
	    themeKey: 'typography'
	  },
	  fontSize: {
	    themeKey: 'typography'
	  },
	  fontStyle: {
	    themeKey: 'typography'
	  },
	  fontWeight: {
	    themeKey: 'typography'
	  },
	  letterSpacing: {},
	  textTransform: {},
	  lineHeight: {},
	  textAlign: {},
	  typography: {
	    cssProperty: false,
	    themeKey: 'typography'
	  }
	};

	function objectsHaveSameKeys(...objects) {
	  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
	  const union = new Set(allKeys);
	  return objects.every(object => union.size === Object.keys(object).length);
	}
	function callIfFn(maybeFn, arg) {
	  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
	}

	// eslint-disable-next-line @typescript-eslint/naming-convention
	function unstable_createStyleFunctionSx() {
	  function getThemeValue(prop, val, theme, config) {
	    const props = {
	      [prop]: val,
	      theme
	    };
	    const options = config[prop];
	    if (!options) {
	      return {
	        [prop]: val
	      };
	    }
	    const {
	      cssProperty = prop,
	      themeKey,
	      transform,
	      style
	    } = options;
	    if (val == null) {
	      return null;
	    }

	    // TODO v6: remove, see https://github.com/mui/material-ui/pull/38123
	    if (themeKey === 'typography' && val === 'inherit') {
	      return {
	        [prop]: val
	      };
	    }
	    const themeMapping = getPath(theme, themeKey) || {};
	    if (style) {
	      return style(props);
	    }
	    const styleFromPropValue = propValueFinal => {
	      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
	      if (propValueFinal === value && typeof propValueFinal === 'string') {
	        // Haven't found value
	        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
	      }
	      if (cssProperty === false) {
	        return value;
	      }
	      return {
	        [cssProperty]: value
	      };
	    };
	    return handleBreakpoints(props, val, styleFromPropValue);
	  }
	  function styleFunctionSx(props) {
	    const {
	      sx,
	      theme = {}
	    } = props || {};
	    if (!sx) {
	      return null; // Emotion & styled-components will neglect null
	    }
	    const config = theme.unstable_sxConfig ?? defaultSxConfig;

	    /*
	     * Receive `sxInput` as object or callback
	     * and then recursively check keys & values to create media query object styles.
	     * (the result will be used in `styled`)
	     */
	    function traverse(sxInput) {
	      let sxObject = sxInput;
	      if (typeof sxInput === 'function') {
	        sxObject = sxInput(theme);
	      } else if (typeof sxInput !== 'object') {
	        // value
	        return sxInput;
	      }
	      if (!sxObject) {
	        return null;
	      }
	      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
	      const breakpointsKeys = Object.keys(emptyBreakpoints);
	      let css = emptyBreakpoints;
	      Object.keys(sxObject).forEach(styleKey => {
	        const value = callIfFn(sxObject[styleKey], theme);
	        if (value !== null && value !== undefined) {
	          if (typeof value === 'object') {
	            if (config[styleKey]) {
	              css = merge(css, getThemeValue(styleKey, value, theme, config));
	            } else {
	              const breakpointsValues = handleBreakpoints({
	                theme
	              }, value, x => ({
	                [styleKey]: x
	              }));
	              if (objectsHaveSameKeys(breakpointsValues, value)) {
	                css[styleKey] = styleFunctionSx({
	                  sx: value,
	                  theme
	                });
	              } else {
	                css = merge(css, breakpointsValues);
	              }
	            }
	          } else {
	            css = merge(css, getThemeValue(styleKey, value, theme, config));
	          }
	        }
	      });
	      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css));
	    }
	    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
	  }
	  return styleFunctionSx;
	}
	const styleFunctionSx = unstable_createStyleFunctionSx();
	styleFunctionSx.filterProps = ['sx'];

	const splitProps = props => {
	  const result = {
	    systemProps: {},
	    otherProps: {}
	  };
	  const config = props?.theme?.unstable_sxConfig ?? defaultSxConfig;
	  Object.keys(props).forEach(prop => {
	    if (config[prop]) {
	      result.systemProps[prop] = props[prop];
	    } else {
	      result.otherProps[prop] = props[prop];
	    }
	  });
	  return result;
	};
	function extendSxProp$1(props) {
	  const {
	    sx: inSx,
	    ...other
	  } = props;
	  const {
	    systemProps,
	    otherProps
	  } = splitProps(other);
	  let finalSx;
	  if (Array.isArray(inSx)) {
	    finalSx = [systemProps, ...inSx];
	  } else if (typeof inSx === 'function') {
	    finalSx = (...args) => {
	      const result = inSx(...args);
	      if (!isPlainObject(result)) {
	        return systemProps;
	      }
	      return {
	        ...systemProps,
	        ...result
	      };
	    };
	  } else {
	    finalSx = {
	      ...systemProps,
	      ...inSx
	    };
	  }
	  return {
	    ...otherProps,
	    sx: finalSx
	  };
	}

	function _extends() {
	  return _extends = Object.assign ? Object.assign.bind() : function (n) {
	    for (var e = 1; e < arguments.length; e++) {
	      var t = arguments[e];
	      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
	    }
	    return n;
	  }, _extends.apply(null, arguments);
	}

	/*

	Based off glamor's StyleSheet, thanks Sunil 

	high performance StyleSheet for css-in-js systems

	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance

	// usage

	import { StyleSheet } from '@emotion/sheet'

	let styleSheet = new StyleSheet({ key: '', container: document.head })

	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet

	styleSheet.flush()
	- empties the stylesheet of all its contents

	*/

	function sheetForTag(tag) {
	  if (tag.sheet) {
	    return tag.sheet;
	  } // this weirdness brought to you by firefox

	  /* istanbul ignore next */


	  for (var i = 0; i < document.styleSheets.length; i++) {
	    if (document.styleSheets[i].ownerNode === tag) {
	      return document.styleSheets[i];
	    }
	  } // this function should always return with a value
	  // TS can't understand it though so we make it stop complaining here


	  return undefined;
	}

	function createStyleElement(options) {
	  var tag = document.createElement('style');
	  tag.setAttribute('data-emotion', options.key);

	  if (options.nonce !== undefined) {
	    tag.setAttribute('nonce', options.nonce);
	  }

	  tag.appendChild(document.createTextNode(''));
	  tag.setAttribute('data-s', '');
	  return tag;
	}

	var StyleSheet = /*#__PURE__*/function () {
	  // Using Node instead of HTMLElement since container may be a ShadowRoot
	  function StyleSheet(options) {
	    var _this = this;

	    this._insertTag = function (tag) {
	      var before;

	      if (_this.tags.length === 0) {
	        if (_this.insertionPoint) {
	          before = _this.insertionPoint.nextSibling;
	        } else if (_this.prepend) {
	          before = _this.container.firstChild;
	        } else {
	          before = _this.before;
	        }
	      } else {
	        before = _this.tags[_this.tags.length - 1].nextSibling;
	      }

	      _this.container.insertBefore(tag, before);

	      _this.tags.push(tag);
	    };

	    this.isSpeedy = options.speedy === undefined ? true : options.speedy;
	    this.tags = [];
	    this.ctr = 0;
	    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

	    this.key = options.key;
	    this.container = options.container;
	    this.prepend = options.prepend;
	    this.insertionPoint = options.insertionPoint;
	    this.before = null;
	  }

	  var _proto = StyleSheet.prototype;

	  _proto.hydrate = function hydrate(nodes) {
	    nodes.forEach(this._insertTag);
	  };

	  _proto.insert = function insert(rule) {
	    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
	    // it's 1 in dev because we insert source maps that map a single rule to a location
	    // and you can only have one source map per style tag
	    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
	      this._insertTag(createStyleElement(this));
	    }

	    var tag = this.tags[this.tags.length - 1];

	    if (this.isSpeedy) {
	      var sheet = sheetForTag(tag);

	      try {
	        // this is the ultrafast version, works across browsers
	        // the big drawback is that the css won't be editable in devtools
	        sheet.insertRule(rule, sheet.cssRules.length);
	      } catch (e) {
	      }
	    } else {
	      tag.appendChild(document.createTextNode(rule));
	    }

	    this.ctr++;
	  };

	  _proto.flush = function flush() {
	    this.tags.forEach(function (tag) {
	      var _tag$parentNode;

	      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
	    });
	    this.tags = [];
	    this.ctr = 0;
	  };

	  return StyleSheet;
	}();

	var MS = '-ms-';
	var MOZ = '-moz-';
	var WEBKIT = '-webkit-';

	var COMMENT = 'comm';
	var RULESET = 'rule';
	var DECLARATION = 'decl';
	var IMPORT = '@import';
	var KEYFRAMES = '@keyframes';
	var LAYER = '@layer';

	/**
	 * @param {number}
	 * @return {number}
	 */
	var abs = Math.abs;

	/**
	 * @param {number}
	 * @return {string}
	 */
	var from = String.fromCharCode;

	/**
	 * @param {object}
	 * @return {object}
	 */
	var assign = Object.assign;

	/**
	 * @param {string} value
	 * @param {number} length
	 * @return {number}
	 */
	function hash (value, length) {
		return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
	}

	/**
	 * @param {string} value
	 * @return {string}
	 */
	function trim (value) {
		return value.trim()
	}

	/**
	 * @param {string} value
	 * @param {RegExp} pattern
	 * @return {string?}
	 */
	function match (value, pattern) {
		return (value = pattern.exec(value)) ? value[0] : value
	}

	/**
	 * @param {string} value
	 * @param {(string|RegExp)} pattern
	 * @param {string} replacement
	 * @return {string}
	 */
	function replace (value, pattern, replacement) {
		return value.replace(pattern, replacement)
	}

	/**
	 * @param {string} value
	 * @param {string} search
	 * @return {number}
	 */
	function indexof (value, search) {
		return value.indexOf(search)
	}

	/**
	 * @param {string} value
	 * @param {number} index
	 * @return {number}
	 */
	function charat (value, index) {
		return value.charCodeAt(index) | 0
	}

	/**
	 * @param {string} value
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function substr (value, begin, end) {
		return value.slice(begin, end)
	}

	/**
	 * @param {string} value
	 * @return {number}
	 */
	function strlen (value) {
		return value.length
	}

	/**
	 * @param {any[]} value
	 * @return {number}
	 */
	function sizeof (value) {
		return value.length
	}

	/**
	 * @param {any} value
	 * @param {any[]} array
	 * @return {any}
	 */
	function append (value, array) {
		return array.push(value), value
	}

	/**
	 * @param {string[]} array
	 * @param {function} callback
	 * @return {string}
	 */
	function combine (array, callback) {
		return array.map(callback).join('')
	}

	var line = 1;
	var column = 1;
	var length = 0;
	var position = 0;
	var character = 0;
	var characters = '';

	/**
	 * @param {string} value
	 * @param {object | null} root
	 * @param {object | null} parent
	 * @param {string} type
	 * @param {string[] | string} props
	 * @param {object[] | string} children
	 * @param {number} length
	 */
	function node$1 (value, root, parent, type, props, children, length) {
		return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
	}

	/**
	 * @param {object} root
	 * @param {object} props
	 * @return {object}
	 */
	function copy (root, props) {
		return assign(node$1('', null, null, '', null, null, 0), root, {length: -root.length}, props)
	}

	/**
	 * @return {number}
	 */
	function char () {
		return character
	}

	/**
	 * @return {number}
	 */
	function prev () {
		character = position > 0 ? charat(characters, --position) : 0;

		if (column--, character === 10)
			column = 1, line--;

		return character
	}

	/**
	 * @return {number}
	 */
	function next () {
		character = position < length ? charat(characters, position++) : 0;

		if (column++, character === 10)
			column = 1, line++;

		return character
	}

	/**
	 * @return {number}
	 */
	function peek () {
		return charat(characters, position)
	}

	/**
	 * @return {number}
	 */
	function caret () {
		return position
	}

	/**
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function slice (begin, end) {
		return substr(characters, begin, end)
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function token (type) {
		switch (type) {
			// \0 \t \n \r \s whitespace token
			case 0: case 9: case 10: case 13: case 32:
				return 5
			// ! + , / > @ ~ isolate token
			case 33: case 43: case 44: case 47: case 62: case 64: case 126:
			// ; { } breakpoint token
			case 59: case 123: case 125:
				return 4
			// : accompanied token
			case 58:
				return 3
			// " ' ( [ opening delimit token
			case 34: case 39: case 40: case 91:
				return 2
			// ) ] closing delimit token
			case 41: case 93:
				return 1
		}

		return 0
	}

	/**
	 * @param {string} value
	 * @return {any[]}
	 */
	function alloc (value) {
		return line = column = 1, length = strlen(characters = value), position = 0, []
	}

	/**
	 * @param {any} value
	 * @return {any}
	 */
	function dealloc (value) {
		return characters = '', value
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function delimit (type) {
		return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function whitespace (type) {
		while (character = peek())
			if (character < 33)
				next();
			else
				break

		return token(type) > 2 || token(character) > 3 ? '' : ' '
	}

	/**
	 * @param {number} index
	 * @param {number} count
	 * @return {string}
	 */
	function escaping (index, count) {
		while (--count && next())
			// not 0-9 A-F a-f
			if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
				break

		return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function delimiter (type) {
		while (next())
			switch (character) {
				// ] ) " '
				case type:
					return position
				// " '
				case 34: case 39:
					if (type !== 34 && type !== 39)
						delimiter(character);
					break
				// (
				case 40:
					if (type === 41)
						delimiter(type);
					break
				// \
				case 92:
					next();
					break
			}

		return position
	}

	/**
	 * @param {number} type
	 * @param {number} index
	 * @return {number}
	 */
	function commenter (type, index) {
		while (next())
			// //
			if (type + character === 47 + 10)
				break
			// /*
			else if (type + character === 42 + 42 && peek() === 47)
				break

		return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
	}

	/**
	 * @param {number} index
	 * @return {string}
	 */
	function identifier (index) {
		while (!token(peek()))
			next();

		return slice(index, position)
	}

	/**
	 * @param {string} value
	 * @return {object[]}
	 */
	function compile (value) {
		return dealloc(parse$1('', null, null, null, [''], value = alloc(value), 0, [0], value))
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {string[]} rule
	 * @param {string[]} rules
	 * @param {string[]} rulesets
	 * @param {number[]} pseudo
	 * @param {number[]} points
	 * @param {string[]} declarations
	 * @return {object}
	 */
	function parse$1 (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
		var index = 0;
		var offset = 0;
		var length = pseudo;
		var atrule = 0;
		var property = 0;
		var previous = 0;
		var variable = 1;
		var scanning = 1;
		var ampersand = 1;
		var character = 0;
		var type = '';
		var props = rules;
		var children = rulesets;
		var reference = rule;
		var characters = type;

		while (scanning)
			switch (previous = character, character = next()) {
				// (
				case 40:
					if (previous != 108 && charat(characters, length - 1) == 58) {
						if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
							ampersand = -1;
						break
					}
				// " ' [
				case 34: case 39: case 91:
					characters += delimit(character);
					break
				// \t \n \r \s
				case 9: case 10: case 13: case 32:
					characters += whitespace(previous);
					break
				// \
				case 92:
					characters += escaping(caret() - 1, 7);
					continue
				// /
				case 47:
					switch (peek()) {
						case 42: case 47:
							append(comment(commenter(next(), caret()), root, parent), declarations);
							break
						default:
							characters += '/';
					}
					break
				// {
				case 123 * variable:
					points[index++] = strlen(characters) * ampersand;
				// } ; \0
				case 125 * variable: case 59: case 0:
					switch (character) {
						// \0 }
						case 0: case 125: scanning = 0;
						// ;
						case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
							if (property > 0 && (strlen(characters) - length))
								append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
							break
						// @ ;
						case 59: characters += ';';
						// { rule/at-rule
						default:
							append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

							if (character === 123)
								if (offset === 0)
									parse$1(characters, root, reference, reference, props, rulesets, length, points, children);
								else
									switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
										// d l m s
										case 100: case 108: case 109: case 115:
											parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
											break
										default:
											parse$1(characters, reference, reference, reference, [''], children, 0, points, children);
									}
					}

					index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
					break
				// :
				case 58:
					length = 1 + strlen(characters), property = previous;
				default:
					if (variable < 1)
						if (character == 123)
							--variable;
						else if (character == 125 && variable++ == 0 && prev() == 125)
							continue

					switch (characters += from(character), character * variable) {
						// &
						case 38:
							ampersand = offset > 0 ? 1 : (characters += '\f', -1);
							break
						// ,
						case 44:
							points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
							break
						// @
						case 64:
							// -
							if (peek() === 45)
								characters += delimit(next());

							atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
							break
						// -
						case 45:
							if (previous === 45 && strlen(characters) == 2)
								variable = 0;
					}
			}

		return rulesets
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} index
	 * @param {number} offset
	 * @param {string[]} rules
	 * @param {number[]} points
	 * @param {string} type
	 * @param {string[]} props
	 * @param {string[]} children
	 * @param {number} length
	 * @return {object}
	 */
	function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
		var post = offset - 1;
		var rule = offset === 0 ? rules : [''];
		var size = sizeof(rule);

		for (var i = 0, j = 0, k = 0; i < index; ++i)
			for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
				if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
					props[k++] = z;

		return node$1(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
	}

	/**
	 * @param {number} value
	 * @param {object} root
	 * @param {object?} parent
	 * @return {object}
	 */
	function comment (value, root, parent) {
		return node$1(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} length
	 * @return {object}
	 */
	function declaration (value, root, parent, length) {
		return node$1(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
	}

	/**
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function serialize (children, callback) {
		var output = '';
		var length = sizeof(children);

		for (var i = 0; i < length; i++)
			output += callback(children[i], i, children, callback) || '';

		return output
	}

	/**
	 * @param {object} element
	 * @param {number} index
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function stringify$1 (element, index, children, callback) {
		switch (element.type) {
			case LAYER: if (element.children.length) break
			case IMPORT: case DECLARATION: return element.return = element.return || element.value
			case COMMENT: return ''
			case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
			case RULESET: element.value = element.props.join(',');
		}

		return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
	}

	/**
	 * @param {function[]} collection
	 * @return {function}
	 */
	function middleware (collection) {
		var length = sizeof(collection);

		return function (element, index, children, callback) {
			var output = '';

			for (var i = 0; i < length; i++)
				output += collection[i](element, index, children, callback) || '';

			return output
		}
	}

	/**
	 * @param {function} callback
	 * @return {function}
	 */
	function rulesheet (callback) {
		return function (element) {
			if (!element.root)
				if (element = element.return)
					callback(element);
		}
	}

	var weakMemoize = function weakMemoize(func) {
	  var cache = new WeakMap();
	  return function (arg) {
	    if (cache.has(arg)) {
	      // Use non-null assertion because we just checked that the cache `has` it
	      // This allows us to remove `undefined` from the return value
	      return cache.get(arg);
	    }

	    var ret = func(arg);
	    cache.set(arg, ret);
	    return ret;
	  };
	};

	function memoize(fn) {
	  var cache = Object.create(null);
	  return function (arg) {
	    if (cache[arg] === undefined) cache[arg] = fn(arg);
	    return cache[arg];
	  };
	}

	var isBrowser$4 = typeof document !== 'undefined';

	var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
	  var previous = 0;
	  var character = 0;

	  while (true) {
	    previous = character;
	    character = peek(); // &\f

	    if (previous === 38 && character === 12) {
	      points[index] = 1;
	    }

	    if (token(character)) {
	      break;
	    }

	    next();
	  }

	  return slice(begin, position);
	};

	var toRules = function toRules(parsed, points) {
	  // pretend we've started with a comma
	  var index = -1;
	  var character = 44;

	  do {
	    switch (token(character)) {
	      case 0:
	        // &\f
	        if (character === 38 && peek() === 12) {
	          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
	          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
	          // and when it should just concatenate the outer and inner selectors
	          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
	          points[index] = 1;
	        }

	        parsed[index] += identifierWithPointTracking(position - 1, points, index);
	        break;

	      case 2:
	        parsed[index] += delimit(character);
	        break;

	      case 4:
	        // comma
	        if (character === 44) {
	          // colon
	          parsed[++index] = peek() === 58 ? '&\f' : '';
	          points[index] = parsed[index].length;
	          break;
	        }

	      // fallthrough

	      default:
	        parsed[index] += from(character);
	    }
	  } while (character = next());

	  return parsed;
	};

	var getRules = function getRules(value, points) {
	  return dealloc(toRules(alloc(value), points));
	}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


	var fixedElements = /* #__PURE__ */new WeakMap();
	var compat = function compat(element) {
	  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
	  // negative .length indicates that this rule has been already prefixed
	  element.length < 1) {
	    return;
	  }

	  var value = element.value;
	  var parent = element.parent;
	  var isImplicitRule = element.column === parent.column && element.line === parent.line;

	  while (parent.type !== 'rule') {
	    parent = parent.parent;
	    if (!parent) return;
	  } // short-circuit for the simplest case


	  if (element.props.length === 1 && value.charCodeAt(0) !== 58
	  /* colon */
	  && !fixedElements.get(parent)) {
	    return;
	  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
	  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


	  if (isImplicitRule) {
	    return;
	  }

	  fixedElements.set(element, true);
	  var points = [];
	  var rules = getRules(value, points);
	  var parentRules = parent.props;

	  for (var i = 0, k = 0; i < rules.length; i++) {
	    for (var j = 0; j < parentRules.length; j++, k++) {
	      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
	    }
	  }
	};
	var removeLabel = function removeLabel(element) {
	  if (element.type === 'decl') {
	    var value = element.value;

	    if ( // charcode for l
	    value.charCodeAt(0) === 108 && // charcode for b
	    value.charCodeAt(2) === 98) {
	      // this ignores label
	      element["return"] = '';
	      element.value = '';
	    }
	  }
	};

	/* eslint-disable no-fallthrough */

	function prefix(value, length) {
	  switch (hash(value, length)) {
	    // color-adjust
	    case 5103:
	      return WEBKIT + 'print-' + value + value;
	    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

	    case 5737:
	    case 4201:
	    case 3177:
	    case 3433:
	    case 1641:
	    case 4457:
	    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

	    case 5572:
	    case 6356:
	    case 5844:
	    case 3191:
	    case 6645:
	    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

	    case 6391:
	    case 5879:
	    case 5623:
	    case 6135:
	    case 4599:
	    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

	    case 4215:
	    case 6389:
	    case 5109:
	    case 5365:
	    case 5621:
	    case 3829:
	      return WEBKIT + value + value;
	    // appearance, user-select, transform, hyphens, text-size-adjust

	    case 5349:
	    case 4246:
	    case 4810:
	    case 6968:
	    case 2756:
	      return WEBKIT + value + MOZ + value + MS + value + value;
	    // flex, flex-direction

	    case 6828:
	    case 4268:
	      return WEBKIT + value + MS + value + value;
	    // order

	    case 6165:
	      return WEBKIT + value + MS + 'flex-' + value + value;
	    // align-items

	    case 5187:
	      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
	    // align-self

	    case 5443:
	      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
	    // align-content

	    case 4675:
	      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
	    // flex-shrink

	    case 5548:
	      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
	    // flex-basis

	    case 5292:
	      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
	    // flex-grow

	    case 6060:
	      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
	    // transition

	    case 4554:
	      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
	    // cursor

	    case 6187:
	      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
	    // background, background-image

	    case 5495:
	    case 3959:
	      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
	    // justify-content

	    case 4968:
	      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
	    // (margin|padding)-inline-(start|end)

	    case 4095:
	    case 3583:
	    case 4068:
	    case 2532:
	      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
	    // (min|max)?(width|height|inline-size|block-size)

	    case 8116:
	    case 7059:
	    case 5753:
	    case 5535:
	    case 5445:
	    case 5701:
	    case 4933:
	    case 4677:
	    case 5533:
	    case 5789:
	    case 5021:
	    case 4765:
	      // stretch, max-content, min-content, fill-available
	      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
	        // (m)ax-content, (m)in-content
	        case 109:
	          // -
	          if (charat(value, length + 4) !== 45) break;
	        // (f)ill-available, (f)it-content

	        case 102:
	          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
	        // (s)tretch

	        case 115:
	          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
	      }
	      break;
	    // position: sticky

	    case 4949:
	      // (s)ticky?
	      if (charat(value, length + 1) !== 115) break;
	    // display: (flex|inline-flex)

	    case 6444:
	      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
	        // stic(k)y
	        case 107:
	          return replace(value, ':', ':' + WEBKIT) + value;
	        // (inline-)?fl(e)x

	        case 101:
	          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
	      }

	      break;
	    // writing-mode

	    case 5936:
	      switch (charat(value, length + 11)) {
	        // vertical-l(r)
	        case 114:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
	        // vertical-r(l)

	        case 108:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
	        // horizontal(-)tb

	        case 45:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
	      }

	      return WEBKIT + value + MS + value + value;
	  }

	  return value;
	}

	var prefixer = function prefixer(element, index, children, callback) {
	  if (element.length > -1) if (!element["return"]) switch (element.type) {
	    case DECLARATION:
	      element["return"] = prefix(element.value, element.length);
	      break;

	    case KEYFRAMES:
	      return serialize([copy(element, {
	        value: replace(element.value, '@', '@' + WEBKIT)
	      })], callback);

	    case RULESET:
	      if (element.length) return combine(element.props, function (value) {
	        switch (match(value, /(::plac\w+|:read-\w+)/)) {
	          // :read-(only|write)
	          case ':read-only':
	          case ':read-write':
	            return serialize([copy(element, {
	              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
	            })], callback);
	          // :placeholder

	          case '::placeholder':
	            return serialize([copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
	            })], callback);
	        }

	        return '';
	      });
	  }
	};

	var getServerStylisCache = isBrowser$4 ? undefined : weakMemoize(function () {
	  return memoize(function () {
	    return {};
	  });
	});
	var defaultStylisPlugins = [prefixer];

	var createCache = function createCache(options) {
	  var key = options.key;

	  if (isBrowser$4 && key === 'css') {
	    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
	    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
	    // note this very very intentionally targets all style elements regardless of the key to ensure
	    // that creating a cache works inside of render of a React component

	    Array.prototype.forEach.call(ssrStyles, function (node) {
	      // we want to only move elements which have a space in the data-emotion attribute value
	      // because that indicates that it is an Emotion 11 server-side rendered style elements
	      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
	      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
	      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
	      // will not result in the Emotion 10 styles being destroyed
	      var dataEmotionAttribute = node.getAttribute('data-emotion');

	      if (dataEmotionAttribute.indexOf(' ') === -1) {
	        return;
	      }

	      document.head.appendChild(node);
	      node.setAttribute('data-s', '');
	    });
	  }

	  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

	  var inserted = {};
	  var container;
	  var nodesToHydrate = [];

	  if (isBrowser$4) {
	    container = options.container || document.head;
	    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
	    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
	    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
	      var attrib = node.getAttribute("data-emotion").split(' ');

	      for (var i = 1; i < attrib.length; i++) {
	        inserted[attrib[i]] = true;
	      }

	      nodesToHydrate.push(node);
	    });
	  }

	  var _insert;

	  var omnipresentPlugins = [compat, removeLabel];

	  if (!getServerStylisCache) {
	    var currentSheet;
	    var finalizingPlugins = [stringify$1, rulesheet(function (rule) {
	      currentSheet.insert(rule);
	    })];
	    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

	    var stylis = function stylis(styles) {
	      return serialize(compile(styles), serializer);
	    };

	    _insert = function insert(selector, serialized, sheet, shouldCache) {
	      currentSheet = sheet;

	      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

	      if (shouldCache) {
	        cache.inserted[serialized.name] = true;
	      }
	    };
	  } else {
	    var _finalizingPlugins = [stringify$1];

	    var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

	    var _stylis = function _stylis(styles) {
	      return serialize(compile(styles), _serializer);
	    };

	    var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

	    var getRules = function getRules(selector, serialized) {
	      var name = serialized.name;

	      if (serverStylisCache[name] === undefined) {
	        serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
	      }

	      return serverStylisCache[name];
	    };

	    _insert = function _insert(selector, serialized, sheet, shouldCache) {
	      var name = serialized.name;
	      var rules = getRules(selector, serialized);

	      if (cache.compat === undefined) {
	        // in regular mode, we don't set the styles on the inserted cache
	        // since we don't need to and that would be wasting memory
	        // we return them so that they are rendered in a style tag
	        if (shouldCache) {
	          cache.inserted[name] = true;
	        }

	        return rules;
	      } else {
	        // in compat mode, we put the styles on the inserted cache so
	        // that emotion-server can pull out the styles
	        // except when we don't want to cache it which was in Global but now
	        // is nowhere but we don't want to do a major right now
	        // and just in case we're going to leave the case here
	        // it's also not affecting client side bundle size
	        // so it's really not a big deal
	        if (shouldCache) {
	          cache.inserted[name] = rules;
	        } else {
	          return rules;
	        }
	      }
	    };
	  }

	  var cache = {
	    key: key,
	    sheet: new StyleSheet({
	      key: key,
	      container: container,
	      nonce: options.nonce,
	      speedy: options.speedy,
	      prepend: options.prepend,
	      insertionPoint: options.insertionPoint
	    }),
	    nonce: options.nonce,
	    inserted: inserted,
	    registered: {},
	    insert: _insert
	  };
	  cache.sheet.hydrate(nodesToHydrate);
	  return cache;
	};

	var reactIs = {exports: {}};

	var reactIs_production_min = {};

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactIs_production_min;

	function requireReactIs_production_min () {
		if (hasRequiredReactIs_production_min) return reactIs_production_min;
		hasRequiredReactIs_production_min = 1;
	var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
		Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
		function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
		reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
		reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
		reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
		return reactIs_production_min;
	}

	var hasRequiredReactIs;

	function requireReactIs () {
		if (hasRequiredReactIs) return reactIs.exports;
		hasRequiredReactIs = 1;

		{
		  reactIs.exports = requireReactIs_production_min();
		}
		return reactIs.exports;
	}

	var hoistNonReactStatics_cjs;
	var hasRequiredHoistNonReactStatics_cjs;

	function requireHoistNonReactStatics_cjs () {
		if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
		hasRequiredHoistNonReactStatics_cjs = 1;

		var reactIs = requireReactIs();

		/**
		 * Copyright 2015, Yahoo! Inc.
		 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
		 */
		var REACT_STATICS = {
		  childContextTypes: true,
		  contextType: true,
		  contextTypes: true,
		  defaultProps: true,
		  displayName: true,
		  getDefaultProps: true,
		  getDerivedStateFromError: true,
		  getDerivedStateFromProps: true,
		  mixins: true,
		  propTypes: true,
		  type: true
		};
		var KNOWN_STATICS = {
		  name: true,
		  length: true,
		  prototype: true,
		  caller: true,
		  callee: true,
		  arguments: true,
		  arity: true
		};
		var FORWARD_REF_STATICS = {
		  '$$typeof': true,
		  render: true,
		  defaultProps: true,
		  displayName: true,
		  propTypes: true
		};
		var MEMO_STATICS = {
		  '$$typeof': true,
		  compare: true,
		  defaultProps: true,
		  displayName: true,
		  propTypes: true,
		  type: true
		};
		var TYPE_STATICS = {};
		TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
		TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

		function getStatics(component) {
		  // React v16.11 and below
		  if (reactIs.isMemo(component)) {
		    return MEMO_STATICS;
		  } // React v16.12 and above


		  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
		}

		var defineProperty = Object.defineProperty;
		var getOwnPropertyNames = Object.getOwnPropertyNames;
		var getOwnPropertySymbols = Object.getOwnPropertySymbols;
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
		var getPrototypeOf = Object.getPrototypeOf;
		var objectPrototype = Object.prototype;
		function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
		  if (typeof sourceComponent !== 'string') {
		    // don't hoist over string (html) components
		    if (objectPrototype) {
		      var inheritedComponent = getPrototypeOf(sourceComponent);

		      if (inheritedComponent && inheritedComponent !== objectPrototype) {
		        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
		      }
		    }

		    var keys = getOwnPropertyNames(sourceComponent);

		    if (getOwnPropertySymbols) {
		      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
		    }

		    var targetStatics = getStatics(targetComponent);
		    var sourceStatics = getStatics(sourceComponent);

		    for (var i = 0; i < keys.length; ++i) {
		      var key = keys[i];

		      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
		        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

		        try {
		          // Avoid failures from read-only properties
		          defineProperty(targetComponent, key, descriptor);
		        } catch (e) {}
		      }
		    }
		  }

		  return targetComponent;
		}

		hoistNonReactStatics_cjs = hoistNonReactStatics;
		return hoistNonReactStatics_cjs;
	}

	requireHoistNonReactStatics_cjs();

	var isBrowser$3 = typeof document !== 'undefined';

	function getRegisteredStyles(registered, registeredStyles, classNames) {
	  var rawClassName = '';
	  classNames.split(' ').forEach(function (className) {
	    if (registered[className] !== undefined) {
	      registeredStyles.push(registered[className] + ";");
	    } else if (className) {
	      rawClassName += className + " ";
	    }
	  });
	  return rawClassName;
	}
	var registerStyles = function registerStyles(cache, serialized, isStringTag) {
	  var className = cache.key + "-" + serialized.name;

	  if ( // we only need to add the styles to the registered cache if the
	  // class name could be used further down
	  // the tree but if it's a string tag, we know it won't
	  // so we don't have to add it to registered cache.
	  // this improves memory usage since we can avoid storing the whole style string
	  (isStringTag === false || // we need to always store it if we're in compat mode and
	  // in node since emotion-server relies on whether a style is in
	  // the registered cache to know whether a style is global or not
	  // also, note that this check will be dead code eliminated in the browser
	  isBrowser$3 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
	    cache.registered[className] = serialized.styles;
	  }
	};
	var insertStyles = function insertStyles(cache, serialized, isStringTag) {
	  registerStyles(cache, serialized, isStringTag);
	  var className = cache.key + "-" + serialized.name;

	  if (cache.inserted[serialized.name] === undefined) {
	    var stylesForSSR = '';
	    var current = serialized;

	    do {
	      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

	      if (!isBrowser$3 && maybeStyles !== undefined) {
	        stylesForSSR += maybeStyles;
	      }

	      current = current.next;
	    } while (current !== undefined);

	    if (!isBrowser$3 && stylesForSSR.length !== 0) {
	      return stylesForSSR;
	    }
	  }
	};

	/* eslint-disable */
	// Inspired by https://github.com/garycourt/murmurhash-js
	// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
	function murmur2(str) {
	  // 'm' and 'r' are mixing constants generated offline.
	  // They're not really 'magic', they just happen to work well.
	  // const m = 0x5bd1e995;
	  // const r = 24;
	  // Initialize the hash
	  var h = 0; // Mix 4 bytes at a time into the hash

	  var k,
	      i = 0,
	      len = str.length;

	  for (; len >= 4; ++i, len -= 4) {
	    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
	    k =
	    /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
	    k ^=
	    /* k >>> r: */
	    k >>> 24;
	    h =
	    /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
	    /* Math.imul(h, m): */
	    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Handle the last few bytes of the input array


	  switch (len) {
	    case 3:
	      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

	    case 2:
	      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

	    case 1:
	      h ^= str.charCodeAt(i) & 0xff;
	      h =
	      /* Math.imul(h, m): */
	      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Do a few final mixes of the hash to ensure the last few
	  // bytes are well-incorporated.


	  h ^= h >>> 13;
	  h =
	  /* Math.imul(h, m): */
	  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  return ((h ^ h >>> 15) >>> 0).toString(36);
	}

	var unitlessKeys = {
	  animationIterationCount: 1,
	  aspectRatio: 1,
	  borderImageOutset: 1,
	  borderImageSlice: 1,
	  borderImageWidth: 1,
	  boxFlex: 1,
	  boxFlexGroup: 1,
	  boxOrdinalGroup: 1,
	  columnCount: 1,
	  columns: 1,
	  flex: 1,
	  flexGrow: 1,
	  flexPositive: 1,
	  flexShrink: 1,
	  flexNegative: 1,
	  flexOrder: 1,
	  gridRow: 1,
	  gridRowEnd: 1,
	  gridRowSpan: 1,
	  gridRowStart: 1,
	  gridColumn: 1,
	  gridColumnEnd: 1,
	  gridColumnSpan: 1,
	  gridColumnStart: 1,
	  msGridRow: 1,
	  msGridRowSpan: 1,
	  msGridColumn: 1,
	  msGridColumnSpan: 1,
	  fontWeight: 1,
	  lineHeight: 1,
	  opacity: 1,
	  order: 1,
	  orphans: 1,
	  scale: 1,
	  tabSize: 1,
	  widows: 1,
	  zIndex: 1,
	  zoom: 1,
	  WebkitLineClamp: 1,
	  // SVG-related properties
	  fillOpacity: 1,
	  floodOpacity: 1,
	  stopOpacity: 1,
	  strokeDasharray: 1,
	  strokeDashoffset: 1,
	  strokeMiterlimit: 1,
	  strokeOpacity: 1,
	  strokeWidth: 1
	};

	var hyphenateRegex = /[A-Z]|^ms/g;
	var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

	var isCustomProperty = function isCustomProperty(property) {
	  return property.charCodeAt(1) === 45;
	};

	var isProcessableValue = function isProcessableValue(value) {
	  return value != null && typeof value !== 'boolean';
	};

	var processStyleName = /* #__PURE__ */memoize(function (styleName) {
	  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
	});

	var processStyleValue = function processStyleValue(key, value) {
	  switch (key) {
	    case 'animation':
	    case 'animationName':
	      {
	        if (typeof value === 'string') {
	          return value.replace(animationRegex, function (match, p1, p2) {
	            cursor = {
	              name: p1,
	              styles: p2,
	              next: cursor
	            };
	            return p1;
	          });
	        }
	      }
	  }

	  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
	    return value + 'px';
	  }

	  return value;
	};

	function handleInterpolation(mergedProps, registered, interpolation) {
	  if (interpolation == null) {
	    return '';
	  }

	  var componentSelector = interpolation;

	  if (componentSelector.__emotion_styles !== undefined) {

	    return componentSelector;
	  }

	  switch (typeof interpolation) {
	    case 'boolean':
	      {
	        return '';
	      }

	    case 'object':
	      {
	        var keyframes = interpolation;

	        if (keyframes.anim === 1) {
	          cursor = {
	            name: keyframes.name,
	            styles: keyframes.styles,
	            next: cursor
	          };
	          return keyframes.name;
	        }

	        var serializedStyles = interpolation;

	        if (serializedStyles.styles !== undefined) {
	          var next = serializedStyles.next;

	          if (next !== undefined) {
	            // not the most efficient thing ever but this is a pretty rare case
	            // and there will be very few iterations of this generally
	            while (next !== undefined) {
	              cursor = {
	                name: next.name,
	                styles: next.styles,
	                next: cursor
	              };
	              next = next.next;
	            }
	          }

	          var styles = serializedStyles.styles + ";";
	          return styles;
	        }

	        return createStringFromObject(mergedProps, registered, interpolation);
	      }

	    case 'function':
	      {
	        if (mergedProps !== undefined) {
	          var previousCursor = cursor;
	          var result = interpolation(mergedProps);
	          cursor = previousCursor;
	          return handleInterpolation(mergedProps, registered, result);
	        }

	        break;
	      }
	  } // finalize string values (regular strings and functions interpolated into css calls)


	  var asString = interpolation;

	  if (registered == null) {
	    return asString;
	  }

	  var cached = registered[asString];
	  return cached !== undefined ? cached : asString;
	}

	function createStringFromObject(mergedProps, registered, obj) {
	  var string = '';

	  if (Array.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
	    }
	  } else {
	    for (var key in obj) {
	      var value = obj[key];

	      if (typeof value !== 'object') {
	        var asString = value;

	        if (registered != null && registered[asString] !== undefined) {
	          string += key + "{" + registered[asString] + "}";
	        } else if (isProcessableValue(asString)) {
	          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
	        }
	      } else {

	        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
	          for (var _i = 0; _i < value.length; _i++) {
	            if (isProcessableValue(value[_i])) {
	              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
	            }
	          }
	        } else {
	          var interpolated = handleInterpolation(mergedProps, registered, value);

	          switch (key) {
	            case 'animation':
	            case 'animationName':
	              {
	                string += processStyleName(key) + ":" + interpolated + ";";
	                break;
	              }

	            default:
	              {

	                string += key + "{" + interpolated + "}";
	              }
	          }
	        }
	      }
	    }
	  }

	  return string;
	}

	var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
	// keyframes are stored on the SerializedStyles object as a linked list

	var cursor;
	function serializeStyles(args, registered, mergedProps) {
	  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
	    return args[0];
	  }

	  var stringMode = true;
	  var styles = '';
	  cursor = undefined;
	  var strings = args[0];

	  if (strings == null || strings.raw === undefined) {
	    stringMode = false;
	    styles += handleInterpolation(mergedProps, registered, strings);
	  } else {
	    var asTemplateStringsArr = strings;

	    styles += asTemplateStringsArr[0];
	  } // we start at 1 since we've already handled the first arg


	  for (var i = 1; i < args.length; i++) {
	    styles += handleInterpolation(mergedProps, registered, args[i]);

	    if (stringMode) {
	      var templateStringsArr = strings;

	      styles += templateStringsArr[i];
	    }
	  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


	  labelPattern.lastIndex = 0;
	  var identifierName = '';
	  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

	  while ((match = labelPattern.exec(styles)) !== null) {
	    identifierName += '-' + match[1];
	  }

	  var name = murmur2(styles) + identifierName;

	  return {
	    name: name,
	    styles: styles,
	    next: cursor
	  };
	}

	var isBrowser$2 = typeof document !== 'undefined';

	var syncFallback = function syncFallback(create) {
	  return create();
	};

	var useInsertionEffect = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
	var useInsertionEffectAlwaysWithSyncFallback = !isBrowser$2 ? syncFallback : useInsertionEffect || syncFallback;
	var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;

	var isBrowser$1 = typeof document !== 'undefined';

	var EmotionCacheContext = /* #__PURE__ */reactExports.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
	// because this module is primarily intended for the browser and node
	// but it's also required in react native and similar environments sometimes
	// and we could have a special build just for that
	// but this is much easier and the native packages
	// might use a different theme context in the future anyway
	typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
	  key: 'css'
	}) : null);

	EmotionCacheContext.Provider;

	var withEmotionCache = function withEmotionCache(func) {
	  return /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
	    // the cache will never be null in the browser
	    var cache = reactExports.useContext(EmotionCacheContext);
	    return func(props, cache, ref);
	  });
	};

	if (!isBrowser$1) {
	  withEmotionCache = function withEmotionCache(func) {
	    return function (props) {
	      var cache = reactExports.useContext(EmotionCacheContext);

	      if (cache === null) {
	        // yes, we're potentially creating this on every render
	        // it doesn't actually matter though since it's only on the server
	        // so there will only every be a single render
	        // that could change in the future because of suspense and etc. but for now,
	        // this works and i don't want to optimise for a future thing that we aren't sure about
	        cache = createCache({
	          key: 'css'
	        });
	        return /*#__PURE__*/reactExports.createElement(EmotionCacheContext.Provider, {
	          value: cache
	        }, func(props, cache));
	      } else {
	        return func(props, cache);
	      }
	    };
	  };
	}

	var ThemeContext = /* #__PURE__ */reactExports.createContext({});

	var hasOwn = {}.hasOwnProperty;

	var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
	var createEmotionProps = function createEmotionProps(type, props) {

	  var newProps = {};

	  for (var _key in props) {
	    if (hasOwn.call(props, _key)) {
	      newProps[_key] = props[_key];
	    }
	  }

	  newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:

	  return newProps;
	};

	var Insertion$1 = function Insertion(_ref) {
	  var cache = _ref.cache,
	      serialized = _ref.serialized,
	      isStringTag = _ref.isStringTag;
	  registerStyles(cache, serialized, isStringTag);
	  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
	    return insertStyles(cache, serialized, isStringTag);
	  });

	  if (!isBrowser$1 && rules !== undefined) {
	    var _ref2;

	    var serializedNames = serialized.name;
	    var next = serialized.next;

	    while (next !== undefined) {
	      serializedNames += ' ' + next.name;
	      next = next.next;
	    }

	    return /*#__PURE__*/reactExports.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
	      __html: rules
	    }, _ref2.nonce = cache.sheet.nonce, _ref2));
	  }

	  return null;
	};

	var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
	  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
	  // not passing the registered cache to serializeStyles because it would
	  // make certain babel optimisations not possible

	  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
	    cssProp = cache.registered[cssProp];
	  }

	  var WrappedComponent = props[typePropName];
	  var registeredStyles = [cssProp];
	  var className = '';

	  if (typeof props.className === 'string') {
	    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
	  } else if (props.className != null) {
	    className = props.className + " ";
	  }

	  var serialized = serializeStyles(registeredStyles, undefined, reactExports.useContext(ThemeContext));

	  className += cache.key + "-" + serialized.name;
	  var newProps = {};

	  for (var _key2 in props) {
	    if (hasOwn.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && (true )) {
	      newProps[_key2] = props[_key2];
	    }
	  }

	  newProps.className = className;

	  if (ref) {
	    newProps.ref = ref;
	  }

	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion$1, {
	    cache: cache,
	    serialized: serialized,
	    isStringTag: typeof WrappedComponent === 'string'
	  }), /*#__PURE__*/reactExports.createElement(WrappedComponent, newProps));
	});

	var Emotion$1 = Emotion;

	var jsx = function jsx(type, props) {
	  // eslint-disable-next-line prefer-rest-params
	  var args = arguments;

	  if (props == null || !hasOwn.call(props, 'css')) {
	    return reactExports.createElement.apply(undefined, args);
	  }

	  var argsLength = args.length;
	  var createElementArgArray = new Array(argsLength);
	  createElementArgArray[0] = Emotion$1;
	  createElementArgArray[1] = createEmotionProps(type, props);

	  for (var i = 2; i < argsLength; i++) {
	    createElementArgArray[i] = args[i];
	  }

	  return reactExports.createElement.apply(null, createElementArgArray);
	};

	(function (_jsx) {
	  var JSX;

	  (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
	})(jsx || (jsx = {}));

	// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
	// initial client-side render from SSR, use place of hydrating tag

	var Global = /* #__PURE__ */withEmotionCache(function (props, cache) {

	  var styles = props.styles;
	  var serialized = serializeStyles([styles], undefined, reactExports.useContext(ThemeContext));

	  if (!isBrowser$1) {
	    var _ref;

	    var serializedNames = serialized.name;
	    var serializedStyles = serialized.styles;
	    var next = serialized.next;

	    while (next !== undefined) {
	      serializedNames += ' ' + next.name;
	      serializedStyles += next.styles;
	      next = next.next;
	    }

	    var shouldCache = cache.compat === true;
	    var rules = cache.insert("", {
	      name: serializedNames,
	      styles: serializedStyles
	    }, cache.sheet, shouldCache);

	    if (shouldCache) {
	      return null;
	    }

	    return /*#__PURE__*/reactExports.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
	      __html: rules
	    }, _ref.nonce = cache.sheet.nonce, _ref));
	  } // yes, i know these hooks are used conditionally
	  // but it is based on a constant that will never change at runtime
	  // it's effectively like having two implementations and switching them out
	  // so it's not actually breaking anything


	  var sheetRef = reactExports.useRef();
	  useInsertionEffectWithLayoutFallback(function () {
	    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

	    var sheet = new cache.sheet.constructor({
	      key: key,
	      nonce: cache.sheet.nonce,
	      container: cache.sheet.container,
	      speedy: cache.sheet.isSpeedy
	    });
	    var rehydrating = false;
	    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

	    if (cache.sheet.tags.length) {
	      sheet.before = cache.sheet.tags[0];
	    }

	    if (node !== null) {
	      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

	      node.setAttribute('data-emotion', key);
	      sheet.hydrate([node]);
	    }

	    sheetRef.current = [sheet, rehydrating];
	    return function () {
	      sheet.flush();
	    };
	  }, [cache]);
	  useInsertionEffectWithLayoutFallback(function () {
	    var sheetRefCurrent = sheetRef.current;
	    var sheet = sheetRefCurrent[0],
	        rehydrating = sheetRefCurrent[1];

	    if (rehydrating) {
	      sheetRefCurrent[1] = false;
	      return;
	    }

	    if (serialized.next !== undefined) {
	      // insert keyframes
	      insertStyles(cache, serialized.next, true);
	    }

	    if (sheet.tags.length) {
	      // if this doesn't exist then it will be null so the style element will be appended
	      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
	      sheet.before = element;
	      sheet.flush();
	    }

	    cache.insert("", serialized, sheet, false);
	  }, [cache, serialized.name]);
	  return null;
	});

	function css$2() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return serializeStyles(args);
	}

	function keyframes() {
	  var insertable = css$2.apply(void 0, arguments);
	  var name = "animation-" + insertable.name;
	  return {
	    name: name,
	    styles: "@keyframes " + name + "{" + insertable.styles + "}",
	    anim: 1,
	    toString: function toString() {
	      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
	    }
	  };
	}

	// eslint-disable-next-line no-undef
	var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

	var isPropValid = /* #__PURE__ */memoize(function (prop) {
	  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
	  /* o */
	  && prop.charCodeAt(1) === 110
	  /* n */
	  && prop.charCodeAt(2) < 91;
	}
	/* Z+1 */
	);

	var isBrowser = typeof document !== 'undefined';

	var testOmitPropsOnStringTag = isPropValid;

	var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
	  return key !== 'theme';
	};

	var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
	  return typeof tag === 'string' && // 96 is one less than the char code
	  // for "a" so this is checking that
	  // it's a lowercase character
	  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
	};
	var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
	  var shouldForwardProp;

	  if (options) {
	    var optionsShouldForwardProp = options.shouldForwardProp;
	    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
	      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
	    } : optionsShouldForwardProp;
	  }

	  if (typeof shouldForwardProp !== 'function' && isReal) {
	    shouldForwardProp = tag.__emotion_forwardProp;
	  }

	  return shouldForwardProp;
	};

	var Insertion = function Insertion(_ref) {
	  var cache = _ref.cache,
	      serialized = _ref.serialized,
	      isStringTag = _ref.isStringTag;
	  registerStyles(cache, serialized, isStringTag);
	  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
	    return insertStyles(cache, serialized, isStringTag);
	  });

	  if (!isBrowser && rules !== undefined) {
	    var _ref2;

	    var serializedNames = serialized.name;
	    var next = serialized.next;

	    while (next !== undefined) {
	      serializedNames += ' ' + next.name;
	      next = next.next;
	    }

	    return /*#__PURE__*/reactExports.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
	      __html: rules
	    }, _ref2.nonce = cache.sheet.nonce, _ref2));
	  }

	  return null;
	};

	var createStyled$1 = function createStyled(tag, options) {

	  var isReal = tag.__emotion_real === tag;
	  var baseTag = isReal && tag.__emotion_base || tag;
	  var identifierName;
	  var targetClassName;

	  if (options !== undefined) {
	    identifierName = options.label;
	    targetClassName = options.target;
	  }

	  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
	  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
	  var shouldUseAs = !defaultShouldForwardProp('as');
	  return function () {
	    // eslint-disable-next-line prefer-rest-params
	    var args = arguments;
	    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

	    if (identifierName !== undefined) {
	      styles.push("label:" + identifierName + ";");
	    }

	    if (args[0] == null || args[0].raw === undefined) {
	      // eslint-disable-next-line prefer-spread
	      styles.push.apply(styles, args);
	    } else {
	      var templateStringsArr = args[0];

	      styles.push(templateStringsArr[0]);
	      var len = args.length;
	      var i = 1;

	      for (; i < len; i++) {

	        styles.push(args[i], templateStringsArr[i]);
	      }
	    }

	    var Styled = withEmotionCache(function (props, cache, ref) {
	      var FinalTag = shouldUseAs && props.as || baseTag;
	      var className = '';
	      var classInterpolations = [];
	      var mergedProps = props;

	      if (props.theme == null) {
	        mergedProps = {};

	        for (var key in props) {
	          mergedProps[key] = props[key];
	        }

	        mergedProps.theme = reactExports.useContext(ThemeContext);
	      }

	      if (typeof props.className === 'string') {
	        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
	      } else if (props.className != null) {
	        className = props.className + " ";
	      }

	      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
	      className += cache.key + "-" + serialized.name;

	      if (targetClassName !== undefined) {
	        className += " " + targetClassName;
	      }

	      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
	      var newProps = {};

	      for (var _key in props) {
	        if (shouldUseAs && _key === 'as') continue;

	        if (finalShouldForwardProp(_key)) {
	          newProps[_key] = props[_key];
	        }
	      }

	      newProps.className = className;

	      if (ref) {
	        newProps.ref = ref;
	      }

	      return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion, {
	        cache: cache,
	        serialized: serialized,
	        isStringTag: typeof FinalTag === 'string'
	      }), /*#__PURE__*/reactExports.createElement(FinalTag, newProps));
	    });
	    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
	    Styled.defaultProps = tag.defaultProps;
	    Styled.__emotion_real = Styled;
	    Styled.__emotion_base = baseTag;
	    Styled.__emotion_styles = styles;
	    Styled.__emotion_forwardProp = shouldForwardProp;
	    Object.defineProperty(Styled, 'toString', {
	      value: function value() {

	        return "." + targetClassName;
	      }
	    });

	    Styled.withComponent = function (nextTag, nextOptions) {
	      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
	        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
	      }));
	      return newStyled.apply(void 0, styles);
	    };

	    return Styled;
	  };
	};

	var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
	'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

	// bind it to avoid mutating the original function
	var newStyled = createStyled$1.bind(null);
	tags.forEach(function (tagName) {
	  newStyled[tagName] = newStyled(tagName);
	});

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production = {};

	/**
	 * @license React
	 * react-jsx-runtime.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactJsxRuntime_production;

	function requireReactJsxRuntime_production () {
		if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
		hasRequiredReactJsxRuntime_production = 1;
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
		function jsxProd(type, config, maybeKey) {
		  var key = null;
		  void 0 !== maybeKey && (key = "" + maybeKey);
		  void 0 !== config.key && (key = "" + config.key);
		  if ("key" in config) {
		    maybeKey = {};
		    for (var propName in config)
		      "key" !== propName && (maybeKey[propName] = config[propName]);
		  } else maybeKey = config;
		  config = maybeKey.ref;
		  return {
		    $$typeof: REACT_ELEMENT_TYPE,
		    type: type,
		    key: key,
		    ref: void 0 !== config ? config : null,
		    props: maybeKey
		  };
		}
		reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
		reactJsxRuntime_production.jsx = jsxProd;
		reactJsxRuntime_production.jsxs = jsxProd;
		return reactJsxRuntime_production;
	}

	var hasRequiredJsxRuntime;

	function requireJsxRuntime () {
		if (hasRequiredJsxRuntime) return jsxRuntime.exports;
		hasRequiredJsxRuntime = 1;

		{
		  jsxRuntime.exports = requireReactJsxRuntime_production();
		}
		return jsxRuntime.exports;
	}

	var jsxRuntimeExports = requireJsxRuntime();

	function isEmpty$1(obj) {
	  return obj === undefined || obj === null || Object.keys(obj).length === 0;
	}
	function GlobalStyles$3(props) {
	  const {
	    styles,
	    defaultTheme = {}
	  } = props;
	  const globalStyles = typeof styles === 'function' ? themeInput => styles(isEmpty$1(themeInput) ? defaultTheme : themeInput) : styles;
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Global, {
	    styles: globalStyles
	  });
	}

	/**
	 * @mui/styled-engine v7.1.0
	 *
	 * @license MIT
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	function styled$2(tag, options) {
	  const stylesFactory = newStyled(tag, options);
	  return stylesFactory;
	}

	// eslint-disable-next-line @typescript-eslint/naming-convention
	function internal_mutateStyles(tag, processor) {
	  // Emotion attaches all the styles as `__emotion_styles`.
	  // Ref: https://github.com/emotion-js/emotion/blob/16d971d0da229596d6bcc39d282ba9753c9ee7cf/packages/styled/src/base.js#L186
	  if (Array.isArray(tag.__emotion_styles)) {
	    tag.__emotion_styles = processor(tag.__emotion_styles);
	  }
	}

	// Emotion only accepts an array, but we want to avoid allocations
	const wrapper = [];
	// eslint-disable-next-line @typescript-eslint/naming-convention
	function internal_serializeStyles(styles) {
	  wrapper[0] = styles;
	  return serializeStyles(wrapper);
	}

	// Sorted ASC by size. That's important.
	// It can't be configured as it's used statically for propTypes.
	const sortBreakpointsValues = values => {
	  const breakpointsAsArray = Object.keys(values).map(key => ({
	    key,
	    val: values[key]
	  })) || [];
	  // Sort in ascending order
	  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
	  return breakpointsAsArray.reduce((acc, obj) => {
	    return {
	      ...acc,
	      [obj.key]: obj.val
	    };
	  }, {});
	};

	// Keep in mind that @media is inclusive by the CSS specification.
	function createBreakpoints(breakpoints) {
	  const {
	    // The breakpoint **start** at this value.
	    // For instance with the first breakpoint xs: [xs, sm).
	    values = {
	      xs: 0,
	      // phone
	      sm: 600,
	      // tablet
	      md: 900,
	      // small laptop
	      lg: 1200,
	      // desktop
	      xl: 1536 // large screen
	    },
	    unit = 'px',
	    step = 5,
	    ...other
	  } = breakpoints;
	  const sortedValues = sortBreakpointsValues(values);
	  const keys = Object.keys(sortedValues);
	  function up(key) {
	    const value = typeof values[key] === 'number' ? values[key] : key;
	    return `@media (min-width:${value}${unit})`;
	  }
	  function down(key) {
	    const value = typeof values[key] === 'number' ? values[key] : key;
	    return `@media (max-width:${value - step / 100}${unit})`;
	  }
	  function between(start, end) {
	    const endIndex = keys.indexOf(end);
	    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
	  }
	  function only(key) {
	    if (keys.indexOf(key) + 1 < keys.length) {
	      return between(key, keys[keys.indexOf(key) + 1]);
	    }
	    return up(key);
	  }
	  function not(key) {
	    // handle first and last key separately, for better readability
	    const keyIndex = keys.indexOf(key);
	    if (keyIndex === 0) {
	      return up(keys[1]);
	    }
	    if (keyIndex === keys.length - 1) {
	      return down(keys[keyIndex]);
	    }
	    return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
	  }
	  return {
	    keys,
	    values: sortedValues,
	    up,
	    down,
	    between,
	    only,
	    not,
	    unit,
	    ...other
	  };
	}

	const shape = {
	  borderRadius: 4
	};

	// The different signatures imply different meaning for their arguments that can't be expressed structurally.
	// We express the difference with variable names.

	function createSpacing(spacingInput = 8,
	// Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
	// Smaller components, such as icons, can align to a 4dp grid.
	// https://m2.material.io/design/layout/understanding-layout.html
	transform = createUnarySpacing({
	  spacing: spacingInput
	})) {
	  // Already transformed.
	  if (spacingInput.mui) {
	    return spacingInput;
	  }
	  const spacing = (...argsInput) => {
	    const args = argsInput.length === 0 ? [1] : argsInput;
	    return args.map(argument => {
	      const output = transform(argument);
	      return typeof output === 'number' ? `${output}px` : output;
	    }).join(' ');
	  };
	  spacing.mui = true;
	  return spacing;
	}

	/**
	 * A universal utility to style components with multiple color modes. Always use it from the theme object.
	 * It works with:
	 *  - [Basic theme](https://mui.com/material-ui/customization/dark-mode/)
	 *  - [CSS theme variables](https://mui.com/material-ui/customization/css-theme-variables/overview/)
	 *  - Zero-runtime engine
	 *
	 * Tips: Use an array over object spread and place `theme.applyStyles()` last.
	 *
	 * With the styled function:
	 *  [{ background: '#e5e5e5' }, theme.applyStyles('dark', { background: '#1c1c1c' })]
	 *  { background: '#e5e5e5', ...theme.applyStyles('dark', { background: '#1c1c1c' })}
	 *
	 * With the sx prop:
	 *  [{ background: '#e5e5e5' }, theme => theme.applyStyles('dark', { background: '#1c1c1c' })]
	 *  { background: '#e5e5e5', ...theme => theme.applyStyles('dark', { background: '#1c1c1c' })}
	 *
	 * @example
	 * 1. using with `styled`:
	 * ```jsx
	 *   const Component = styled('div')(({ theme }) => [
	 *     { background: '#e5e5e5' },
	 *     theme.applyStyles('dark', {
	 *       background: '#1c1c1c',
	 *       color: '#fff',
	 *     }),
	 *   ]);
	 * ```
	 *
	 * @example
	 * 2. using with `sx` prop:
	 * ```jsx
	 *   <Box sx={[
	 *     { background: '#e5e5e5' },
	 *     theme => theme.applyStyles('dark', {
	 *        background: '#1c1c1c',
	 *        color: '#fff',
	 *      }),
	 *     ]}
	 *   />
	 * ```
	 *
	 * @example
	 * 3. theming a component:
	 * ```jsx
	 *   extendTheme({
	 *     components: {
	 *       MuiButton: {
	 *         styleOverrides: {
	 *           root: ({ theme }) => [
	 *             { background: '#e5e5e5' },
	 *             theme.applyStyles('dark', {
	 *               background: '#1c1c1c',
	 *               color: '#fff',
	 *             }),
	 *           ],
	 *         },
	 *       }
	 *     }
	 *   })
	 *```
	 */
	function applyStyles(key, styles) {
	  // @ts-expect-error this is 'any' type
	  const theme = this;
	  if (theme.vars) {
	    if (!theme.colorSchemes?.[key] || typeof theme.getColorSchemeSelector !== 'function') {
	      return {};
	    }
	    // If CssVarsProvider is used as a provider, returns '*:where({selector}) &'
	    let selector = theme.getColorSchemeSelector(key);
	    if (selector === '&') {
	      return styles;
	    }
	    if (selector.includes('data-') || selector.includes('.')) {
	      // '*' is required as a workaround for Emotion issue (https://github.com/emotion-js/emotion/issues/2836)
	      selector = `*:where(${selector.replace(/\s*&$/, '')}) &`;
	    }
	    return {
	      [selector]: styles
	    };
	  }
	  if (theme.palette.mode === key) {
	    return styles;
	  }
	  return {};
	}

	function createTheme$1(options = {}, ...args) {
	  const {
	    breakpoints: breakpointsInput = {},
	    palette: paletteInput = {},
	    spacing: spacingInput,
	    shape: shapeInput = {},
	    ...other
	  } = options;
	  const breakpoints = createBreakpoints(breakpointsInput);
	  const spacing = createSpacing(spacingInput);
	  let muiTheme = deepmerge({
	    breakpoints,
	    direction: 'ltr',
	    components: {},
	    // Inject component definitions.
	    palette: {
	      mode: 'light',
	      ...paletteInput
	    },
	    spacing,
	    shape: {
	      ...shape,
	      ...shapeInput
	    }
	  }, other);
	  muiTheme = cssContainerQueries(muiTheme);
	  muiTheme.applyStyles = applyStyles;
	  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	  muiTheme.unstable_sxConfig = {
	    ...defaultSxConfig,
	    ...other?.unstable_sxConfig
	  };
	  muiTheme.unstable_sx = function sx(props) {
	    return styleFunctionSx({
	      sx: props,
	      theme: this
	    });
	  };
	  return muiTheme;
	}

	function isObjectEmpty$2(obj) {
	  return Object.keys(obj).length === 0;
	}
	function useTheme$2(defaultTheme = null) {
	  const contextTheme = reactExports.useContext(ThemeContext);
	  return !contextTheme || isObjectEmpty$2(contextTheme) ? defaultTheme : contextTheme;
	}

	const systemDefaultTheme$1 = createTheme$1();
	function useTheme$1(defaultTheme = systemDefaultTheme$1) {
	  return useTheme$2(defaultTheme);
	}

	function GlobalStyles$2({
	  styles,
	  themeId,
	  defaultTheme = {}
	}) {
	  const upperTheme = useTheme$1(defaultTheme);
	  const globalStyles = typeof styles === 'function' ? styles(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles;
	  return /*#__PURE__*/jsxRuntimeExports.jsx(GlobalStyles$3, {
	    styles: globalStyles
	  });
	}

	const defaultGenerator = componentName => componentName;
	const createClassNameGenerator = () => {
	  let generate = defaultGenerator;
	  return {
	    configure(generator) {
	      generate = generator;
	    },
	    generate(componentName) {
	      return generate(componentName);
	    },
	    reset() {
	      generate = defaultGenerator;
	    }
	  };
	};
	const ClassNameGenerator = createClassNameGenerator();

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	function createBox(options = {}) {
	  const {
	    themeId,
	    defaultTheme,
	    defaultClassName = 'MuiBox-root',
	    generateClassName
	  } = options;
	  const BoxRoot = styled$2('div', {
	    shouldForwardProp: prop => prop !== 'theme' && prop !== 'sx' && prop !== 'as'
	  })(styleFunctionSx);
	  const Box = /*#__PURE__*/reactExports.forwardRef(function Box(inProps, ref) {
	    const theme = useTheme$1(defaultTheme);
	    const {
	      className,
	      component = 'div',
	      ...other
	    } = extendSxProp$1(inProps);
	    return /*#__PURE__*/jsxRuntimeExports.jsx(BoxRoot, {
	      as: component,
	      ref: ref,
	      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
	      theme: themeId ? theme[themeId] || theme : theme,
	      ...other
	    });
	  });
	  return Box;
	}

	const globalStateClasses = {
	  active: 'active',
	  checked: 'checked',
	  completed: 'completed',
	  disabled: 'disabled',
	  error: 'error',
	  expanded: 'expanded',
	  focused: 'focused',
	  focusVisible: 'focusVisible',
	  open: 'open',
	  readOnly: 'readOnly',
	  required: 'required',
	  selected: 'selected'
	};
	function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
	  const globalStateClass = globalStateClasses[slot];
	  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
	}

	function generateUtilityClasses(componentName, slots, globalStatePrefix = 'Mui') {
	  const result = {};
	  slots.forEach(slot => {
	    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
	  });
	  return result;
	}

	function preprocessStyles(input) {
	  const {
	    variants,
	    ...style
	  } = input;
	  const result = {
	    variants,
	    style: internal_serializeStyles(style),
	    isProcessed: true
	  };

	  // Not supported on styled-components
	  if (result.style === style) {
	    return result;
	  }
	  if (variants) {
	    variants.forEach(variant => {
	      if (typeof variant.style !== 'function') {
	        variant.style = internal_serializeStyles(variant.style);
	      }
	    });
	  }
	  return result;
	}

	/* eslint-disable no-underscore-dangle */
	/* eslint-disable no-labels */
	/* eslint-disable no-lone-blocks */

	const systemDefaultTheme = createTheme$1();

	// Update /system/styled/#api in case if this changes
	function shouldForwardProp(prop) {
	  return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
	}
	function defaultOverridesResolver(slot) {
	  if (!slot) {
	    return null;
	  }
	  return (_props, styles) => styles[slot];
	}
	function attachTheme(props, themeId, defaultTheme) {
	  props.theme = isObjectEmpty$1(props.theme) ? defaultTheme : props.theme[themeId] || props.theme;
	}
	function processStyle(props, style) {
	  /*
	   * Style types:
	   *  - null/undefined
	   *  - string
	   *  - CSS style object: { [cssKey]: [cssValue], variants }
	   *  - Processed style object: { style, variants, isProcessed: true }
	   *  - Array of any of the above
	   */

	  const resolvedStyle = typeof style === 'function' ? style(props) : style;
	  if (Array.isArray(resolvedStyle)) {
	    return resolvedStyle.flatMap(subStyle => processStyle(props, subStyle));
	  }
	  if (Array.isArray(resolvedStyle?.variants)) {
	    let rootStyle;
	    if (resolvedStyle.isProcessed) {
	      rootStyle = resolvedStyle.style;
	    } else {
	      const {
	        variants,
	        ...otherStyles
	      } = resolvedStyle;
	      rootStyle = otherStyles;
	    }
	    return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
	  }
	  if (resolvedStyle?.isProcessed) {
	    return resolvedStyle.style;
	  }
	  return resolvedStyle;
	}
	function processStyleVariants(props, variants, results = []) {
	  let mergedState; // We might not need it, initialized lazily

	  variantLoop: for (let i = 0; i < variants.length; i += 1) {
	    const variant = variants[i];
	    if (typeof variant.props === 'function') {
	      mergedState ??= {
	        ...props,
	        ...props.ownerState,
	        ownerState: props.ownerState
	      };
	      if (!variant.props(mergedState)) {
	        continue;
	      }
	    } else {
	      for (const key in variant.props) {
	        if (props[key] !== variant.props[key] && props.ownerState?.[key] !== variant.props[key]) {
	          continue variantLoop;
	        }
	      }
	    }
	    if (typeof variant.style === 'function') {
	      mergedState ??= {
	        ...props,
	        ...props.ownerState,
	        ownerState: props.ownerState
	      };
	      results.push(variant.style(mergedState));
	    } else {
	      results.push(variant.style);
	    }
	  }
	  return results;
	}
	function createStyled(input = {}) {
	  const {
	    themeId,
	    defaultTheme = systemDefaultTheme,
	    rootShouldForwardProp = shouldForwardProp,
	    slotShouldForwardProp = shouldForwardProp
	  } = input;
	  function styleAttachTheme(props) {
	    attachTheme(props, themeId, defaultTheme);
	  }
	  const styled = (tag, inputOptions = {}) => {
	    // If `tag` is already a styled component, filter out the `sx` style function
	    // to prevent unnecessary styles generated by the composite components.
	    internal_mutateStyles(tag, styles => styles.filter(style => style !== styleFunctionSx));
	    const {
	      name: componentName,
	      slot: componentSlot,
	      skipVariantsResolver: inputSkipVariantsResolver,
	      skipSx: inputSkipSx,
	      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
	      // For more details: https://github.com/mui/material-ui/pull/37908
	      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
	      ...options
	    } = inputOptions;

	    // if skipVariantsResolver option is defined, take the value, otherwise, true for root and false for other slots.
	    const skipVariantsResolver = inputSkipVariantsResolver !== undefined ? inputSkipVariantsResolver :
	    // TODO v6: remove `Root` in the next major release
	    // For more details: https://github.com/mui/material-ui/pull/37908
	    componentSlot && componentSlot !== 'Root' && componentSlot !== 'root' || false;
	    const skipSx = inputSkipSx || false;
	    let shouldForwardPropOption = shouldForwardProp;

	    // TODO v6: remove `Root` in the next major release
	    // For more details: https://github.com/mui/material-ui/pull/37908
	    if (componentSlot === 'Root' || componentSlot === 'root') {
	      shouldForwardPropOption = rootShouldForwardProp;
	    } else if (componentSlot) {
	      // any other slot specified
	      shouldForwardPropOption = slotShouldForwardProp;
	    } else if (isStringTag(tag)) {
	      // for string (html) tag, preserve the behavior in emotion & styled-components.
	      shouldForwardPropOption = undefined;
	    }
	    const defaultStyledResolver = styled$2(tag, {
	      shouldForwardProp: shouldForwardPropOption,
	      label: generateStyledLabel(),
	      ...options
	    });
	    const transformStyle = style => {
	      // On the server Emotion doesn't use React.forwardRef for creating components, so the created
	      // component stays as a function. This condition makes sure that we do not interpolate functions
	      // which are basically components used as a selectors.
	      if (typeof style === 'function' && style.__emotion_real !== style) {
	        return function styleFunctionProcessor(props) {
	          return processStyle(props, style);
	        };
	      }
	      if (isPlainObject(style)) {
	        const serialized = preprocessStyles(style);
	        if (!serialized.variants) {
	          return serialized.style;
	        }
	        return function styleObjectProcessor(props) {
	          return processStyle(props, serialized);
	        };
	      }
	      return style;
	    };
	    const muiStyledResolver = (...expressionsInput) => {
	      const expressionsHead = [];
	      const expressionsBody = expressionsInput.map(transformStyle);
	      const expressionsTail = [];

	      // Preprocess `props` to set the scoped theme value.
	      // This must run before any other expression.
	      expressionsHead.push(styleAttachTheme);
	      if (componentName && overridesResolver) {
	        expressionsTail.push(function styleThemeOverrides(props) {
	          const theme = props.theme;
	          const styleOverrides = theme.components?.[componentName]?.styleOverrides;
	          if (!styleOverrides) {
	            return null;
	          }
	          const resolvedStyleOverrides = {};

	          // TODO: v7 remove iteration and use `resolveStyleArg(styleOverrides[slot])` directly
	          // eslint-disable-next-line guard-for-in
	          for (const slotKey in styleOverrides) {
	            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
	          }
	          return overridesResolver(props, resolvedStyleOverrides);
	        });
	      }
	      if (componentName && !skipVariantsResolver) {
	        expressionsTail.push(function styleThemeVariants(props) {
	          const theme = props.theme;
	          const themeVariants = theme?.components?.[componentName]?.variants;
	          if (!themeVariants) {
	            return null;
	          }
	          return processStyleVariants(props, themeVariants);
	        });
	      }
	      if (!skipSx) {
	        expressionsTail.push(styleFunctionSx);
	      }

	      // This function can be called as a tagged template, so the first argument would contain
	      // CSS `string[]` values.
	      if (Array.isArray(expressionsBody[0])) {
	        const inputStrings = expressionsBody.shift();

	        // We need to add placeholders in the tagged template for the custom functions we have
	        // possibly added (attachTheme, overrides, variants, and sx).
	        const placeholdersHead = new Array(expressionsHead.length).fill('');
	        const placeholdersTail = new Array(expressionsTail.length).fill('');
	        let outputStrings;
	        // prettier-ignore
	        {
	          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
	          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
	        }

	        // The only case where we put something before `attachTheme`
	        expressionsHead.unshift(outputStrings);
	      }
	      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
	      const Component = defaultStyledResolver(...expressions);
	      if (tag.muiName) {
	        Component.muiName = tag.muiName;
	      }
	      return Component;
	    };
	    if (defaultStyledResolver.withConfig) {
	      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
	    }
	    return muiStyledResolver;
	  };
	  return styled;
	}
	function generateStyledLabel(componentName, componentSlot) {
	  let label;
	  return label;
	}
	function isObjectEmpty$1(object) {
	  // eslint-disable-next-line
	  for (const _ in object) {
	    return false;
	  }
	  return true;
	}

	// https://github.com/emotion-js/emotion/blob/26ded6109fcd8ca9875cc2ce4564fee678a3f3c5/packages/styled/src/utils.js#L40
	function isStringTag(tag) {
	  return typeof tag === 'string' &&
	  // 96 is one less than the char code
	  // for "a" so this is checking that
	  // it's a lowercase character
	  tag.charCodeAt(0) > 96;
	}
	function lowercaseFirstLetter(string) {
	  if (!string) {
	    return string;
	  }
	  return string.charAt(0).toLowerCase() + string.slice(1);
	}

	const styled$1 = createStyled();

	/**
	 * Add keys, values of `defaultProps` that does not exist in `props`
	 * @param defaultProps
	 * @param props
	 * @returns resolved props
	 */
	function resolveProps(defaultProps, props) {
	  const output = {
	    ...props
	  };
	  for (const key in defaultProps) {
	    if (Object.prototype.hasOwnProperty.call(defaultProps, key)) {
	      const propName = key;
	      if (propName === 'components' || propName === 'slots') {
	        output[propName] = {
	          ...defaultProps[propName],
	          ...output[propName]
	        };
	      } else if (propName === 'componentsProps' || propName === 'slotProps') {
	        const defaultSlotProps = defaultProps[propName];
	        const slotProps = props[propName];
	        if (!slotProps) {
	          output[propName] = defaultSlotProps || {};
	        } else if (!defaultSlotProps) {
	          output[propName] = slotProps;
	        } else {
	          output[propName] = {
	            ...slotProps
	          };
	          for (const slotKey in defaultSlotProps) {
	            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
	              const slotPropName = slotKey;
	              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
	            }
	          }
	        }
	      } else if (output[propName] === undefined) {
	        output[propName] = defaultProps[propName];
	      }
	    }
	  }
	  return output;
	}

	function getThemeProps$1(params) {
	  const {
	    theme,
	    name,
	    props
	  } = params;
	  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
	    return props;
	  }
	  return resolveProps(theme.components[name].defaultProps, props);
	}

	function useThemeProps({
	  props,
	  name,
	  defaultTheme,
	  themeId
	}) {
	  let theme = useTheme$1(defaultTheme);
	  if (themeId) {
	    theme = theme[themeId] || theme;
	  }
	  return getThemeProps$1({
	    theme,
	    name,
	    props
	  });
	}

	/**
	 * A version of `React.useLayoutEffect` that does not show a warning when server-side rendering.
	 * This is useful for effects that are only needed for client-side rendering but not for SSR.
	 *
	 * Before you use this hook, make sure to read https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
	 * and confirm it doesn't apply to your use-case.
	 */
	const useEnhancedEffect = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;

	function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
	  return Math.max(min, Math.min(val, max));
	}

	/**
	 * Returns a number whose value is limited to the given range.
	 * @param {number} value The value to be clamped
	 * @param {number} min The lower boundary of the output range
	 * @param {number} max The upper boundary of the output range
	 * @returns {number} A number in the range [min, max]
	 */
	function clampWrapper(value, min = 0, max = 1) {
	  return clamp(value, min, max);
	}

	/**
	 * Converts a color from CSS hex format to CSS rgb format.
	 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
	 * @returns {string} A CSS rgb color string
	 */
	function hexToRgb(color) {
	  color = color.slice(1);
	  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
	  let colors = color.match(re);
	  if (colors && colors[0].length === 1) {
	    colors = colors.map(n => n + n);
	  }
	  return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
	}

	/**
	 * Returns an object with the type and values of a color.
	 *
	 * Note: Does not support rgb % values.
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @returns {object} - A MUI color object: {type: string, values: number[]}
	 */
	function decomposeColor(color) {
	  // Idempotent
	  if (color.type) {
	    return color;
	  }
	  if (color.charAt(0) === '#') {
	    return decomposeColor(hexToRgb(color));
	  }
	  const marker = color.indexOf('(');
	  const type = color.substring(0, marker);
	  if (!['rgb', 'rgba', 'hsl', 'hsla', 'color'].includes(type)) {
	    throw new Error(formatMuiErrorMessage(9, color));
	  }
	  let values = color.substring(marker + 1, color.length - 1);
	  let colorSpace;
	  if (type === 'color') {
	    values = values.split(' ');
	    colorSpace = values.shift();
	    if (values.length === 4 && values[3].charAt(0) === '/') {
	      values[3] = values[3].slice(1);
	    }
	    if (!['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].includes(colorSpace)) {
	      throw new Error(formatMuiErrorMessage(10, colorSpace));
	    }
	  } else {
	    values = values.split(',');
	  }
	  values = values.map(value => parseFloat(value));
	  return {
	    type,
	    values,
	    colorSpace
	  };
	}

	/**
	 * Returns a channel created from the input color.
	 *
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
	 */
	const colorChannel = color => {
	  const decomposedColor = decomposeColor(color);
	  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes('hsl') && idx !== 0 ? `${val}%` : val).join(' ');
	};
	const private_safeColorChannel = (color, warning) => {
	  try {
	    return colorChannel(color);
	  } catch (error) {
	    return color;
	  }
	};

	/**
	 * Converts a color object with type and values to a string.
	 * @param {object} color - Decomposed color
	 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
	 * @param {array} color.values - [n,n,n] or [n,n,n,n]
	 * @returns {string} A CSS color string
	 */
	function recomposeColor(color) {
	  const {
	    type,
	    colorSpace
	  } = color;
	  let {
	    values
	  } = color;
	  if (type.includes('rgb')) {
	    // Only convert the first 3 values to int (i.e. not alpha)
	    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
	  } else if (type.includes('hsl')) {
	    values[1] = `${values[1]}%`;
	    values[2] = `${values[2]}%`;
	  }
	  if (type.includes('color')) {
	    values = `${colorSpace} ${values.join(' ')}`;
	  } else {
	    values = `${values.join(', ')}`;
	  }
	  return `${type}(${values})`;
	}

	/**
	 * Converts a color from hsl format to rgb format.
	 * @param {string} color - HSL color values
	 * @returns {string} rgb color values
	 */
	function hslToRgb(color) {
	  color = decomposeColor(color);
	  const {
	    values
	  } = color;
	  const h = values[0];
	  const s = values[1] / 100;
	  const l = values[2] / 100;
	  const a = s * Math.min(l, 1 - l);
	  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	  let type = 'rgb';
	  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
	  if (color.type === 'hsla') {
	    type += 'a';
	    rgb.push(values[3]);
	  }
	  return recomposeColor({
	    type,
	    values: rgb
	  });
	}
	/**
	 * The relative brightness of any point in a color space,
	 * normalized to 0 for darkest black and 1 for lightest white.
	 *
	 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @returns {number} The relative brightness of the color in the range 0 - 1
	 */
	function getLuminance(color) {
	  color = decomposeColor(color);
	  let rgb = color.type === 'hsl' || color.type === 'hsla' ? decomposeColor(hslToRgb(color)).values : color.values;
	  rgb = rgb.map(val => {
	    if (color.type !== 'color') {
	      val /= 255; // normalized
	    }
	    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
	  });

	  // Truncate at 3 digits
	  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
	}

	/**
	 * Calculates the contrast ratio between two colors.
	 *
	 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
	 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
	 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
	 * @returns {number} A contrast ratio value in the range 0 - 21.
	 */
	function getContrastRatio(foreground, background) {
	  const lumA = getLuminance(foreground);
	  const lumB = getLuminance(background);
	  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
	}

	/**
	 * Sets the absolute transparency of a color.
	 * Any existing alpha values are overwritten.
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @param {number} value - value to set the alpha channel to in the range 0 - 1
	 * @returns {string} A CSS color string. Hex input values are returned as rgb
	 */
	function alpha(color, value) {
	  color = decomposeColor(color);
	  value = clampWrapper(value);
	  if (color.type === 'rgb' || color.type === 'hsl') {
	    color.type += 'a';
	  }
	  if (color.type === 'color') {
	    color.values[3] = `/${value}`;
	  } else {
	    color.values[3] = value;
	  }
	  return recomposeColor(color);
	}
	function private_safeAlpha(color, value, warning) {
	  try {
	    return alpha(color, value);
	  } catch (error) {
	    return color;
	  }
	}

	/**
	 * Darkens a color.
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @param {number} coefficient - multiplier in the range 0 - 1
	 * @returns {string} A CSS color string. Hex input values are returned as rgb
	 */
	function darken(color, coefficient) {
	  color = decomposeColor(color);
	  coefficient = clampWrapper(coefficient);
	  if (color.type.includes('hsl')) {
	    color.values[2] *= 1 - coefficient;
	  } else if (color.type.includes('rgb') || color.type.includes('color')) {
	    for (let i = 0; i < 3; i += 1) {
	      color.values[i] *= 1 - coefficient;
	    }
	  }
	  return recomposeColor(color);
	}
	function private_safeDarken(color, coefficient, warning) {
	  try {
	    return darken(color, coefficient);
	  } catch (error) {
	    return color;
	  }
	}

	/**
	 * Lightens a color.
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @param {number} coefficient - multiplier in the range 0 - 1
	 * @returns {string} A CSS color string. Hex input values are returned as rgb
	 */
	function lighten(color, coefficient) {
	  color = decomposeColor(color);
	  coefficient = clampWrapper(coefficient);
	  if (color.type.includes('hsl')) {
	    color.values[2] += (100 - color.values[2]) * coefficient;
	  } else if (color.type.includes('rgb')) {
	    for (let i = 0; i < 3; i += 1) {
	      color.values[i] += (255 - color.values[i]) * coefficient;
	    }
	  } else if (color.type.includes('color')) {
	    for (let i = 0; i < 3; i += 1) {
	      color.values[i] += (1 - color.values[i]) * coefficient;
	    }
	  }
	  return recomposeColor(color);
	}
	function private_safeLighten(color, coefficient, warning) {
	  try {
	    return lighten(color, coefficient);
	  } catch (error) {
	    return color;
	  }
	}

	/**
	 * Darken or lighten a color, depending on its luminance.
	 * Light colors are darkened, dark colors are lightened.
	 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
	 * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
	 * @returns {string} A CSS color string. Hex input values are returned as rgb
	 */
	function emphasize(color, coefficient = 0.15) {
	  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
	}
	function private_safeEmphasize(color, coefficient, warning) {
	  try {
	    return emphasize(color, coefficient);
	  } catch (error) {
	    return color;
	  }
	}

	const PropsContext = /*#__PURE__*/reactExports.createContext(undefined);
	function getThemeProps(params) {
	  const {
	    theme,
	    name,
	    props
	  } = params;
	  if (!theme || !theme.components || !theme.components[name]) {
	    return props;
	  }
	  const config = theme.components[name];
	  if (config.defaultProps) {
	    // compatible with v5 signature
	    return resolveProps(config.defaultProps, props);
	  }
	  if (!config.styleOverrides && !config.variants) {
	    // v6 signature, no property 'defaultProps'
	    return resolveProps(config, props);
	  }
	  return props;
	}
	function useDefaultProps$1({
	  props,
	  name
	}) {
	  const ctx = reactExports.useContext(PropsContext);
	  return getThemeProps({
	    props,
	    name,
	    theme: {
	      components: ctx
	    }
	  });
	}

	/* eslint-disable @typescript-eslint/naming-convention */

	// We need to pass an argument as `{ theme }` for PigmentCSS, but we don't want to
	// allocate more objects.
	const arg = {
	  theme: undefined
	};

	/**
	 * Memoize style function on theme.
	 * Intended to be used in styled() calls that only need access to the theme.
	 */
	function unstable_memoTheme(styleFn) {
	  let lastValue;
	  let lastTheme;
	  return function styleMemoized(props) {
	    let value = lastValue;
	    if (value === undefined || props.theme !== lastTheme) {
	      arg.theme = props.theme;
	      value = preprocessStyles(styleFn(arg));
	      lastValue = value;
	      lastTheme = props.theme;
	    }
	    return value;
	  };
	}

	/**
	 * The benefit of this function is to help developers get CSS var from theme without specifying the whole variable
	 * and they does not need to remember the prefix (defined once).
	 */
	function createGetCssVar$1(prefix = '') {
	  function appendVar(...vars) {
	    if (!vars.length) {
	      return '';
	    }
	    const value = vars[0];
	    if (typeof value === 'string' && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
	      return `, var(--${prefix ? `${prefix}-` : ''}${value}${appendVar(...vars.slice(1))})`;
	    }
	    return `, ${value}`;
	  }

	  // AdditionalVars makes `getCssVar` less strict, so it can be use like this `getCssVar('non-mui-variable')` without type error.
	  const getCssVar = (field, ...fallbacks) => {
	    return `var(--${prefix ? `${prefix}-` : ''}${field}${appendVar(...fallbacks)})`;
	  };
	  return getCssVar;
	}

	/**
	 * This function create an object from keys, value and then assign to target
	 *
	 * @param {Object} obj : the target object to be assigned
	 * @param {string[]} keys
	 * @param {string | number} value
	 *
	 * @example
	 * const source = {}
	 * assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')
	 * console.log(source) // { palette: { primary: 'var(--palette-primary)' } }
	 *
	 * @example
	 * const source = { palette: { primary: 'var(--palette-primary)' } }
	 * assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')
	 * console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }
	 */
	const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
	  let temp = obj;
	  keys.forEach((k, index) => {
	    if (index === keys.length - 1) {
	      if (Array.isArray(temp)) {
	        temp[Number(k)] = value;
	      } else if (temp && typeof temp === 'object') {
	        temp[k] = value;
	      }
	    } else if (temp && typeof temp === 'object') {
	      if (!temp[k]) {
	        temp[k] = arrayKeys.includes(k) ? [] : {};
	      }
	      temp = temp[k];
	    }
	  });
	};

	/**
	 *
	 * @param {Object} obj : source object
	 * @param {Function} callback : a function that will be called when
	 *                   - the deepest key in source object is reached
	 *                   - the value of the deepest key is NOT `undefined` | `null`
	 *
	 * @example
	 * walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)
	 * // ['palette', 'primary', 'main'] '#000000'
	 */
	const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
	  function recurse(object, parentKeys = [], arrayKeys = []) {
	    Object.entries(object).forEach(([key, value]) => {
	      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
	        if (value !== undefined && value !== null) {
	          if (typeof value === 'object' && Object.keys(value).length > 0) {
	            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
	          } else {
	            callback([...parentKeys, key], value, arrayKeys);
	          }
	        }
	      }
	    });
	  }
	  recurse(obj);
	};
	const getCssValue = (keys, value) => {
	  if (typeof value === 'number') {
	    if (['lineHeight', 'fontWeight', 'opacity', 'zIndex'].some(prop => keys.includes(prop))) {
	      // CSS property that are unitless
	      return value;
	    }
	    const lastKey = keys[keys.length - 1];
	    if (lastKey.toLowerCase().includes('opacity')) {
	      // opacity values are unitless
	      return value;
	    }
	    return `${value}px`;
	  }
	  return value;
	};

	/**
	 * a function that parse theme and return { css, vars }
	 *
	 * @param {Object} theme
	 * @param {{
	 *  prefix?: string,
	 *  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean
	 * }} options.
	 *  `prefix`: The prefix of the generated CSS variables. This function does not change the value.
	 *
	 * @returns {{ css: Object, vars: Object }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme).
	 *
	 * @example
	 * const { css, vars } = parser({
	 *   fontSize: 12,
	 *   lineHeight: 1.2,
	 *   palette: { primary: { 500: 'var(--color)' } }
	 * }, { prefix: 'foo' })
	 *
	 * console.log(css) // { '--foo-fontSize': '12px', '--foo-lineHeight': 1.2, '--foo-palette-primary-500': 'var(--color)' }
	 * console.log(vars) // { fontSize: 'var(--foo-fontSize)', lineHeight: 'var(--foo-lineHeight)', palette: { primary: { 500: 'var(--foo-palette-primary-500)' } } }
	 */
	function cssVarsParser(theme, options) {
	  const {
	    prefix,
	    shouldSkipGeneratingVar
	  } = options || {};
	  const css = {};
	  const vars = {};
	  const varsWithDefaults = {};
	  walkObjectDeep(theme, (keys, value, arrayKeys) => {
	    if (typeof value === 'string' || typeof value === 'number') {
	      if (!shouldSkipGeneratingVar || !shouldSkipGeneratingVar(keys, value)) {
	        // only create css & var if `shouldSkipGeneratingVar` return false
	        const cssVar = `--${prefix ? `${prefix}-` : ''}${keys.join('-')}`;
	        const resolvedValue = getCssValue(keys, value);
	        Object.assign(css, {
	          [cssVar]: resolvedValue
	        });
	        assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
	        assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
	      }
	    }
	  }, keys => keys[0] === 'vars' // skip 'vars/*' paths
	  );
	  return {
	    css,
	    vars,
	    varsWithDefaults
	  };
	}

	function prepareCssVars(theme, parserConfig = {}) {
	  const {
	    getSelector = defaultGetSelector,
	    disableCssColorScheme,
	    colorSchemeSelector: selector
	  } = parserConfig;
	  // @ts-ignore - ignore components do not exist
	  const {
	    colorSchemes = {},
	    components,
	    defaultColorScheme = 'light',
	    ...otherTheme
	  } = theme;
	  const {
	    vars: rootVars,
	    css: rootCss,
	    varsWithDefaults: rootVarsWithDefaults
	  } = cssVarsParser(otherTheme, parserConfig);
	  let themeVars = rootVarsWithDefaults;
	  const colorSchemesMap = {};
	  const {
	    [defaultColorScheme]: defaultScheme,
	    ...otherColorSchemes
	  } = colorSchemes;
	  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
	    const {
	      vars,
	      css,
	      varsWithDefaults
	    } = cssVarsParser(scheme, parserConfig);
	    themeVars = deepmerge(themeVars, varsWithDefaults);
	    colorSchemesMap[key] = {
	      css,
	      vars
	    };
	  });
	  if (defaultScheme) {
	    // default color scheme vars should be merged last to set as default
	    const {
	      css,
	      vars,
	      varsWithDefaults
	    } = cssVarsParser(defaultScheme, parserConfig);
	    themeVars = deepmerge(themeVars, varsWithDefaults);
	    colorSchemesMap[defaultColorScheme] = {
	      css,
	      vars
	    };
	  }
	  function defaultGetSelector(colorScheme, cssObject) {
	    let rule = selector;
	    if (selector === 'class') {
	      rule = '.%s';
	    }
	    if (selector === 'data') {
	      rule = '[data-%s]';
	    }
	    if (selector?.startsWith('data-') && !selector.includes('%s')) {
	      // 'data-joy-color-scheme' -> '[data-joy-color-scheme="%s"]'
	      rule = `[${selector}="%s"]`;
	    }
	    if (colorScheme) {
	      if (rule === 'media') {
	        if (theme.defaultColorScheme === colorScheme) {
	          return ':root';
	        }
	        const mode = colorSchemes[colorScheme]?.palette?.mode || colorScheme;
	        return {
	          [`@media (prefers-color-scheme: ${mode})`]: {
	            ':root': cssObject
	          }
	        };
	      }
	      if (rule) {
	        if (theme.defaultColorScheme === colorScheme) {
	          return `:root, ${rule.replace('%s', String(colorScheme))}`;
	        }
	        return rule.replace('%s', String(colorScheme));
	      }
	    }
	    return ':root';
	  }
	  const generateThemeVars = () => {
	    let vars = {
	      ...rootVars
	    };
	    Object.entries(colorSchemesMap).forEach(([, {
	      vars: schemeVars
	    }]) => {
	      vars = deepmerge(vars, schemeVars);
	    });
	    return vars;
	  };
	  const generateStyleSheets = () => {
	    const stylesheets = [];
	    const colorScheme = theme.defaultColorScheme || 'light';
	    function insertStyleSheet(key, css) {
	      if (Object.keys(css).length) {
	        stylesheets.push(typeof key === 'string' ? {
	          [key]: {
	            ...css
	          }
	        } : key);
	      }
	    }
	    insertStyleSheet(getSelector(undefined, {
	      ...rootCss
	    }), rootCss);
	    const {
	      [colorScheme]: defaultSchemeVal,
	      ...other
	    } = colorSchemesMap;
	    if (defaultSchemeVal) {
	      // default color scheme has to come before other color schemes
	      const {
	        css
	      } = defaultSchemeVal;
	      const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
	      const finalCss = !disableCssColorScheme && cssColorSheme ? {
	        colorScheme: cssColorSheme,
	        ...css
	      } : {
	        ...css
	      };
	      insertStyleSheet(getSelector(colorScheme, {
	        ...finalCss
	      }), finalCss);
	    }
	    Object.entries(other).forEach(([key, {
	      css
	    }]) => {
	      const cssColorSheme = colorSchemes[key]?.palette?.mode;
	      const finalCss = !disableCssColorScheme && cssColorSheme ? {
	        colorScheme: cssColorSheme,
	        ...css
	      } : {
	        ...css
	      };
	      insertStyleSheet(getSelector(key, {
	        ...finalCss
	      }), finalCss);
	    });
	    return stylesheets;
	  };
	  return {
	    vars: themeVars,
	    generateThemeVars,
	    generateStyleSheets
	  };
	}

	/* eslint-disable import/prefer-default-export */
	function createGetColorSchemeSelector(selector) {
	  return function getColorSchemeSelector(colorScheme) {
	    if (selector === 'media') {
	      return `@media (prefers-color-scheme: ${colorScheme})`;
	    }
	    if (selector) {
	      if (selector.startsWith('data-') && !selector.includes('%s')) {
	        return `[${selector}="${colorScheme}"] &`;
	      }
	      if (selector === 'class') {
	        return `.${colorScheme} &`;
	      }
	      if (selector === 'data') {
	        return `[data-${colorScheme}] &`;
	      }
	      return `${selector.replace('%s', colorScheme)} &`;
	    }
	    return '&';
	  };
	}

	/* eslint no-restricted-syntax: 0, prefer-template: 0, guard-for-in: 0
	   ---
	   These rules are preventing the performance optimizations below.
	 */

	/**
	 * Compose classes from multiple sources.
	 *
	 * @example
	 * ```tsx
	 * const slots = {
	 *  root: ['root', 'primary'],
	 *  label: ['label'],
	 * };
	 *
	 * const getUtilityClass = (slot) => `MuiButton-${slot}`;
	 *
	 * const classes = {
	 *   root: 'my-root-class',
	 * };
	 *
	 * const output = composeClasses(slots, getUtilityClass, classes);
	 * // {
	 * //   root: 'MuiButton-root MuiButton-primary my-root-class',
	 * //   label: 'MuiButton-label',
	 * // }
	 * ```
	 *
	 * @param slots a list of classes for each possible slot
	 * @param getUtilityClass a function to resolve the class based on the slot name
	 * @param classes the input classes from props
	 * @returns the resolved classes for all slots
	 */
	function composeClasses(slots, getUtilityClass, classes = undefined) {
	  const output = {};
	  for (const slotName in slots) {
	    const slot = slots[slotName];
	    let buffer = '';
	    let start = true;
	    for (let i = 0; i < slot.length; i += 1) {
	      const value = slot[i];
	      if (value) {
	        buffer += (start === true ? '' : ' ') + getUtilityClass(value);
	        start = false;
	        if (classes && classes[value]) {
	          buffer += ' ' + classes[value];
	        }
	      }
	    }
	    output[slotName] = buffer;
	  }
	  return output;
	}

	function isMuiElement(element, muiNames) {
	  return /*#__PURE__*/reactExports.isValidElement(element) && muiNames.indexOf(
	  // For server components `muiName` is avaialble in element.type._payload.value.muiName
	  // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
	  // eslint-disable-next-line no-underscore-dangle
	  element.type.muiName ?? element.type?._payload?.value?.muiName) !== -1;
	}

	const filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter(key => responsiveKeys.includes(key));
	const traverseBreakpoints = (breakpoints, responsive, iterator) => {
	  const smallestBreakpoint = breakpoints.keys[0]; // the keys is sorted from smallest to largest by `createBreakpoints`.

	  if (Array.isArray(responsive)) {
	    responsive.forEach((breakpointValue, index) => {
	      iterator((responsiveStyles, style) => {
	        if (index <= breakpoints.keys.length - 1) {
	          if (index === 0) {
	            Object.assign(responsiveStyles, style);
	          } else {
	            responsiveStyles[breakpoints.up(breakpoints.keys[index])] = style;
	          }
	        }
	      }, breakpointValue);
	    });
	  } else if (responsive && typeof responsive === 'object') {
	    // prevent null
	    // responsive could be a very big object, pick the smallest responsive values

	    const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
	    keys.forEach(key => {
	      if (breakpoints.keys.includes(key)) {
	        // @ts-ignore already checked that responsive is an object
	        const breakpointValue = responsive[key];
	        if (breakpointValue !== undefined) {
	          iterator((responsiveStyles, style) => {
	            if (smallestBreakpoint === key) {
	              Object.assign(responsiveStyles, style);
	            } else {
	              responsiveStyles[breakpoints.up(key)] = style;
	            }
	          }, breakpointValue);
	        }
	      }
	    });
	  } else if (typeof responsive === 'number' || typeof responsive === 'string') {
	    iterator((responsiveStyles, style) => {
	      Object.assign(responsiveStyles, style);
	    }, responsive);
	  }
	};

	function getSelfSpacingVar(axis) {
	  return `--Grid-${axis}Spacing`;
	}
	function getParentSpacingVar(axis) {
	  return `--Grid-parent-${axis}Spacing`;
	}
	const selfColumnsVar = '--Grid-columns';
	const parentColumnsVar = '--Grid-parent-columns';
	const generateGridSizeStyles = ({
	  theme,
	  ownerState
	}) => {
	  const styles = {};
	  traverseBreakpoints(theme.breakpoints, ownerState.size, (appendStyle, value) => {
	    let style = {};
	    if (value === 'grow') {
	      style = {
	        flexBasis: 0,
	        flexGrow: 1,
	        maxWidth: '100%'
	      };
	    }
	    if (value === 'auto') {
	      style = {
	        flexBasis: 'auto',
	        flexGrow: 0,
	        flexShrink: 0,
	        maxWidth: 'none',
	        width: 'auto'
	      };
	    }
	    if (typeof value === 'number') {
	      style = {
	        flexGrow: 0,
	        flexBasis: 'auto',
	        width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar('column')}) / var(${parentColumnsVar})))`
	      };
	    }
	    appendStyle(styles, style);
	  });
	  return styles;
	};
	const generateGridOffsetStyles = ({
	  theme,
	  ownerState
	}) => {
	  const styles = {};
	  traverseBreakpoints(theme.breakpoints, ownerState.offset, (appendStyle, value) => {
	    let style = {};
	    if (value === 'auto') {
	      style = {
	        marginLeft: 'auto'
	      };
	    }
	    if (typeof value === 'number') {
	      style = {
	        marginLeft: value === 0 ? '0px' : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar('column')}) * ${value} / var(${parentColumnsVar}))`
	      };
	    }
	    appendStyle(styles, style);
	  });
	  return styles;
	};
	const generateGridColumnsStyles = ({
	  theme,
	  ownerState
	}) => {
	  if (!ownerState.container) {
	    return {};
	  }
	  const styles = {
	    [selfColumnsVar]: 12
	  };
	  traverseBreakpoints(theme.breakpoints, ownerState.columns, (appendStyle, value) => {
	    const columns = value ?? 12;
	    appendStyle(styles, {
	      [selfColumnsVar]: columns,
	      '> *': {
	        [parentColumnsVar]: columns
	      }
	    });
	  });
	  return styles;
	};
	const generateGridRowSpacingStyles = ({
	  theme,
	  ownerState
	}) => {
	  if (!ownerState.container) {
	    return {};
	  }
	  const styles = {};
	  traverseBreakpoints(theme.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
	    const spacing = typeof value === 'string' ? value : theme.spacing?.(value);
	    appendStyle(styles, {
	      [getSelfSpacingVar('row')]: spacing,
	      '> *': {
	        [getParentSpacingVar('row')]: spacing
	      }
	    });
	  });
	  return styles;
	};
	const generateGridColumnSpacingStyles = ({
	  theme,
	  ownerState
	}) => {
	  if (!ownerState.container) {
	    return {};
	  }
	  const styles = {};
	  traverseBreakpoints(theme.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
	    const spacing = typeof value === 'string' ? value : theme.spacing?.(value);
	    appendStyle(styles, {
	      [getSelfSpacingVar('column')]: spacing,
	      '> *': {
	        [getParentSpacingVar('column')]: spacing
	      }
	    });
	  });
	  return styles;
	};
	const generateGridDirectionStyles = ({
	  theme,
	  ownerState
	}) => {
	  if (!ownerState.container) {
	    return {};
	  }
	  const styles = {};
	  traverseBreakpoints(theme.breakpoints, ownerState.direction, (appendStyle, value) => {
	    appendStyle(styles, {
	      flexDirection: value
	    });
	  });
	  return styles;
	};
	const generateGridStyles = ({
	  ownerState
	}) => {
	  return {
	    minWidth: 0,
	    boxSizing: 'border-box',
	    ...(ownerState.container && {
	      display: 'flex',
	      flexWrap: 'wrap',
	      ...(ownerState.wrap && ownerState.wrap !== 'wrap' && {
	        flexWrap: ownerState.wrap
	      }),
	      gap: `var(${getSelfSpacingVar('row')}) var(${getSelfSpacingVar('column')})`
	    })
	  };
	};
	const generateSizeClassNames = size => {
	  const classNames = [];
	  Object.entries(size).forEach(([key, value]) => {
	    if (value !== false && value !== undefined) {
	      classNames.push(`grid-${key}-${String(value)}`);
	    }
	  });
	  return classNames;
	};
	const generateSpacingClassNames = (spacing, smallestBreakpoint = 'xs') => {
	  function isValidSpacing(val) {
	    if (val === undefined) {
	      return false;
	    }
	    return typeof val === 'string' && !Number.isNaN(Number(val)) || typeof val === 'number' && val > 0;
	  }
	  if (isValidSpacing(spacing)) {
	    return [`spacing-${smallestBreakpoint}-${String(spacing)}`];
	  }
	  if (typeof spacing === 'object' && !Array.isArray(spacing)) {
	    const classNames = [];
	    Object.entries(spacing).forEach(([key, value]) => {
	      if (isValidSpacing(value)) {
	        classNames.push(`spacing-${key}-${String(value)}`);
	      }
	    });
	    return classNames;
	  }
	  return [];
	};
	const generateDirectionClasses = direction => {
	  if (direction === undefined) {
	    return [];
	  }
	  if (typeof direction === 'object') {
	    return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
	  }
	  return [`direction-xs-${String(direction)}`];
	};

	/**
	 * Deletes the legacy Grid component props from the `props` object and warns once about them if found.
	 *
	 * @param {object} props The props object to remove the legacy Grid props from.
	 * @param {Breakpoints} breakpoints The breakpoints object.
	 */
	function deleteLegacyGridProps(props, breakpoints) {
	  if (props.item !== undefined) {
	    delete props.item;
	  }
	  if (props.zeroMinWidth !== undefined) {
	    delete props.zeroMinWidth;
	  }
	  breakpoints.keys.forEach(breakpoint => {
	    if (props[breakpoint] !== undefined) {
	      delete props[breakpoint];
	    }
	  });
	}

	const defaultTheme$3 = createTheme$1();

	// widening Theme to any so that the consumer can own the theme structure.
	const defaultCreateStyledComponent = styled$1('div', {
	  name: 'MuiGrid',
	  slot: 'Root'
	});
	function useThemePropsDefault(props) {
	  return useThemeProps({
	    props,
	    name: 'MuiGrid',
	    defaultTheme: defaultTheme$3
	  });
	}
	function createGrid(options = {}) {
	  const {
	    // This will allow adding custom styled fn (for example for custom sx style function)
	    createStyledComponent = defaultCreateStyledComponent,
	    useThemeProps = useThemePropsDefault,
	    useTheme = useTheme$1,
	    componentName = 'MuiGrid'
	  } = options;
	  const useUtilityClasses = (ownerState, theme) => {
	    const {
	      container,
	      direction,
	      spacing,
	      wrap,
	      size
	    } = ownerState;
	    const slots = {
	      root: ['root', container && 'container', wrap !== 'wrap' && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size), ...(container ? generateSpacingClassNames(spacing, theme.breakpoints.keys[0]) : [])]
	    };
	    return composeClasses(slots, slot => generateUtilityClass(componentName, slot), {});
	  };
	  function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
	    const parsedProp = {};
	    if (propValue === null) {
	      return parsedProp;
	    }
	    if (Array.isArray(propValue)) {
	      propValue.forEach((value, index) => {
	        if (value !== null && shouldUseValue(value) && breakpoints.keys[index]) {
	          parsedProp[breakpoints.keys[index]] = value;
	        }
	      });
	    } else if (typeof propValue === 'object') {
	      Object.keys(propValue).forEach(key => {
	        const value = propValue[key];
	        if (value !== null && value !== undefined && shouldUseValue(value)) {
	          parsedProp[key] = value;
	        }
	      });
	    } else {
	      parsedProp[breakpoints.keys[0]] = propValue;
	    }
	    return parsedProp;
	  }
	  const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
	  const Grid = /*#__PURE__*/reactExports.forwardRef(function Grid(inProps, ref) {
	    const theme = useTheme();
	    const themeProps = useThemeProps(inProps);
	    const props = extendSxProp$1(themeProps); // `color` type conflicts with html color attribute.

	    // TODO v8: Remove when removing the legacy Grid component
	    deleteLegacyGridProps(props, theme.breakpoints);
	    const {
	      className,
	      children,
	      columns: columnsProp = 12,
	      container = false,
	      component = 'div',
	      direction = 'row',
	      wrap = 'wrap',
	      size: sizeProp = {},
	      offset: offsetProp = {},
	      spacing: spacingProp = 0,
	      rowSpacing: rowSpacingProp = spacingProp,
	      columnSpacing: columnSpacingProp = spacingProp,
	      unstable_level: level = 0,
	      ...other
	    } = props;
	    const size = parseResponsiveProp(sizeProp, theme.breakpoints, val => val !== false);
	    const offset = parseResponsiveProp(offsetProp, theme.breakpoints);
	    const columns = inProps.columns ?? (level ? undefined : columnsProp);
	    const spacing = inProps.spacing ?? (level ? undefined : spacingProp);
	    const rowSpacing = inProps.rowSpacing ?? inProps.spacing ?? (level ? undefined : rowSpacingProp);
	    const columnSpacing = inProps.columnSpacing ?? inProps.spacing ?? (level ? undefined : columnSpacingProp);
	    const ownerState = {
	      ...props,
	      level,
	      columns,
	      container,
	      direction,
	      wrap,
	      spacing,
	      rowSpacing,
	      columnSpacing,
	      size,
	      offset
	    };
	    const classes = useUtilityClasses(ownerState, theme);
	    return /*#__PURE__*/jsxRuntimeExports.jsx(GridRoot, {
	      ref: ref,
	      as: component,
	      ownerState: ownerState,
	      className: clsx(classes.root, className),
	      ...other,
	      children: reactExports.Children.map(children, child => {
	        if (/*#__PURE__*/reactExports.isValidElement(child) && isMuiElement(child, ['Grid']) && container && child.props.container) {
	          return /*#__PURE__*/reactExports.cloneElement(child, {
	            unstable_level: child.props?.unstable_level ?? level + 1
	          });
	        }
	        return child;
	      })
	    });
	  });

	  // @ts-ignore internal logic for nested grid
	  Grid.muiName = 'Grid';
	  return Grid;
	}

	const common = {
	  black: '#000',
	  white: '#fff'
	};

	const grey = {
	  50: '#fafafa',
	  100: '#f5f5f5',
	  200: '#eeeeee',
	  300: '#e0e0e0',
	  400: '#bdbdbd',
	  500: '#9e9e9e',
	  600: '#757575',
	  700: '#616161',
	  800: '#424242',
	  900: '#212121',
	  A100: '#f5f5f5',
	  A200: '#eeeeee',
	  A400: '#bdbdbd',
	  A700: '#616161'
	};

	const purple = {
	  50: '#f3e5f5',
	  200: '#ce93d8',
	  300: '#ba68c8',
	  400: '#ab47bc',
	  500: '#9c27b0',
	  700: '#7b1fa2'};

	const red = {
	  300: '#e57373',
	  400: '#ef5350',
	  500: '#f44336',
	  700: '#d32f2f',
	  800: '#c62828'};

	const orange = {
	  300: '#ffb74d',
	  400: '#ffa726',
	  500: '#ff9800',
	  700: '#f57c00',
	  900: '#e65100'};

	const blue = {
	  50: '#e3f2fd',
	  200: '#90caf9',
	  400: '#42a5f5',
	  700: '#1976d2',
	  800: '#1565c0'};

	const lightBlue = {
	  300: '#4fc3f7',
	  400: '#29b6f6',
	  500: '#03a9f4',
	  700: '#0288d1',
	  900: '#01579b'};

	const green = {
	  300: '#81c784',
	  400: '#66bb6a',
	  500: '#4caf50',
	  700: '#388e3c',
	  800: '#2e7d32',
	  900: '#1b5e20'};

	function getLight() {
	  return {
	    // The colors used to style the text.
	    text: {
	      // The most important text.
	      primary: 'rgba(0, 0, 0, 0.87)',
	      // Secondary text.
	      secondary: 'rgba(0, 0, 0, 0.6)',
	      // Disabled text have even lower visual prominence.
	      disabled: 'rgba(0, 0, 0, 0.38)'
	    },
	    // The color used to divide different elements.
	    divider: 'rgba(0, 0, 0, 0.12)',
	    // The background colors used to style the surfaces.
	    // Consistency between these values is important.
	    background: {
	      paper: common.white,
	      default: common.white
	    },
	    // The colors used to style the action elements.
	    action: {
	      // The color of an active action like an icon button.
	      active: 'rgba(0, 0, 0, 0.54)',
	      // The color of an hovered action.
	      hover: 'rgba(0, 0, 0, 0.04)',
	      hoverOpacity: 0.04,
	      // The color of a selected action.
	      selected: 'rgba(0, 0, 0, 0.08)',
	      selectedOpacity: 0.08,
	      // The color of a disabled action.
	      disabled: 'rgba(0, 0, 0, 0.26)',
	      // The background color of a disabled action.
	      disabledBackground: 'rgba(0, 0, 0, 0.12)',
	      disabledOpacity: 0.38,
	      focus: 'rgba(0, 0, 0, 0.12)',
	      focusOpacity: 0.12,
	      activatedOpacity: 0.12
	    }
	  };
	}
	const light = getLight();
	function getDark() {
	  return {
	    text: {
	      primary: common.white,
	      secondary: 'rgba(255, 255, 255, 0.7)',
	      disabled: 'rgba(255, 255, 255, 0.5)',
	      icon: 'rgba(255, 255, 255, 0.5)'
	    },
	    divider: 'rgba(255, 255, 255, 0.12)',
	    background: {
	      paper: '#121212',
	      default: '#121212'
	    },
	    action: {
	      active: common.white,
	      hover: 'rgba(255, 255, 255, 0.08)',
	      hoverOpacity: 0.08,
	      selected: 'rgba(255, 255, 255, 0.16)',
	      selectedOpacity: 0.16,
	      disabled: 'rgba(255, 255, 255, 0.3)',
	      disabledBackground: 'rgba(255, 255, 255, 0.12)',
	      disabledOpacity: 0.38,
	      focus: 'rgba(255, 255, 255, 0.12)',
	      focusOpacity: 0.12,
	      activatedOpacity: 0.24
	    }
	  };
	}
	const dark = getDark();
	function addLightOrDark(intent, direction, shade, tonalOffset) {
	  const tonalOffsetLight = tonalOffset.light || tonalOffset;
	  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
	  if (!intent[direction]) {
	    if (intent.hasOwnProperty(shade)) {
	      intent[direction] = intent[shade];
	    } else if (direction === 'light') {
	      intent.light = lighten(intent.main, tonalOffsetLight);
	    } else if (direction === 'dark') {
	      intent.dark = darken(intent.main, tonalOffsetDark);
	    }
	  }
	}
	function getDefaultPrimary(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: blue[200],
	      light: blue[50],
	      dark: blue[400]
	    };
	  }
	  return {
	    main: blue[700],
	    light: blue[400],
	    dark: blue[800]
	  };
	}
	function getDefaultSecondary(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: purple[200],
	      light: purple[50],
	      dark: purple[400]
	    };
	  }
	  return {
	    main: purple[500],
	    light: purple[300],
	    dark: purple[700]
	  };
	}
	function getDefaultError(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: red[500],
	      light: red[300],
	      dark: red[700]
	    };
	  }
	  return {
	    main: red[700],
	    light: red[400],
	    dark: red[800]
	  };
	}
	function getDefaultInfo(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: lightBlue[400],
	      light: lightBlue[300],
	      dark: lightBlue[700]
	    };
	  }
	  return {
	    main: lightBlue[700],
	    light: lightBlue[500],
	    dark: lightBlue[900]
	  };
	}
	function getDefaultSuccess(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: green[400],
	      light: green[300],
	      dark: green[700]
	    };
	  }
	  return {
	    main: green[800],
	    light: green[500],
	    dark: green[900]
	  };
	}
	function getDefaultWarning(mode = 'light') {
	  if (mode === 'dark') {
	    return {
	      main: orange[400],
	      light: orange[300],
	      dark: orange[700]
	    };
	  }
	  return {
	    main: '#ed6c02',
	    // closest to orange[800] that pass 3:1.
	    light: orange[500],
	    dark: orange[900]
	  };
	}
	function createPalette(palette) {
	  const {
	    mode = 'light',
	    contrastThreshold = 3,
	    tonalOffset = 0.2,
	    ...other
	  } = palette;
	  const primary = palette.primary || getDefaultPrimary(mode);
	  const secondary = palette.secondary || getDefaultSecondary(mode);
	  const error = palette.error || getDefaultError(mode);
	  const info = palette.info || getDefaultInfo(mode);
	  const success = palette.success || getDefaultSuccess(mode);
	  const warning = palette.warning || getDefaultWarning(mode);

	  // Use the same logic as
	  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
	  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
	  function getContrastText(background) {
	    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
	    return contrastText;
	  }
	  const augmentColor = ({
	    color,
	    name,
	    mainShade = 500,
	    lightShade = 300,
	    darkShade = 700
	  }) => {
	    color = {
	      ...color
	    };
	    if (!color.main && color[mainShade]) {
	      color.main = color[mainShade];
	    }
	    if (!color.hasOwnProperty('main')) {
	      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : '', mainShade));
	    }
	    if (typeof color.main !== 'string') {
	      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : '', JSON.stringify(color.main)));
	    }
	    addLightOrDark(color, 'light', lightShade, tonalOffset);
	    addLightOrDark(color, 'dark', darkShade, tonalOffset);
	    if (!color.contrastText) {
	      color.contrastText = getContrastText(color.main);
	    }
	    return color;
	  };
	  let modeHydrated;
	  if (mode === 'light') {
	    modeHydrated = getLight();
	  } else if (mode === 'dark') {
	    modeHydrated = getDark();
	  }
	  const paletteOutput = deepmerge({
	    // A collection of common colors.
	    common: {
	      ...common
	    },
	    // prevent mutable object.
	    // The palette mode, can be light or dark.
	    mode,
	    // The colors used to represent primary interface elements for a user.
	    primary: augmentColor({
	      color: primary,
	      name: 'primary'
	    }),
	    // The colors used to represent secondary interface elements for a user.
	    secondary: augmentColor({
	      color: secondary,
	      name: 'secondary',
	      mainShade: 'A400',
	      lightShade: 'A200',
	      darkShade: 'A700'
	    }),
	    // The colors used to represent interface elements that the user should be made aware of.
	    error: augmentColor({
	      color: error,
	      name: 'error'
	    }),
	    // The colors used to represent potentially dangerous actions or important messages.
	    warning: augmentColor({
	      color: warning,
	      name: 'warning'
	    }),
	    // The colors used to present information to the user that is neutral and not necessarily important.
	    info: augmentColor({
	      color: info,
	      name: 'info'
	    }),
	    // The colors used to indicate the successful completion of an action that user triggered.
	    success: augmentColor({
	      color: success,
	      name: 'success'
	    }),
	    // The grey colors.
	    grey,
	    // Used by `getContrastText()` to maximize the contrast between
	    // the background and the text.
	    contrastThreshold,
	    // Takes a background color and returns the text color that maximizes the contrast.
	    getContrastText,
	    // Generate a rich color object.
	    augmentColor,
	    // Used by the functions below to shift a color's luminance by approximately
	    // two indexes within its tonal palette.
	    // E.g., shift from Red 500 to Red 300 or Red 700.
	    tonalOffset,
	    // The light and dark mode object.
	    ...modeHydrated
	  }, other);
	  return paletteOutput;
	}

	function prepareTypographyVars(typography) {
	  const vars = {};
	  const entries = Object.entries(typography);
	  entries.forEach(entry => {
	    const [key, value] = entry;
	    if (typeof value === 'object') {
	      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ''}${value.fontVariant ? `${value.fontVariant} ` : ''}${value.fontWeight ? `${value.fontWeight} ` : ''}${value.fontStretch ? `${value.fontStretch} ` : ''}${value.fontSize || ''}${value.lineHeight ? `/${value.lineHeight} ` : ''}${value.fontFamily || ''}`;
	    }
	  });
	  return vars;
	}

	function createMixins(breakpoints, mixins) {
	  return {
	    toolbar: {
	      minHeight: 56,
	      [breakpoints.up('xs')]: {
	        '@media (orientation: landscape)': {
	          minHeight: 48
	        }
	      },
	      [breakpoints.up('sm')]: {
	        minHeight: 64
	      }
	    },
	    ...mixins
	  };
	}

	function round$1(value) {
	  return Math.round(value * 1e5) / 1e5;
	}
	const caseAllCaps = {
	  textTransform: 'uppercase'
	};
	const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';

	/**
	 * @see @link{https://m2.material.io/design/typography/the-type-system.html}
	 * @see @link{https://m2.material.io/design/typography/understanding-typography.html}
	 */
	function createTypography(palette, typography) {
	  const {
	    fontFamily = defaultFontFamily,
	    // The default font size of the Material Specification.
	    fontSize = 14,
	    // px
	    fontWeightLight = 300,
	    fontWeightRegular = 400,
	    fontWeightMedium = 500,
	    fontWeightBold = 700,
	    // Tell MUI what's the font-size on the html element.
	    // 16px is the default font-size used by browsers.
	    htmlFontSize = 16,
	    // Apply the CSS properties to all the variants.
	    allVariants,
	    pxToRem: pxToRem2,
	    ...other
	  } = typeof typography === 'function' ? typography(palette) : typography;
	  const coef = fontSize / 14;
	  const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);
	  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
	    fontFamily,
	    fontWeight,
	    fontSize: pxToRem(size),
	    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
	    lineHeight,
	    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
	    // across font-families can cause issues with the kerning.
	    ...(fontFamily === defaultFontFamily ? {
	      letterSpacing: `${round$1(letterSpacing / size)}em`
	    } : {}),
	    ...casing,
	    ...allVariants
	  });
	  const variants = {
	    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
	    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
	    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
	    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
	    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
	    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
	    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
	    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
	    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
	    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
	    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
	    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
	    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
	    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
	    inherit: {
	      fontFamily: 'inherit',
	      fontWeight: 'inherit',
	      fontSize: 'inherit',
	      lineHeight: 'inherit',
	      letterSpacing: 'inherit'
	    }
	  };
	  return deepmerge({
	    htmlFontSize,
	    pxToRem,
	    fontFamily,
	    fontSize,
	    fontWeightLight,
	    fontWeightRegular,
	    fontWeightMedium,
	    fontWeightBold,
	    ...variants
	  }, other, {
	    clone: false // No need to clone deep
	  });
	}

	const shadowKeyUmbraOpacity = 0.2;
	const shadowKeyPenumbraOpacity = 0.14;
	const shadowAmbientShadowOpacity = 0.12;
	function createShadow(...px) {
	  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
	}

	// Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
	const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];

	// Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
	// to learn the context in which each easing should be used.
	const easing = {
	  // This is the most common easing curve.
	  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
	  // Objects enter the screen at full velocity from off-screen and
	  // slowly decelerate to a resting point.
	  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
	  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
	  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
	  // The sharp curve is used by objects that may return to the screen at any time.
	  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
	};

	// Follow https://m2.material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
	// to learn when use what timing
	const duration = {
	  shortest: 150,
	  shorter: 200,
	  short: 250,
	  // most basic recommended timing
	  standard: 300,
	  // this is to be used in complex animations
	  complex: 375,
	  // recommended when something is entering screen
	  enteringScreen: 225,
	  // recommended when something is leaving screen
	  leavingScreen: 195
	};
	function formatMs(milliseconds) {
	  return `${Math.round(milliseconds)}ms`;
	}
	function getAutoHeightDuration(height) {
	  if (!height) {
	    return 0;
	  }
	  const constant = height / 36;

	  // https://www.desmos.com/calculator/vbrp3ggqet
	  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3000);
	}
	function createTransitions(inputTransitions) {
	  const mergedEasing = {
	    ...easing,
	    ...inputTransitions.easing
	  };
	  const mergedDuration = {
	    ...duration,
	    ...inputTransitions.duration
	  };
	  const create = (props = ['all'], options = {}) => {
	    const {
	      duration: durationOption = mergedDuration.standard,
	      easing: easingOption = mergedEasing.easeInOut,
	      delay = 0,
	      ...other
	    } = options;
	    return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
	  };
	  return {
	    getAutoHeightDuration,
	    create,
	    ...inputTransitions,
	    easing: mergedEasing,
	    duration: mergedDuration
	  };
	}

	// We need to centralize the zIndex definitions as they work
	// like global values in the browser.
	const zIndex = {
	  mobileStepper: 1000,
	  fab: 1050,
	  speedDial: 1050,
	  appBar: 1100,
	  drawer: 1200,
	  modal: 1300,
	  snackbar: 1400,
	  tooltip: 1500
	};

	/* eslint-disable import/prefer-default-export */
	function isSerializable(val) {
	  return isPlainObject(val) || typeof val === 'undefined' || typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number' || Array.isArray(val);
	}

	/**
	 * `baseTheme` usually comes from `createTheme()` or `extendTheme()`.
	 *
	 * This function is intended to be used with zero-runtime CSS-in-JS like Pigment CSS
	 * For example, in a Next.js project:
	 *
	 * ```js
	 * // next.config.js
	 * const { extendTheme } = require('@mui/material/styles');
	 *
	 * const theme = extendTheme();
	 * // `.toRuntimeSource` is Pigment CSS specific to create a theme that is available at runtime.
	 * theme.toRuntimeSource = stringifyTheme;
	 *
	 * module.exports = withPigment({
	 *  theme,
	 * });
	 * ```
	 */
	function stringifyTheme(baseTheme = {}) {
	  const serializableTheme = {
	    ...baseTheme
	  };
	  function serializeTheme(object) {
	    const array = Object.entries(object);
	    // eslint-disable-next-line no-plusplus
	    for (let index = 0; index < array.length; index++) {
	      const [key, value] = array[index];
	      if (!isSerializable(value) || key.startsWith('unstable_')) {
	        delete object[key];
	      } else if (isPlainObject(value)) {
	        object[key] = {
	          ...value
	        };
	        serializeTheme(object[key]);
	      }
	    }
	  }
	  serializeTheme(serializableTheme);
	  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
	}

	function createThemeNoVars(options = {}, ...args) {
	  const {
	    breakpoints: breakpointsInput,
	    mixins: mixinsInput = {},
	    spacing: spacingInput,
	    palette: paletteInput = {},
	    transitions: transitionsInput = {},
	    typography: typographyInput = {},
	    shape: shapeInput,
	    ...other
	  } = options;
	  if (options.vars &&
	  // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
	  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
	  options.generateThemeVars === undefined) {
	    throw new Error(formatMuiErrorMessage(20));
	  }
	  const palette = createPalette(paletteInput);
	  const systemTheme = createTheme$1(options);
	  let muiTheme = deepmerge(systemTheme, {
	    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
	    palette,
	    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
	    shadows: shadows.slice(),
	    typography: createTypography(palette, typographyInput),
	    transitions: createTransitions(transitionsInput),
	    zIndex: {
	      ...zIndex
	    }
	  });
	  muiTheme = deepmerge(muiTheme, other);
	  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	  muiTheme.unstable_sxConfig = {
	    ...defaultSxConfig,
	    ...other?.unstable_sxConfig
	  };
	  muiTheme.unstable_sx = function sx(props) {
	    return styleFunctionSx({
	      sx: props,
	      theme: this
	    });
	  };
	  muiTheme.toRuntimeSource = stringifyTheme; // for Pigment CSS integration

	  return muiTheme;
	}

	// Inspired by https://github.com/material-components/material-components-ios/blob/bca36107405594d5b7b16265a5b0ed698f85a5ee/components/Elevation/src/UIColor%2BMaterialElevation.m#L61
	function getOverlayAlpha(elevation) {
	  let alphaValue;
	  if (elevation < 1) {
	    alphaValue = 5.11916 * elevation ** 2;
	  } else {
	    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
	  }
	  return Math.round(alphaValue * 10) / 1000;
	}

	const defaultDarkOverlays = [...Array(25)].map((_, index) => {
	  if (index === 0) {
	    return 'none';
	  }
	  const overlay = getOverlayAlpha(index);
	  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
	});
	function getOpacity(mode) {
	  return {
	    inputPlaceholder: mode === 'dark' ? 0.5 : 0.42,
	    inputUnderline: mode === 'dark' ? 0.7 : 0.42,
	    switchTrackDisabled: mode === 'dark' ? 0.2 : 0.12,
	    switchTrack: mode === 'dark' ? 0.3 : 0.38
	  };
	}
	function getOverlays(mode) {
	  return mode === 'dark' ? defaultDarkOverlays : [];
	}
	function createColorScheme(options) {
	  const {
	    palette: paletteInput = {
	      mode: 'light'
	    },
	    // need to cast to avoid module augmentation test
	    opacity,
	    overlays,
	    ...rest
	  } = options;
	  const palette = createPalette(paletteInput);
	  return {
	    palette,
	    opacity: {
	      ...getOpacity(palette.mode),
	      ...opacity
	    },
	    overlays: overlays || getOverlays(palette.mode),
	    ...rest
	  };
	}

	function shouldSkipGeneratingVar(keys) {
	  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) ||
	  // ends with sxConfig
	  keys[0] === 'palette' && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
	}

	/**
	 * @internal These variables should not appear in the :root stylesheet when the `defaultColorScheme="dark"`
	 */
	const excludeVariablesFromRoot = cssVarPrefix => [...[...Array(25)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ''}overlays-${index}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ''}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ''}palette-AppBar-darkColor`];

	var defaultGetSelector = theme => (colorScheme, css) => {
	  const root = theme.rootSelector || ':root';
	  const selector = theme.colorSchemeSelector;
	  let rule = selector;
	  if (selector === 'class') {
	    rule = '.%s';
	  }
	  if (selector === 'data') {
	    rule = '[data-%s]';
	  }
	  if (selector?.startsWith('data-') && !selector.includes('%s')) {
	    // 'data-mui-color-scheme' -> '[data-mui-color-scheme="%s"]'
	    rule = `[${selector}="%s"]`;
	  }
	  if (theme.defaultColorScheme === colorScheme) {
	    if (colorScheme === 'dark') {
	      const excludedVariables = {};
	      excludeVariablesFromRoot(theme.cssVarPrefix).forEach(cssVar => {
	        excludedVariables[cssVar] = css[cssVar];
	        delete css[cssVar];
	      });
	      if (rule === 'media') {
	        return {
	          [root]: css,
	          [`@media (prefers-color-scheme: dark)`]: {
	            [root]: excludedVariables
	          }
	        };
	      }
	      if (rule) {
	        return {
	          [rule.replace('%s', colorScheme)]: excludedVariables,
	          [`${root}, ${rule.replace('%s', colorScheme)}`]: css
	        };
	      }
	      return {
	        [root]: {
	          ...css,
	          ...excludedVariables
	        }
	      };
	    }
	    if (rule && rule !== 'media') {
	      return `${root}, ${rule.replace('%s', String(colorScheme))}`;
	    }
	  } else if (colorScheme) {
	    if (rule === 'media') {
	      return {
	        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
	          [root]: css
	        }
	      };
	    }
	    if (rule) {
	      return rule.replace('%s', String(colorScheme));
	    }
	  }
	  return root;
	};

	function assignNode(obj, keys) {
	  keys.forEach(k => {
	    if (!obj[k]) {
	      obj[k] = {};
	    }
	  });
	}
	function setColor(obj, key, defaultValue) {
	  if (!obj[key] && defaultValue) {
	    obj[key] = defaultValue;
	  }
	}
	function toRgb(color) {
	  if (typeof color !== 'string' || !color.startsWith('hsl')) {
	    return color;
	  }
	  return hslToRgb(color);
	}
	function setColorChannel(obj, key) {
	  if (!(`${key}Channel` in obj)) {
	    // custom channel token is not provided, generate one.
	    // if channel token can't be generated, show a warning.
	    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
	  }
	}
	function getSpacingVal(spacingInput) {
	  if (typeof spacingInput === 'number') {
	    return `${spacingInput}px`;
	  }
	  if (typeof spacingInput === 'string' || typeof spacingInput === 'function' || Array.isArray(spacingInput)) {
	    return spacingInput;
	  }
	  return '8px';
	}
	const silent = fn => {
	  try {
	    return fn();
	  } catch (error) {
	    // ignore error
	  }
	  return undefined;
	};
	const createGetCssVar = (cssVarPrefix = 'mui') => createGetCssVar$1(cssVarPrefix);
	function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
	  if (!scheme) {
	    return undefined;
	  }
	  scheme = scheme === true ? {} : scheme;
	  const mode = colorScheme === 'dark' ? 'dark' : 'light';
	  if (!restTheme) {
	    colorSchemes[colorScheme] = createColorScheme({
	      ...scheme,
	      palette: {
	        mode,
	        ...scheme?.palette
	      }
	    });
	    return undefined;
	  }
	  const {
	    palette,
	    ...muiTheme
	  } = createThemeNoVars({
	    ...restTheme,
	    palette: {
	      mode,
	      ...scheme?.palette
	    }
	  });
	  colorSchemes[colorScheme] = {
	    ...scheme,
	    palette,
	    opacity: {
	      ...getOpacity(mode),
	      ...scheme?.opacity
	    },
	    overlays: scheme?.overlays || getOverlays(mode)
	  };
	  return muiTheme;
	}

	/**
	 * A default `createThemeWithVars` comes with a single color scheme, either `light` or `dark` based on the `defaultColorScheme`.
	 * This is better suited for apps that only need a single color scheme.
	 *
	 * To enable built-in `light` and `dark` color schemes, either:
	 * 1. provide a `colorSchemeSelector` to define how the color schemes will change.
	 * 2. provide `colorSchemes.dark` will set `colorSchemeSelector: 'media'` by default.
	 */
	function createThemeWithVars(options = {}, ...args) {
	  const {
	    colorSchemes: colorSchemesInput = {
	      light: true
	    },
	    defaultColorScheme: defaultColorSchemeInput,
	    disableCssColorScheme = false,
	    cssVarPrefix = 'mui',
	    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
	    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? 'media' : undefined,
	    rootSelector = ':root',
	    ...input
	  } = options;
	  const firstColorScheme = Object.keys(colorSchemesInput)[0];
	  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== 'light' ? 'light' : firstColorScheme);
	  const getCssVar = createGetCssVar(cssVarPrefix);
	  const {
	    [defaultColorScheme]: defaultSchemeInput,
	    light: builtInLight,
	    dark: builtInDark,
	    ...customColorSchemes
	  } = colorSchemesInput;
	  const colorSchemes = {
	    ...customColorSchemes
	  };
	  let defaultScheme = defaultSchemeInput;

	  // For built-in light and dark color schemes, ensure that the value is valid if they are the default color scheme.
	  if (defaultColorScheme === 'dark' && !('dark' in colorSchemesInput) || defaultColorScheme === 'light' && !('light' in colorSchemesInput)) {
	    defaultScheme = true;
	  }
	  if (!defaultScheme) {
	    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
	  }

	  // Create the palette for the default color scheme, either `light`, `dark`, or custom color scheme.
	  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
	  if (builtInLight && !colorSchemes.light) {
	    attachColorScheme$1(colorSchemes, builtInLight, undefined, 'light');
	  }
	  if (builtInDark && !colorSchemes.dark) {
	    attachColorScheme$1(colorSchemes, builtInDark, undefined, 'dark');
	  }
	  let theme = {
	    defaultColorScheme,
	    ...muiTheme,
	    cssVarPrefix,
	    colorSchemeSelector: selector,
	    rootSelector,
	    getCssVar,
	    colorSchemes,
	    font: {
	      ...prepareTypographyVars(muiTheme.typography),
	      ...muiTheme.font
	    },
	    spacing: getSpacingVal(input.spacing)
	  };
	  Object.keys(theme.colorSchemes).forEach(key => {
	    const palette = theme.colorSchemes[key].palette;
	    const setCssVarColor = cssVar => {
	      const tokens = cssVar.split('-');
	      const color = tokens[1];
	      const colorToken = tokens[2];
	      return getCssVar(cssVar, palette[color][colorToken]);
	    };

	    // attach black & white channels to common node
	    if (palette.mode === 'light') {
	      setColor(palette.common, 'background', '#fff');
	      setColor(palette.common, 'onBackground', '#000');
	    }
	    if (palette.mode === 'dark') {
	      setColor(palette.common, 'background', '#000');
	      setColor(palette.common, 'onBackground', '#fff');
	    }

	    // assign component variables
	    assignNode(palette, ['Alert', 'AppBar', 'Avatar', 'Button', 'Chip', 'FilledInput', 'LinearProgress', 'Skeleton', 'Slider', 'SnackbarContent', 'SpeedDialAction', 'StepConnector', 'StepContent', 'Switch', 'TableCell', 'Tooltip']);
	    if (palette.mode === 'light') {
	      setColor(palette.Alert, 'errorColor', private_safeDarken(palette.error.light, 0.6));
	      setColor(palette.Alert, 'infoColor', private_safeDarken(palette.info.light, 0.6));
	      setColor(palette.Alert, 'successColor', private_safeDarken(palette.success.light, 0.6));
	      setColor(palette.Alert, 'warningColor', private_safeDarken(palette.warning.light, 0.6));
	      setColor(palette.Alert, 'errorFilledBg', setCssVarColor('palette-error-main'));
	      setColor(palette.Alert, 'infoFilledBg', setCssVarColor('palette-info-main'));
	      setColor(palette.Alert, 'successFilledBg', setCssVarColor('palette-success-main'));
	      setColor(palette.Alert, 'warningFilledBg', setCssVarColor('palette-warning-main'));
	      setColor(palette.Alert, 'errorFilledColor', silent(() => palette.getContrastText(palette.error.main)));
	      setColor(palette.Alert, 'infoFilledColor', silent(() => palette.getContrastText(palette.info.main)));
	      setColor(palette.Alert, 'successFilledColor', silent(() => palette.getContrastText(palette.success.main)));
	      setColor(palette.Alert, 'warningFilledColor', silent(() => palette.getContrastText(palette.warning.main)));
	      setColor(palette.Alert, 'errorStandardBg', private_safeLighten(palette.error.light, 0.9));
	      setColor(palette.Alert, 'infoStandardBg', private_safeLighten(palette.info.light, 0.9));
	      setColor(palette.Alert, 'successStandardBg', private_safeLighten(palette.success.light, 0.9));
	      setColor(palette.Alert, 'warningStandardBg', private_safeLighten(palette.warning.light, 0.9));
	      setColor(palette.Alert, 'errorIconColor', setCssVarColor('palette-error-main'));
	      setColor(palette.Alert, 'infoIconColor', setCssVarColor('palette-info-main'));
	      setColor(palette.Alert, 'successIconColor', setCssVarColor('palette-success-main'));
	      setColor(palette.Alert, 'warningIconColor', setCssVarColor('palette-warning-main'));
	      setColor(palette.AppBar, 'defaultBg', setCssVarColor('palette-grey-100'));
	      setColor(palette.Avatar, 'defaultBg', setCssVarColor('palette-grey-400'));
	      setColor(palette.Button, 'inheritContainedBg', setCssVarColor('palette-grey-300'));
	      setColor(palette.Button, 'inheritContainedHoverBg', setCssVarColor('palette-grey-A100'));
	      setColor(palette.Chip, 'defaultBorder', setCssVarColor('palette-grey-400'));
	      setColor(palette.Chip, 'defaultAvatarColor', setCssVarColor('palette-grey-700'));
	      setColor(palette.Chip, 'defaultIconColor', setCssVarColor('palette-grey-700'));
	      setColor(palette.FilledInput, 'bg', 'rgba(0, 0, 0, 0.06)');
	      setColor(palette.FilledInput, 'hoverBg', 'rgba(0, 0, 0, 0.09)');
	      setColor(palette.FilledInput, 'disabledBg', 'rgba(0, 0, 0, 0.12)');
	      setColor(palette.LinearProgress, 'primaryBg', private_safeLighten(palette.primary.main, 0.62));
	      setColor(palette.LinearProgress, 'secondaryBg', private_safeLighten(palette.secondary.main, 0.62));
	      setColor(palette.LinearProgress, 'errorBg', private_safeLighten(palette.error.main, 0.62));
	      setColor(palette.LinearProgress, 'infoBg', private_safeLighten(palette.info.main, 0.62));
	      setColor(palette.LinearProgress, 'successBg', private_safeLighten(palette.success.main, 0.62));
	      setColor(palette.LinearProgress, 'warningBg', private_safeLighten(palette.warning.main, 0.62));
	      setColor(palette.Skeleton, 'bg', `rgba(${setCssVarColor('palette-text-primaryChannel')} / 0.11)`);
	      setColor(palette.Slider, 'primaryTrack', private_safeLighten(palette.primary.main, 0.62));
	      setColor(palette.Slider, 'secondaryTrack', private_safeLighten(palette.secondary.main, 0.62));
	      setColor(palette.Slider, 'errorTrack', private_safeLighten(palette.error.main, 0.62));
	      setColor(palette.Slider, 'infoTrack', private_safeLighten(palette.info.main, 0.62));
	      setColor(palette.Slider, 'successTrack', private_safeLighten(palette.success.main, 0.62));
	      setColor(palette.Slider, 'warningTrack', private_safeLighten(palette.warning.main, 0.62));
	      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
	      setColor(palette.SnackbarContent, 'bg', snackbarContentBackground);
	      setColor(palette.SnackbarContent, 'color', silent(() => palette.getContrastText(snackbarContentBackground)));
	      setColor(palette.SpeedDialAction, 'fabHoverBg', private_safeEmphasize(palette.background.paper, 0.15));
	      setColor(palette.StepConnector, 'border', setCssVarColor('palette-grey-400'));
	      setColor(palette.StepContent, 'border', setCssVarColor('palette-grey-400'));
	      setColor(palette.Switch, 'defaultColor', setCssVarColor('palette-common-white'));
	      setColor(palette.Switch, 'defaultDisabledColor', setCssVarColor('palette-grey-100'));
	      setColor(palette.Switch, 'primaryDisabledColor', private_safeLighten(palette.primary.main, 0.62));
	      setColor(palette.Switch, 'secondaryDisabledColor', private_safeLighten(palette.secondary.main, 0.62));
	      setColor(palette.Switch, 'errorDisabledColor', private_safeLighten(palette.error.main, 0.62));
	      setColor(palette.Switch, 'infoDisabledColor', private_safeLighten(palette.info.main, 0.62));
	      setColor(palette.Switch, 'successDisabledColor', private_safeLighten(palette.success.main, 0.62));
	      setColor(palette.Switch, 'warningDisabledColor', private_safeLighten(palette.warning.main, 0.62));
	      setColor(palette.TableCell, 'border', private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
	      setColor(palette.Tooltip, 'bg', private_safeAlpha(palette.grey[700], 0.92));
	    }
	    if (palette.mode === 'dark') {
	      setColor(palette.Alert, 'errorColor', private_safeLighten(palette.error.light, 0.6));
	      setColor(palette.Alert, 'infoColor', private_safeLighten(palette.info.light, 0.6));
	      setColor(palette.Alert, 'successColor', private_safeLighten(palette.success.light, 0.6));
	      setColor(palette.Alert, 'warningColor', private_safeLighten(palette.warning.light, 0.6));
	      setColor(palette.Alert, 'errorFilledBg', setCssVarColor('palette-error-dark'));
	      setColor(palette.Alert, 'infoFilledBg', setCssVarColor('palette-info-dark'));
	      setColor(palette.Alert, 'successFilledBg', setCssVarColor('palette-success-dark'));
	      setColor(palette.Alert, 'warningFilledBg', setCssVarColor('palette-warning-dark'));
	      setColor(palette.Alert, 'errorFilledColor', silent(() => palette.getContrastText(palette.error.dark)));
	      setColor(palette.Alert, 'infoFilledColor', silent(() => palette.getContrastText(palette.info.dark)));
	      setColor(palette.Alert, 'successFilledColor', silent(() => palette.getContrastText(palette.success.dark)));
	      setColor(palette.Alert, 'warningFilledColor', silent(() => palette.getContrastText(palette.warning.dark)));
	      setColor(palette.Alert, 'errorStandardBg', private_safeDarken(palette.error.light, 0.9));
	      setColor(palette.Alert, 'infoStandardBg', private_safeDarken(palette.info.light, 0.9));
	      setColor(palette.Alert, 'successStandardBg', private_safeDarken(palette.success.light, 0.9));
	      setColor(palette.Alert, 'warningStandardBg', private_safeDarken(palette.warning.light, 0.9));
	      setColor(palette.Alert, 'errorIconColor', setCssVarColor('palette-error-main'));
	      setColor(palette.Alert, 'infoIconColor', setCssVarColor('palette-info-main'));
	      setColor(palette.Alert, 'successIconColor', setCssVarColor('palette-success-main'));
	      setColor(palette.Alert, 'warningIconColor', setCssVarColor('palette-warning-main'));
	      setColor(palette.AppBar, 'defaultBg', setCssVarColor('palette-grey-900'));
	      setColor(palette.AppBar, 'darkBg', setCssVarColor('palette-background-paper')); // specific for dark mode
	      setColor(palette.AppBar, 'darkColor', setCssVarColor('palette-text-primary')); // specific for dark mode
	      setColor(palette.Avatar, 'defaultBg', setCssVarColor('palette-grey-600'));
	      setColor(palette.Button, 'inheritContainedBg', setCssVarColor('palette-grey-800'));
	      setColor(palette.Button, 'inheritContainedHoverBg', setCssVarColor('palette-grey-700'));
	      setColor(palette.Chip, 'defaultBorder', setCssVarColor('palette-grey-700'));
	      setColor(palette.Chip, 'defaultAvatarColor', setCssVarColor('palette-grey-300'));
	      setColor(palette.Chip, 'defaultIconColor', setCssVarColor('palette-grey-300'));
	      setColor(palette.FilledInput, 'bg', 'rgba(255, 255, 255, 0.09)');
	      setColor(palette.FilledInput, 'hoverBg', 'rgba(255, 255, 255, 0.13)');
	      setColor(palette.FilledInput, 'disabledBg', 'rgba(255, 255, 255, 0.12)');
	      setColor(palette.LinearProgress, 'primaryBg', private_safeDarken(palette.primary.main, 0.5));
	      setColor(palette.LinearProgress, 'secondaryBg', private_safeDarken(palette.secondary.main, 0.5));
	      setColor(palette.LinearProgress, 'errorBg', private_safeDarken(palette.error.main, 0.5));
	      setColor(palette.LinearProgress, 'infoBg', private_safeDarken(palette.info.main, 0.5));
	      setColor(palette.LinearProgress, 'successBg', private_safeDarken(palette.success.main, 0.5));
	      setColor(palette.LinearProgress, 'warningBg', private_safeDarken(palette.warning.main, 0.5));
	      setColor(palette.Skeleton, 'bg', `rgba(${setCssVarColor('palette-text-primaryChannel')} / 0.13)`);
	      setColor(palette.Slider, 'primaryTrack', private_safeDarken(palette.primary.main, 0.5));
	      setColor(palette.Slider, 'secondaryTrack', private_safeDarken(palette.secondary.main, 0.5));
	      setColor(palette.Slider, 'errorTrack', private_safeDarken(palette.error.main, 0.5));
	      setColor(palette.Slider, 'infoTrack', private_safeDarken(palette.info.main, 0.5));
	      setColor(palette.Slider, 'successTrack', private_safeDarken(palette.success.main, 0.5));
	      setColor(palette.Slider, 'warningTrack', private_safeDarken(palette.warning.main, 0.5));
	      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
	      setColor(palette.SnackbarContent, 'bg', snackbarContentBackground);
	      setColor(palette.SnackbarContent, 'color', silent(() => palette.getContrastText(snackbarContentBackground)));
	      setColor(palette.SpeedDialAction, 'fabHoverBg', private_safeEmphasize(palette.background.paper, 0.15));
	      setColor(palette.StepConnector, 'border', setCssVarColor('palette-grey-600'));
	      setColor(palette.StepContent, 'border', setCssVarColor('palette-grey-600'));
	      setColor(palette.Switch, 'defaultColor', setCssVarColor('palette-grey-300'));
	      setColor(palette.Switch, 'defaultDisabledColor', setCssVarColor('palette-grey-600'));
	      setColor(palette.Switch, 'primaryDisabledColor', private_safeDarken(palette.primary.main, 0.55));
	      setColor(palette.Switch, 'secondaryDisabledColor', private_safeDarken(palette.secondary.main, 0.55));
	      setColor(palette.Switch, 'errorDisabledColor', private_safeDarken(palette.error.main, 0.55));
	      setColor(palette.Switch, 'infoDisabledColor', private_safeDarken(palette.info.main, 0.55));
	      setColor(palette.Switch, 'successDisabledColor', private_safeDarken(palette.success.main, 0.55));
	      setColor(palette.Switch, 'warningDisabledColor', private_safeDarken(palette.warning.main, 0.55));
	      setColor(palette.TableCell, 'border', private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
	      setColor(palette.Tooltip, 'bg', private_safeAlpha(palette.grey[700], 0.92));
	    }

	    // MUI X - DataGrid needs this token.
	    setColorChannel(palette.background, 'default');

	    // added for consistency with the `background.default` token
	    setColorChannel(palette.background, 'paper');
	    setColorChannel(palette.common, 'background');
	    setColorChannel(palette.common, 'onBackground');
	    setColorChannel(palette, 'divider');
	    Object.keys(palette).forEach(color => {
	      const colors = palette[color];

	      // The default palettes (primary, secondary, error, info, success, and warning) errors are handled by the above `createTheme(...)`.

	      if (color !== 'tonalOffset' && colors && typeof colors === 'object') {
	        // Silent the error for custom palettes.
	        if (colors.main) {
	          setColor(palette[color], 'mainChannel', private_safeColorChannel(toRgb(colors.main)));
	        }
	        if (colors.light) {
	          setColor(palette[color], 'lightChannel', private_safeColorChannel(toRgb(colors.light)));
	        }
	        if (colors.dark) {
	          setColor(palette[color], 'darkChannel', private_safeColorChannel(toRgb(colors.dark)));
	        }
	        if (colors.contrastText) {
	          setColor(palette[color], 'contrastTextChannel', private_safeColorChannel(toRgb(colors.contrastText)));
	        }
	        if (color === 'text') {
	          // Text colors: text.primary, text.secondary
	          setColorChannel(palette[color], 'primary');
	          setColorChannel(palette[color], 'secondary');
	        }
	        if (color === 'action') {
	          // Action colors: action.active, action.selected
	          if (colors.active) {
	            setColorChannel(palette[color], 'active');
	          }
	          if (colors.selected) {
	            setColorChannel(palette[color], 'selected');
	          }
	        }
	      }
	    });
	  });
	  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
	  const parserConfig = {
	    prefix: cssVarPrefix,
	    disableCssColorScheme,
	    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
	    getSelector: defaultGetSelector(theme)
	  };
	  const {
	    vars,
	    generateThemeVars,
	    generateStyleSheets
	  } = prepareCssVars(theme, parserConfig);
	  theme.vars = vars;
	  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
	    theme[key] = value;
	  });
	  theme.generateThemeVars = generateThemeVars;
	  theme.generateStyleSheets = generateStyleSheets;
	  theme.generateSpacing = function generateSpacing() {
	    return createSpacing(input.spacing, createUnarySpacing(this));
	  };
	  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
	  theme.spacing = theme.generateSpacing();
	  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
	  theme.unstable_sxConfig = {
	    ...defaultSxConfig,
	    ...input?.unstable_sxConfig
	  };
	  theme.unstable_sx = function sx(props) {
	    return styleFunctionSx({
	      sx: props,
	      theme: this
	    });
	  };
	  theme.toRuntimeSource = stringifyTheme; // for Pigment CSS integration

	  return theme;
	}

	// eslint-disable-next-line consistent-return
	function attachColorScheme(theme, scheme, colorScheme) {
	  if (!theme.colorSchemes) {
	    return undefined;
	  }
	  if (colorScheme) {
	    theme.colorSchemes[scheme] = {
	      ...(colorScheme !== true && colorScheme),
	      palette: createPalette({
	        ...(colorScheme === true ? {} : colorScheme.palette),
	        mode: scheme
	      }) // cast type to skip module augmentation test
	    };
	  }
	}

	/**
	 * Generate a theme base on the options received.
	 * @param options Takes an incomplete theme object and adds the missing parts.
	 * @param args Deep merge the arguments with the about to be returned theme.
	 * @returns A complete, ready-to-use theme object.
	 */
	function createTheme(options = {},
	// cast type to skip module augmentation test
	...args) {
	  const {
	    palette,
	    cssVariables = false,
	    colorSchemes: initialColorSchemes = !palette ? {
	      light: true
	    } : undefined,
	    defaultColorScheme: initialDefaultColorScheme = palette?.mode,
	    ...rest
	  } = options;
	  const defaultColorSchemeInput = initialDefaultColorScheme || 'light';
	  const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
	  const colorSchemesInput = {
	    ...initialColorSchemes,
	    ...(palette ? {
	      [defaultColorSchemeInput]: {
	        ...(typeof defaultScheme !== 'boolean' && defaultScheme),
	        palette
	      }
	    } : undefined)
	  };
	  if (cssVariables === false) {
	    if (!('colorSchemes' in options)) {
	      // Behaves exactly as v5
	      return createThemeNoVars(options, ...args);
	    }
	    let paletteOptions = palette;
	    if (!('palette' in options)) {
	      if (colorSchemesInput[defaultColorSchemeInput]) {
	        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
	          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
	        } else if (defaultColorSchemeInput === 'dark') {
	          // @ts-ignore to prevent the module augmentation test from failing
	          paletteOptions = {
	            mode: 'dark'
	          };
	        }
	      }
	    }
	    const theme = createThemeNoVars({
	      ...options,
	      palette: paletteOptions
	    }, ...args);
	    theme.defaultColorScheme = defaultColorSchemeInput;
	    theme.colorSchemes = colorSchemesInput;
	    if (theme.palette.mode === 'light') {
	      theme.colorSchemes.light = {
	        ...(colorSchemesInput.light !== true && colorSchemesInput.light),
	        palette: theme.palette
	      };
	      attachColorScheme(theme, 'dark', colorSchemesInput.dark);
	    }
	    if (theme.palette.mode === 'dark') {
	      theme.colorSchemes.dark = {
	        ...(colorSchemesInput.dark !== true && colorSchemesInput.dark),
	        palette: theme.palette
	      };
	      attachColorScheme(theme, 'light', colorSchemesInput.light);
	    }
	    return theme;
	  }
	  if (!palette && !('light' in colorSchemesInput) && defaultColorSchemeInput === 'light') {
	    colorSchemesInput.light = true;
	  }
	  return createThemeWithVars({
	    ...rest,
	    colorSchemes: colorSchemesInput,
	    defaultColorScheme: defaultColorSchemeInput,
	    ...(typeof cssVariables !== 'boolean' && cssVariables)
	  }, ...args);
	}

	const defaultTheme$2 = createTheme();

	var THEME_ID = '$$material';

	function useTheme() {
	  const theme = useTheme$1(defaultTheme$2);
	  return theme[THEME_ID] || theme;
	}

	function GlobalStyles$1(props) {
	  return /*#__PURE__*/jsxRuntimeExports.jsx(GlobalStyles$2, {
	    ...props,
	    defaultTheme: defaultTheme$2,
	    themeId: THEME_ID
	  });
	}

	// copied from @mui/system/createStyled
	function slotShouldForwardProp(prop) {
	  return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
	}

	const rootShouldForwardProp = prop => slotShouldForwardProp(prop) && prop !== 'classes';

	const styled = createStyled({
	  themeId: THEME_ID,
	  defaultTheme: defaultTheme$2,
	  rootShouldForwardProp
	});

	function globalCss(styles) {
	  return function GlobalStylesWrapper(props) {
	    return (
	      /*#__PURE__*/
	      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
	      jsxRuntimeExports.jsx(GlobalStyles$1, {
	        styles: typeof styles === 'function' ? theme => styles({
	          theme,
	          ...props
	        }) : styles
	      })
	    );
	  };
	}

	// eslint-disable-next-line @typescript-eslint/naming-convention
	function internal_createExtendSxProp() {
	  return extendSxProp$1;
	}

	function useDefaultProps(params) {
	  return useDefaultProps$1(params);
	}

	const isDynamicSupport = typeof globalCss({}) === 'function';
	const html = (theme, enableColorScheme) => ({
	  WebkitFontSmoothing: 'antialiased',
	  // Antialiasing.
	  MozOsxFontSmoothing: 'grayscale',
	  // Antialiasing.
	  // Change from `box-sizing: content-box` so that `width`
	  // is not affected by `padding` or `border`.
	  boxSizing: 'border-box',
	  // Fix font resize problem in iOS
	  WebkitTextSizeAdjust: '100%',
	  // When used under CssVarsProvider, colorScheme should not be applied dynamically because it will generate the stylesheet twice for server-rendered applications.
	  ...(enableColorScheme && !theme.vars && {
	    colorScheme: theme.palette.mode
	  })
	});
	const body = theme => ({
	  color: (theme.vars || theme).palette.text.primary,
	  ...theme.typography.body1,
	  backgroundColor: (theme.vars || theme).palette.background.default,
	  '@media print': {
	    // Save printer ink.
	    backgroundColor: (theme.vars || theme).palette.common.white
	  }
	});
	const styles$2 = (theme, enableColorScheme = false) => {
	  const colorSchemeStyles = {};
	  if (enableColorScheme && theme.colorSchemes && typeof theme.getColorSchemeSelector === 'function') {
	    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {
	      const selector = theme.getColorSchemeSelector(key);
	      if (selector.startsWith('@')) {
	        // for @media (prefers-color-scheme), we need to target :root
	        colorSchemeStyles[selector] = {
	          ':root': {
	            colorScheme: scheme.palette?.mode
	          }
	        };
	      } else {
	        // else, it's likely that the selector already target an element with a class or data attribute
	        colorSchemeStyles[selector.replace(/\s*&/, '')] = {
	          colorScheme: scheme.palette?.mode
	        };
	      }
	    });
	  }
	  let defaultStyles = {
	    html: html(theme, enableColorScheme),
	    '*, *::before, *::after': {
	      boxSizing: 'inherit'
	    },
	    'strong, b': {
	      fontWeight: theme.typography.fontWeightBold
	    },
	    body: {
	      margin: 0,
	      // Remove the margin in all browsers.
	      ...body(theme),
	      // Add support for document.body.requestFullScreen().
	      // Other elements, if background transparent, are not supported.
	      '&::backdrop': {
	        backgroundColor: (theme.vars || theme).palette.background.default
	      }
	    },
	    ...colorSchemeStyles
	  };
	  const themeOverrides = theme.components?.MuiCssBaseline?.styleOverrides;
	  if (themeOverrides) {
	    defaultStyles = [defaultStyles, themeOverrides];
	  }
	  return defaultStyles;
	};

	// `ecs` stands for enableColorScheme. This is internal logic to make it work with Pigment CSS, so shorter is better.
	const SELECTOR = 'mui-ecs';
	const staticStyles = theme => {
	  const result = styles$2(theme, false);
	  const baseStyles = Array.isArray(result) ? result[0] : result;
	  if (!theme.vars && baseStyles) {
	    baseStyles.html[`:root:has(${SELECTOR})`] = {
	      colorScheme: theme.palette.mode
	    };
	  }
	  if (theme.colorSchemes) {
	    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {
	      const selector = theme.getColorSchemeSelector(key);
	      if (selector.startsWith('@')) {
	        // for @media (prefers-color-scheme), we need to target :root
	        baseStyles[selector] = {
	          [`:root:not(:has(.${SELECTOR}))`]: {
	            colorScheme: scheme.palette?.mode
	          }
	        };
	      } else {
	        // else, it's likely that the selector already target an element with a class or data attribute
	        baseStyles[selector.replace(/\s*&/, '')] = {
	          [`&:not(:has(.${SELECTOR}))`]: {
	            colorScheme: scheme.palette?.mode
	          }
	        };
	      }
	    });
	  }
	  return result;
	};
	const GlobalStyles = globalCss(isDynamicSupport ? ({
	  theme,
	  enableColorScheme
	}) => styles$2(theme, enableColorScheme) : ({
	  theme
	}) => staticStyles(theme));

	/**
	 * Kickstart an elegant, consistent, and simple baseline to build upon.
	 */
	function CssBaseline(inProps) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiCssBaseline'
	  });
	  const {
	    children,
	    enableColorScheme = false
	  } = props;
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
	    children: [isDynamicSupport && /*#__PURE__*/jsxRuntimeExports.jsx(GlobalStyles, {
	      enableColorScheme: enableColorScheme
	    }), !isDynamicSupport && !enableColorScheme && /*#__PURE__*/jsxRuntimeExports.jsx("span", {
	      className: SELECTOR,
	      style: {
	        display: 'none'
	      }
	    }), children]
	  });
	}

	/**
	 * Safe chained function.
	 *
	 * Will only create a new function if needed,
	 * otherwise will pass back existing functions or null.
	 */
	function createChainedFunction(...funcs) {
	  return funcs.reduce((acc, func) => {
	    if (func == null) {
	      return acc;
	    }
	    return function chainedFunction(...args) {
	      acc.apply(this, args);
	      func.apply(this, args);
	    };
	  }, () => {});
	}

	const memoTheme = unstable_memoTheme;

	function getSvgIconUtilityClass(slot) {
	  return generateUtilityClass('MuiSvgIcon', slot);
	}
	generateUtilityClasses('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge']);

	const useUtilityClasses$c = ownerState => {
	  const {
	    color,
	    fontSize,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', color !== 'inherit' && `color${capitalize(color)}`, `fontSize${capitalize(fontSize)}`]
	  };
	  return composeClasses(slots, getSvgIconUtilityClass, classes);
	};
	const SvgIconRoot = styled('svg', {
	  name: 'MuiSvgIcon',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, ownerState.color !== 'inherit' && styles[`color${capitalize(ownerState.color)}`], styles[`fontSize${capitalize(ownerState.fontSize)}`]];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  userSelect: 'none',
	  width: '1em',
	  height: '1em',
	  display: 'inline-block',
	  flexShrink: 0,
	  transition: theme.transitions?.create?.('fill', {
	    duration: (theme.vars ?? theme).transitions?.duration?.shorter
	  }),
	  variants: [{
	    props: props => !props.hasSvgAsChild,
	    style: {
	      // the <svg> will define the property that has `currentColor`
	      // for example heroicons uses fill="none" and stroke="currentColor"
	      fill: 'currentColor'
	    }
	  }, {
	    props: {
	      fontSize: 'inherit'
	    },
	    style: {
	      fontSize: 'inherit'
	    }
	  }, {
	    props: {
	      fontSize: 'small'
	    },
	    style: {
	      fontSize: theme.typography?.pxToRem?.(20) || '1.25rem'
	    }
	  }, {
	    props: {
	      fontSize: 'medium'
	    },
	    style: {
	      fontSize: theme.typography?.pxToRem?.(24) || '1.5rem'
	    }
	  }, {
	    props: {
	      fontSize: 'large'
	    },
	    style: {
	      fontSize: theme.typography?.pxToRem?.(35) || '2.1875rem'
	    }
	  },
	  // TODO v5 deprecate color prop, v6 remove for sx
	  ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color]) => ({
	    props: {
	      color
	    },
	    style: {
	      color: (theme.vars ?? theme).palette?.[color]?.main
	    }
	  })), {
	    props: {
	      color: 'action'
	    },
	    style: {
	      color: (theme.vars ?? theme).palette?.action?.active
	    }
	  }, {
	    props: {
	      color: 'disabled'
	    },
	    style: {
	      color: (theme.vars ?? theme).palette?.action?.disabled
	    }
	  }, {
	    props: {
	      color: 'inherit'
	    },
	    style: {
	      color: undefined
	    }
	  }]
	})));
	const SvgIcon = /*#__PURE__*/reactExports.forwardRef(function SvgIcon(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiSvgIcon'
	  });
	  const {
	    children,
	    className,
	    color = 'inherit',
	    component = 'svg',
	    fontSize = 'medium',
	    htmlColor,
	    inheritViewBox = false,
	    titleAccess,
	    viewBox = '0 0 24 24',
	    ...other
	  } = props;
	  const hasSvgAsChild = /*#__PURE__*/reactExports.isValidElement(children) && children.type === 'svg';
	  const ownerState = {
	    ...props,
	    color,
	    component,
	    fontSize,
	    instanceFontSize: inProps.fontSize,
	    inheritViewBox,
	    viewBox,
	    hasSvgAsChild
	  };
	  const more = {};
	  if (!inheritViewBox) {
	    more.viewBox = viewBox;
	  }
	  const classes = useUtilityClasses$c(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(SvgIconRoot, {
	    as: component,
	    className: clsx(classes.root, className),
	    focusable: "false",
	    color: htmlColor,
	    "aria-hidden": titleAccess ? undefined : true,
	    role: titleAccess ? 'img' : undefined,
	    ref: ref,
	    ...more,
	    ...other,
	    ...(hasSvgAsChild && children.props),
	    ownerState: ownerState,
	    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /*#__PURE__*/jsxRuntimeExports.jsx("title", {
	      children: titleAccess
	    }) : null]
	  });
	});
	SvgIcon.muiName = 'SvgIcon';

	function createSvgIcon(path, displayName) {
	  function Component(props, ref) {
	    return /*#__PURE__*/jsxRuntimeExports.jsx(SvgIcon, {
	      "data-testid": undefined,
	      ref: ref,
	      ...props,
	      children: path
	    });
	  }
	  Component.muiName = SvgIcon.muiName;
	  return /*#__PURE__*/reactExports.memo(/*#__PURE__*/reactExports.forwardRef(Component));
	}

	// Corresponds to 10 frames at 60 Hz.
	// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
	function debounce(func, wait = 166) {
	  let timeout;
	  function debounced(...args) {
	    const later = () => {
	      // @ts-ignore
	      func.apply(this, args);
	    };
	    clearTimeout(timeout);
	    timeout = setTimeout(later, wait);
	  }
	  debounced.clear = () => {
	    clearTimeout(timeout);
	  };
	  return debounced;
	}

	function ownerDocument(node) {
	  return node && node.ownerDocument || document;
	}

	function ownerWindow(node) {
	  const doc = ownerDocument(node);
	  return doc.defaultView || window;
	}

	/**
	 * TODO v5: consider making it private
	 *
	 * passes {value} to {ref}
	 *
	 * WARNING: Be sure to only call this inside a callback that is passed as a ref.
	 * Otherwise, make sure to cleanup the previous {ref} if it changes. See
	 * https://github.com/mui/material-ui/issues/13539
	 *
	 * Useful if you want to expose the ref of an inner component to the public API
	 * while still using it inside the component.
	 * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
	 */
	function setRef(ref, value) {
	  if (typeof ref === 'function') {
	    ref(value);
	  } else if (ref) {
	    ref.current = value;
	  }
	}

	let globalId = 0;

	// TODO React 17: Remove `useGlobalId` once React 17 support is removed
	function useGlobalId(idOverride) {
	  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
	  const id = idOverride || defaultId;
	  reactExports.useEffect(() => {
	    if (defaultId == null) {
	      // Fallback to this default id when possible.
	      // Use the incrementing value for client-side rendering only.
	      // We can't use it server-side.
	      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
	      globalId += 1;
	      setDefaultId(`mui-${globalId}`);
	    }
	  }, [defaultId]);
	  return id;
	}

	// See https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379 for why
	const safeReact = {
	  ...React$1
	};
	const maybeReactUseId = safeReact.useId;

	/**
	 *
	 * @example <div id={useId()} />
	 * @param idOverride
	 * @returns {string}
	 */
	function useId(idOverride) {
	  // React.useId() is only available from React 17.0.0.
	  if (maybeReactUseId !== undefined) {
	    const reactId = maybeReactUseId();
	    return idOverride ?? reactId;
	  }

	  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler
	  // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.
	  return useGlobalId(idOverride);
	}

	/**
	 * Inspired by https://github.com/facebook/react/issues/14099#issuecomment-440013892
	 * See RFC in https://github.com/reactjs/rfcs/pull/220
	 */

	function useEventCallback(fn) {
	  const ref = reactExports.useRef(fn);
	  useEnhancedEffect(() => {
	    ref.current = fn;
	  });
	  return reactExports.useRef((...args) =>
	  // @ts-expect-error hide `this`
	  (0, ref.current)(...args)).current;
	}

	/**
	 * Merges refs into a single memoized callback ref or `null`.
	 *
	 * ```tsx
	 * const rootRef = React.useRef<Instance>(null);
	 * const refFork = useForkRef(rootRef, props.ref);
	 *
	 * return (
	 *   <Root {...props} ref={refFork} />
	 * );
	 * ```
	 *
	 * @param {Array<React.Ref<Instance> | undefined>} refs The ref array.
	 * @returns {React.RefCallback<Instance> | null} The new ref callback.
	 */
	function useForkRef(...refs) {
	  const cleanupRef = reactExports.useRef(undefined);
	  const refEffect = reactExports.useCallback(instance => {
	    const cleanups = refs.map(ref => {
	      if (ref == null) {
	        return null;
	      }
	      if (typeof ref === 'function') {
	        const refCallback = ref;
	        const refCleanup = refCallback(instance);
	        return typeof refCleanup === 'function' ? refCleanup : () => {
	          refCallback(null);
	        };
	      }
	      ref.current = instance;
	      return () => {
	        ref.current = null;
	      };
	    });
	    return () => {
	      cleanups.forEach(refCleanup => refCleanup?.());
	    };
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, refs);
	  return reactExports.useMemo(() => {
	    if (refs.every(ref => ref == null)) {
	      return null;
	    }
	    return value => {
	      if (cleanupRef.current) {
	        cleanupRef.current();
	        cleanupRef.current = undefined;
	      }
	      if (value != null) {
	        cleanupRef.current = refEffect(value);
	      }
	    };
	    // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- intentionally ignoring that the dependency array must be an array literal
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, refs);
	}

	function _objectWithoutPropertiesLoose(r, e) {
	  if (null == r) return {};
	  var t = {};
	  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
	    if (-1 !== e.indexOf(n)) continue;
	    t[n] = r[n];
	  }
	  return t;
	}

	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}

	function _inheritsLoose(t, o) {
	  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
	}

	var reactDomExports = requireReactDom();
	var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);

	var config = {
	  disabled: false
	};

	var TransitionGroupContext = React.createContext(null);

	var forceReflow = function forceReflow(node) {
	  return node.scrollTop;
	};

	var UNMOUNTED = 'unmounted';
	var EXITED = 'exited';
	var ENTERING = 'entering';
	var ENTERED = 'entered';
	var EXITING = 'exiting';
	/**
	 * The Transition component lets you describe a transition from one component
	 * state to another _over time_ with a simple declarative API. Most commonly
	 * it's used to animate the mounting and unmounting of a component, but can also
	 * be used to describe in-place transition states as well.
	 *
	 * ---
	 *
	 * **Note**: `Transition` is a platform-agnostic base component. If you're using
	 * transitions in CSS, you'll probably want to use
	 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
	 * instead. It inherits all the features of `Transition`, but contains
	 * additional features necessary to play nice with CSS transitions (hence the
	 * name of the component).
	 *
	 * ---
	 *
	 * By default the `Transition` component does not alter the behavior of the
	 * component it renders, it only tracks "enter" and "exit" states for the
	 * components. It's up to you to give meaning and effect to those states. For
	 * example we can add styles to a component when it enters or exits:
	 *
	 * ```jsx
	 * import { Transition } from 'react-transition-group';
	 *
	 * const duration = 300;
	 *
	 * const defaultStyle = {
	 *   transition: `opacity ${duration}ms ease-in-out`,
	 *   opacity: 0,
	 * }
	 *
	 * const transitionStyles = {
	 *   entering: { opacity: 1 },
	 *   entered:  { opacity: 1 },
	 *   exiting:  { opacity: 0 },
	 *   exited:  { opacity: 0 },
	 * };
	 *
	 * const Fade = ({ in: inProp }) => (
	 *   <Transition in={inProp} timeout={duration}>
	 *     {state => (
	 *       <div style={{
	 *         ...defaultStyle,
	 *         ...transitionStyles[state]
	 *       }}>
	 *         I'm a fade Transition!
	 *       </div>
	 *     )}
	 *   </Transition>
	 * );
	 * ```
	 *
	 * There are 4 main states a Transition can be in:
	 *  - `'entering'`
	 *  - `'entered'`
	 *  - `'exiting'`
	 *  - `'exited'`
	 *
	 * Transition state is toggled via the `in` prop. When `true` the component
	 * begins the "Enter" stage. During this stage, the component will shift from
	 * its current transition state, to `'entering'` for the duration of the
	 * transition and then to the `'entered'` stage once it's complete. Let's take
	 * the following example (we'll use the
	 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
	 *
	 * ```jsx
	 * function App() {
	 *   const [inProp, setInProp] = useState(false);
	 *   return (
	 *     <div>
	 *       <Transition in={inProp} timeout={500}>
	 *         {state => (
	 *           // ...
	 *         )}
	 *       </Transition>
	 *       <button onClick={() => setInProp(true)}>
	 *         Click to Enter
	 *       </button>
	 *     </div>
	 *   );
	 * }
	 * ```
	 *
	 * When the button is clicked the component will shift to the `'entering'` state
	 * and stay there for 500ms (the value of `timeout`) before it finally switches
	 * to `'entered'`.
	 *
	 * When `in` is `false` the same thing happens except the state moves from
	 * `'exiting'` to `'exited'`.
	 */

	var Transition = /*#__PURE__*/function (_React$Component) {
	  _inheritsLoose(Transition, _React$Component);

	  function Transition(props, context) {
	    var _this;

	    _this = _React$Component.call(this, props, context) || this;
	    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

	    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
	    var initialStatus;
	    _this.appearStatus = null;

	    if (props.in) {
	      if (appear) {
	        initialStatus = EXITED;
	        _this.appearStatus = ENTERING;
	      } else {
	        initialStatus = ENTERED;
	      }
	    } else {
	      if (props.unmountOnExit || props.mountOnEnter) {
	        initialStatus = UNMOUNTED;
	      } else {
	        initialStatus = EXITED;
	      }
	    }

	    _this.state = {
	      status: initialStatus
	    };
	    _this.nextCallback = null;
	    return _this;
	  }

	  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
	    var nextIn = _ref.in;

	    if (nextIn && prevState.status === UNMOUNTED) {
	      return {
	        status: EXITED
	      };
	    }

	    return null;
	  } // getSnapshotBeforeUpdate(prevProps) {
	  //   let nextStatus = null
	  //   if (prevProps !== this.props) {
	  //     const { status } = this.state
	  //     if (this.props.in) {
	  //       if (status !== ENTERING && status !== ENTERED) {
	  //         nextStatus = ENTERING
	  //       }
	  //     } else {
	  //       if (status === ENTERING || status === ENTERED) {
	  //         nextStatus = EXITING
	  //       }
	  //     }
	  //   }
	  //   return { nextStatus }
	  // }
	  ;

	  var _proto = Transition.prototype;

	  _proto.componentDidMount = function componentDidMount() {
	    this.updateStatus(true, this.appearStatus);
	  };

	  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
	    var nextStatus = null;

	    if (prevProps !== this.props) {
	      var status = this.state.status;

	      if (this.props.in) {
	        if (status !== ENTERING && status !== ENTERED) {
	          nextStatus = ENTERING;
	        }
	      } else {
	        if (status === ENTERING || status === ENTERED) {
	          nextStatus = EXITING;
	        }
	      }
	    }

	    this.updateStatus(false, nextStatus);
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    this.cancelNextCallback();
	  };

	  _proto.getTimeouts = function getTimeouts() {
	    var timeout = this.props.timeout;
	    var exit, enter, appear;
	    exit = enter = appear = timeout;

	    if (timeout != null && typeof timeout !== 'number') {
	      exit = timeout.exit;
	      enter = timeout.enter; // TODO: remove fallback for next major

	      appear = timeout.appear !== undefined ? timeout.appear : enter;
	    }

	    return {
	      exit: exit,
	      enter: enter,
	      appear: appear
	    };
	  };

	  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
	    if (mounting === void 0) {
	      mounting = false;
	    }

	    if (nextStatus !== null) {
	      // nextStatus will always be ENTERING or EXITING.
	      this.cancelNextCallback();

	      if (nextStatus === ENTERING) {
	        if (this.props.unmountOnExit || this.props.mountOnEnter) {
	          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
	          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
	          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

	          if (node) forceReflow(node);
	        }

	        this.performEnter(mounting);
	      } else {
	        this.performExit();
	      }
	    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
	      this.setState({
	        status: UNMOUNTED
	      });
	    }
	  };

	  _proto.performEnter = function performEnter(mounting) {
	    var _this2 = this;

	    var enter = this.props.enter;
	    var appearing = this.context ? this.context.isMounting : mounting;

	    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
	        maybeNode = _ref2[0],
	        maybeAppearing = _ref2[1];

	    var timeouts = this.getTimeouts();
	    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
	    // if we are mounting and running this it means appear _must_ be set

	    if (!mounting && !enter || config.disabled) {
	      this.safeSetState({
	        status: ENTERED
	      }, function () {
	        _this2.props.onEntered(maybeNode);
	      });
	      return;
	    }

	    this.props.onEnter(maybeNode, maybeAppearing);
	    this.safeSetState({
	      status: ENTERING
	    }, function () {
	      _this2.props.onEntering(maybeNode, maybeAppearing);

	      _this2.onTransitionEnd(enterTimeout, function () {
	        _this2.safeSetState({
	          status: ENTERED
	        }, function () {
	          _this2.props.onEntered(maybeNode, maybeAppearing);
	        });
	      });
	    });
	  };

	  _proto.performExit = function performExit() {
	    var _this3 = this;

	    var exit = this.props.exit;
	    var timeouts = this.getTimeouts();
	    var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

	    if (!exit || config.disabled) {
	      this.safeSetState({
	        status: EXITED
	      }, function () {
	        _this3.props.onExited(maybeNode);
	      });
	      return;
	    }

	    this.props.onExit(maybeNode);
	    this.safeSetState({
	      status: EXITING
	    }, function () {
	      _this3.props.onExiting(maybeNode);

	      _this3.onTransitionEnd(timeouts.exit, function () {
	        _this3.safeSetState({
	          status: EXITED
	        }, function () {
	          _this3.props.onExited(maybeNode);
	        });
	      });
	    });
	  };

	  _proto.cancelNextCallback = function cancelNextCallback() {
	    if (this.nextCallback !== null) {
	      this.nextCallback.cancel();
	      this.nextCallback = null;
	    }
	  };

	  _proto.safeSetState = function safeSetState(nextState, callback) {
	    // This shouldn't be necessary, but there are weird race conditions with
	    // setState callbacks and unmounting in testing, so always make sure that
	    // we can cancel any pending setState callbacks after we unmount.
	    callback = this.setNextCallback(callback);
	    this.setState(nextState, callback);
	  };

	  _proto.setNextCallback = function setNextCallback(callback) {
	    var _this4 = this;

	    var active = true;

	    this.nextCallback = function (event) {
	      if (active) {
	        active = false;
	        _this4.nextCallback = null;
	        callback(event);
	      }
	    };

	    this.nextCallback.cancel = function () {
	      active = false;
	    };

	    return this.nextCallback;
	  };

	  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
	    this.setNextCallback(handler);
	    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
	    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

	    if (!node || doesNotHaveTimeoutOrListener) {
	      setTimeout(this.nextCallback, 0);
	      return;
	    }

	    if (this.props.addEndListener) {
	      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
	          maybeNode = _ref3[0],
	          maybeNextCallback = _ref3[1];

	      this.props.addEndListener(maybeNode, maybeNextCallback);
	    }

	    if (timeout != null) {
	      setTimeout(this.nextCallback, timeout);
	    }
	  };

	  _proto.render = function render() {
	    var status = this.state.status;

	    if (status === UNMOUNTED) {
	      return null;
	    }

	    var _this$props = this.props,
	        children = _this$props.children;
	        _this$props.in;
	        _this$props.mountOnEnter;
	        _this$props.unmountOnExit;
	        _this$props.appear;
	        _this$props.enter;
	        _this$props.exit;
	        _this$props.timeout;
	        _this$props.addEndListener;
	        _this$props.onEnter;
	        _this$props.onEntering;
	        _this$props.onEntered;
	        _this$props.onExit;
	        _this$props.onExiting;
	        _this$props.onExited;
	        _this$props.nodeRef;
	        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

	    return (
	      /*#__PURE__*/
	      // allows for nested Transitions
	      React.createElement(TransitionGroupContext.Provider, {
	        value: null
	      }, typeof children === 'function' ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
	    );
	  };

	  return Transition;
	}(React.Component);

	Transition.contextType = TransitionGroupContext;
	Transition.propTypes = {}; // Name the function so it is clearer in the documentation

	function noop$3() {}

	Transition.defaultProps = {
	  in: false,
	  mountOnEnter: false,
	  unmountOnExit: false,
	  appear: false,
	  enter: true,
	  exit: true,
	  onEnter: noop$3,
	  onEntering: noop$3,
	  onEntered: noop$3,
	  onExit: noop$3,
	  onExiting: noop$3,
	  onExited: noop$3
	};
	Transition.UNMOUNTED = UNMOUNTED;
	Transition.EXITED = EXITED;
	Transition.ENTERING = ENTERING;
	Transition.ENTERED = ENTERED;
	Transition.EXITING = EXITING;

	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}

	/**
	 * Given `this.props.children`, return an object mapping key to child.
	 *
	 * @param {*} children `this.props.children`
	 * @return {object} Mapping of key to child
	 */

	function getChildMapping(children, mapFn) {
	  var mapper = function mapper(child) {
	    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
	  };

	  var result = Object.create(null);
	  if (children) reactExports.Children.map(children, function (c) {
	    return c;
	  }).forEach(function (child) {
	    // run the map function here instead so that the key is the computed one
	    result[child.key] = mapper(child);
	  });
	  return result;
	}
	/**
	 * When you're adding or removing children some may be added or removed in the
	 * same render pass. We want to show *both* since we want to simultaneously
	 * animate elements in and out. This function takes a previous set of keys
	 * and a new set of keys and merges them with its best guess of the correct
	 * ordering. In the future we may expose some of the utilities in
	 * ReactMultiChild to make this easy, but for now React itself does not
	 * directly have this concept of the union of prevChildren and nextChildren
	 * so we implement it here.
	 *
	 * @param {object} prev prev children as returned from
	 * `ReactTransitionChildMapping.getChildMapping()`.
	 * @param {object} next next children as returned from
	 * `ReactTransitionChildMapping.getChildMapping()`.
	 * @return {object} a key set that contains all keys in `prev` and all keys
	 * in `next` in a reasonable order.
	 */

	function mergeChildMappings(prev, next) {
	  prev = prev || {};
	  next = next || {};

	  function getValueForKey(key) {
	    return key in next ? next[key] : prev[key];
	  } // For each key of `next`, the list of keys to insert before that key in
	  // the combined list


	  var nextKeysPending = Object.create(null);
	  var pendingKeys = [];

	  for (var prevKey in prev) {
	    if (prevKey in next) {
	      if (pendingKeys.length) {
	        nextKeysPending[prevKey] = pendingKeys;
	        pendingKeys = [];
	      }
	    } else {
	      pendingKeys.push(prevKey);
	    }
	  }

	  var i;
	  var childMapping = {};

	  for (var nextKey in next) {
	    if (nextKeysPending[nextKey]) {
	      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
	        var pendingNextKey = nextKeysPending[nextKey][i];
	        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
	      }
	    }

	    childMapping[nextKey] = getValueForKey(nextKey);
	  } // Finally, add the keys which didn't appear before any key in `next`


	  for (i = 0; i < pendingKeys.length; i++) {
	    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
	  }

	  return childMapping;
	}

	function getProp(child, prop, props) {
	  return props[prop] != null ? props[prop] : child.props[prop];
	}

	function getInitialChildMapping(props, onExited) {
	  return getChildMapping(props.children, function (child) {
	    return reactExports.cloneElement(child, {
	      onExited: onExited.bind(null, child),
	      in: true,
	      appear: getProp(child, 'appear', props),
	      enter: getProp(child, 'enter', props),
	      exit: getProp(child, 'exit', props)
	    });
	  });
	}
	function getNextChildMapping(nextProps, prevChildMapping, onExited) {
	  var nextChildMapping = getChildMapping(nextProps.children);
	  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
	  Object.keys(children).forEach(function (key) {
	    var child = children[key];
	    if (!reactExports.isValidElement(child)) return;
	    var hasPrev = (key in prevChildMapping);
	    var hasNext = (key in nextChildMapping);
	    var prevChild = prevChildMapping[key];
	    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

	    if (hasNext && (!hasPrev || isLeaving)) {
	      // console.log('entering', key)
	      children[key] = reactExports.cloneElement(child, {
	        onExited: onExited.bind(null, child),
	        in: true,
	        exit: getProp(child, 'exit', nextProps),
	        enter: getProp(child, 'enter', nextProps)
	      });
	    } else if (!hasNext && hasPrev && !isLeaving) {
	      // item is old (exiting)
	      // console.log('leaving', key)
	      children[key] = reactExports.cloneElement(child, {
	        in: false
	      });
	    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
	      // item hasn't changed transition states
	      // copy over the last transition props;
	      // console.log('unchanged', key)
	      children[key] = reactExports.cloneElement(child, {
	        onExited: onExited.bind(null, child),
	        in: prevChild.props.in,
	        exit: getProp(child, 'exit', nextProps),
	        enter: getProp(child, 'enter', nextProps)
	      });
	    }
	  });
	  return children;
	}

	var values = Object.values || function (obj) {
	  return Object.keys(obj).map(function (k) {
	    return obj[k];
	  });
	};

	var defaultProps$1 = {
	  component: 'div',
	  childFactory: function childFactory(child) {
	    return child;
	  }
	};
	/**
	 * The `<TransitionGroup>` component manages a set of transition components
	 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
	 * components, `<TransitionGroup>` is a state machine for managing the mounting
	 * and unmounting of components over time.
	 *
	 * Consider the example below. As items are removed or added to the TodoList the
	 * `in` prop is toggled automatically by the `<TransitionGroup>`.
	 *
	 * Note that `<TransitionGroup>`  does not define any animation behavior!
	 * Exactly _how_ a list item animates is up to the individual transition
	 * component. This means you can mix and match animations across different list
	 * items.
	 */

	var TransitionGroup = /*#__PURE__*/function (_React$Component) {
	  _inheritsLoose(TransitionGroup, _React$Component);

	  function TransitionGroup(props, context) {
	    var _this;

	    _this = _React$Component.call(this, props, context) || this;

	    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


	    _this.state = {
	      contextValue: {
	        isMounting: true
	      },
	      handleExited: handleExited,
	      firstRender: true
	    };
	    return _this;
	  }

	  var _proto = TransitionGroup.prototype;

	  _proto.componentDidMount = function componentDidMount() {
	    this.mounted = true;
	    this.setState({
	      contextValue: {
	        isMounting: false
	      }
	    });
	  };

	  _proto.componentWillUnmount = function componentWillUnmount() {
	    this.mounted = false;
	  };

	  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
	    var prevChildMapping = _ref.children,
	        handleExited = _ref.handleExited,
	        firstRender = _ref.firstRender;
	    return {
	      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
	      firstRender: false
	    };
	  } // node is `undefined` when user provided `nodeRef` prop
	  ;

	  _proto.handleExited = function handleExited(child, node) {
	    var currentChildMapping = getChildMapping(this.props.children);
	    if (child.key in currentChildMapping) return;

	    if (child.props.onExited) {
	      child.props.onExited(node);
	    }

	    if (this.mounted) {
	      this.setState(function (state) {
	        var children = _extends({}, state.children);

	        delete children[child.key];
	        return {
	          children: children
	        };
	      });
	    }
	  };

	  _proto.render = function render() {
	    var _this$props = this.props,
	        Component = _this$props.component,
	        childFactory = _this$props.childFactory,
	        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

	    var contextValue = this.state.contextValue;
	    var children = values(this.state.children).map(childFactory);
	    delete props.appear;
	    delete props.enter;
	    delete props.exit;

	    if (Component === null) {
	      return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
	        value: contextValue
	      }, children);
	    }

	    return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
	      value: contextValue
	    }, /*#__PURE__*/React.createElement(Component, props, children));
	  };

	  return TransitionGroup;
	}(React.Component);

	TransitionGroup.propTypes = {};
	TransitionGroup.defaultProps = defaultProps$1;

	const UNINITIALIZED = {};

	/**
	 * A React.useRef() that is initialized lazily with a function. Note that it accepts an optional
	 * initialization argument, so the initialization function doesn't need to be an inline closure.
	 *
	 * @usage
	 *   const ref = useLazyRef(sortColumns, columns)
	 */
	function useLazyRef(init, initArg) {
	  const ref = reactExports.useRef(UNINITIALIZED);
	  if (ref.current === UNINITIALIZED) {
	    ref.current = init(initArg);
	  }
	  return ref;
	}

	const EMPTY = [];

	/**
	 * A React.useEffect equivalent that runs once, when the component is mounted.
	 */
	function useOnMount(fn) {
	  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- no need to put `fn` in the dependency array
	  /* eslint-disable react-hooks/exhaustive-deps */
	  reactExports.useEffect(fn, EMPTY);
	  /* eslint-enable react-hooks/exhaustive-deps */
	}

	class Timeout {
	  static create() {
	    return new Timeout();
	  }
	  currentId = null;

	  /**
	   * Executes `fn` after `delay`, clearing any previously scheduled call.
	   */
	  start(delay, fn) {
	    this.clear();
	    this.currentId = setTimeout(() => {
	      this.currentId = null;
	      fn();
	    }, delay);
	  }
	  clear = () => {
	    if (this.currentId !== null) {
	      clearTimeout(this.currentId);
	      this.currentId = null;
	    }
	  };
	  disposeEffect = () => {
	    return this.clear;
	  };
	}
	function useTimeout() {
	  const timeout = useLazyRef(Timeout.create).current;
	  useOnMount(timeout.disposeEffect);
	  return timeout;
	}

	const reflow = node => node.scrollTop;
	function getTransitionProps(props, options) {
	  const {
	    timeout,
	    easing,
	    style = {}
	  } = props;
	  return {
	    duration: style.transitionDuration ?? (typeof timeout === 'number' ? timeout : timeout[options.mode] || 0),
	    easing: style.transitionTimingFunction ?? (typeof easing === 'object' ? easing[options.mode] : easing),
	    delay: style.transitionDelay
	  };
	}

	function getPaperUtilityClass(slot) {
	  return generateUtilityClass('MuiPaper', slot);
	}
	generateUtilityClasses('MuiPaper', ['root', 'rounded', 'outlined', 'elevation', 'elevation0', 'elevation1', 'elevation2', 'elevation3', 'elevation4', 'elevation5', 'elevation6', 'elevation7', 'elevation8', 'elevation9', 'elevation10', 'elevation11', 'elevation12', 'elevation13', 'elevation14', 'elevation15', 'elevation16', 'elevation17', 'elevation18', 'elevation19', 'elevation20', 'elevation21', 'elevation22', 'elevation23', 'elevation24']);

	const useUtilityClasses$b = ownerState => {
	  const {
	    square,
	    elevation,
	    variant,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', variant, !square && 'rounded', variant === 'elevation' && `elevation${elevation}`]
	  };
	  return composeClasses(slots, getPaperUtilityClass, classes);
	};
	const PaperRoot = styled('div', {
	  name: 'MuiPaper',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, styles[ownerState.variant], !ownerState.square && styles.rounded, ownerState.variant === 'elevation' && styles[`elevation${ownerState.elevation}`]];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  backgroundColor: (theme.vars || theme).palette.background.paper,
	  color: (theme.vars || theme).palette.text.primary,
	  transition: theme.transitions.create('box-shadow'),
	  variants: [{
	    props: ({
	      ownerState
	    }) => !ownerState.square,
	    style: {
	      borderRadius: theme.shape.borderRadius
	    }
	  }, {
	    props: {
	      variant: 'outlined'
	    },
	    style: {
	      border: `1px solid ${(theme.vars || theme).palette.divider}`
	    }
	  }, {
	    props: {
	      variant: 'elevation'
	    },
	    style: {
	      boxShadow: 'var(--Paper-shadow)',
	      backgroundImage: 'var(--Paper-overlay)'
	    }
	  }]
	})));
	const Paper = /*#__PURE__*/reactExports.forwardRef(function Paper(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiPaper'
	  });
	  const theme = useTheme();
	  const {
	    className,
	    component = 'div',
	    elevation = 1,
	    square = false,
	    variant = 'elevation',
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    component,
	    elevation,
	    square,
	    variant
	  };
	  const classes = useUtilityClasses$b(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(PaperRoot, {
	    as: component,
	    ownerState: ownerState,
	    className: clsx(classes.root, className),
	    ref: ref,
	    ...other,
	    style: {
	      ...(variant === 'elevation' && {
	        '--Paper-shadow': (theme.vars || theme).shadows[elevation],
	        ...(theme.vars && {
	          '--Paper-overlay': theme.vars.overlays?.[elevation]
	        }),
	        ...(!theme.vars && theme.palette.mode === 'dark' && {
	          '--Paper-overlay': `linear-gradient(${alpha('#fff', getOverlayAlpha(elevation))}, ${alpha('#fff', getOverlayAlpha(elevation))})`
	        })
	      }),
	      ...other.style
	    }
	  });
	});

	/**
	 * Determines if a given element is a DOM element name (i.e. not a React component).
	 */
	function isHostComponent$1(element) {
	  return typeof element === 'string';
	}

	/**
	 * Type of the ownerState based on the type of an element it applies to.
	 * This resolves to the provided OwnerState for React components and `undefined` for host components.
	 * Falls back to `OwnerState | undefined` when the exact type can't be determined in development time.
	 */

	/**
	 * Appends the ownerState object to the props, merging with the existing one if necessary.
	 *
	 * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node or undefined, `ownerState` is not applied.
	 * @param otherProps Props of the element.
	 * @param ownerState
	 */
	function appendOwnerState(elementType, otherProps, ownerState) {
	  if (elementType === undefined || isHostComponent$1(elementType)) {
	    return otherProps;
	  }
	  return {
	    ...otherProps,
	    ownerState: {
	      ...otherProps.ownerState,
	      ...ownerState
	    }
	  };
	}

	/**
	 * If `componentProps` is a function, calls it with the provided `ownerState`.
	 * Otherwise, just returns `componentProps`.
	 */
	function resolveComponentProps(componentProps, ownerState, slotState) {
	  if (typeof componentProps === 'function') {
	    return componentProps(ownerState, slotState);
	  }
	  return componentProps;
	}

	/**
	 * Extracts event handlers from a given object.
	 * A prop is considered an event handler if it is a function and its name starts with `on`.
	 *
	 * @param object An object to extract event handlers from.
	 * @param excludeKeys An array of keys to exclude from the returned object.
	 */
	function extractEventHandlers(object, excludeKeys = []) {
	  if (object === undefined) {
	    return {};
	  }
	  const result = {};
	  Object.keys(object).filter(prop => prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach(prop => {
	    result[prop] = object[prop];
	  });
	  return result;
	}

	/**
	 * Removes event handlers from the given object.
	 * A field is considered an event handler if it is a function with a name beginning with `on`.
	 *
	 * @param object Object to remove event handlers from.
	 * @returns Object with event handlers removed.
	 */
	function omitEventHandlers(object) {
	  if (object === undefined) {
	    return {};
	  }
	  const result = {};
	  Object.keys(object).filter(prop => !(prop.match(/^on[A-Z]/) && typeof object[prop] === 'function')).forEach(prop => {
	    result[prop] = object[prop];
	  });
	  return result;
	}

	/**
	 * Merges the slot component internal props (usually coming from a hook)
	 * with the externally provided ones.
	 *
	 * The merge order is (the latter overrides the former):
	 * 1. The internal props (specified as a getter function to work with get*Props hook result)
	 * 2. Additional props (specified internally on a Base UI component)
	 * 3. External props specified on the owner component. These should only be used on a root slot.
	 * 4. External props specified in the `slotProps.*` prop.
	 * 5. The `className` prop - combined from all the above.
	 * @param parameters
	 * @returns
	 */
	function mergeSlotProps(parameters) {
	  const {
	    getSlotProps,
	    additionalProps,
	    externalSlotProps,
	    externalForwardedProps,
	    className
	  } = parameters;
	  if (!getSlotProps) {
	    // The simpler case - getSlotProps is not defined, so no internal event handlers are defined,
	    // so we can simply merge all the props without having to worry about extracting event handlers.
	    const joinedClasses = clsx(additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
	    const mergedStyle = {
	      ...additionalProps?.style,
	      ...externalForwardedProps?.style,
	      ...externalSlotProps?.style
	    };
	    const props = {
	      ...additionalProps,
	      ...externalForwardedProps,
	      ...externalSlotProps
	    };
	    if (joinedClasses.length > 0) {
	      props.className = joinedClasses;
	    }
	    if (Object.keys(mergedStyle).length > 0) {
	      props.style = mergedStyle;
	    }
	    return {
	      props,
	      internalRef: undefined
	    };
	  }

	  // In this case, getSlotProps is responsible for calling the external event handlers.
	  // We don't need to include them in the merged props because of this.

	  const eventHandlers = extractEventHandlers({
	    ...externalForwardedProps,
	    ...externalSlotProps
	  });
	  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
	  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
	  const internalSlotProps = getSlotProps(eventHandlers);

	  // The order of classes is important here.
	  // Emotion (that we use in libraries consuming Base UI) depends on this order
	  // to properly override style. It requires the most important classes to be last
	  // (see https://github.com/mui/material-ui/pull/33205) for the related discussion.
	  const joinedClasses = clsx(internalSlotProps?.className, additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
	  const mergedStyle = {
	    ...internalSlotProps?.style,
	    ...additionalProps?.style,
	    ...externalForwardedProps?.style,
	    ...externalSlotProps?.style
	  };
	  const props = {
	    ...internalSlotProps,
	    ...additionalProps,
	    ...otherPropsWithoutEventHandlers,
	    ...componentsPropsWithoutEventHandlers
	  };
	  if (joinedClasses.length > 0) {
	    props.className = joinedClasses;
	  }
	  if (Object.keys(mergedStyle).length > 0) {
	    props.style = mergedStyle;
	  }
	  return {
	    props,
	    internalRef: internalSlotProps.ref
	  };
	}

	/**
	 * An internal function to create a Material UI slot.
	 *
	 * This is an advanced version of Base UI `useSlotProps` because Material UI allows leaf component to be customized via `component` prop
	 * while Base UI does not need to support leaf component customization.
	 *
	 * @param {string} name: name of the slot
	 * @param {object} parameters
	 * @returns {[Slot, slotProps]} The slot's React component and the slot's props
	 *
	 * Note: the returned slot's props
	 * - will never contain `component` prop.
	 * - might contain `as` prop.
	 */
	function useSlot(
	/**
	 * The slot's name. All Material UI components should have `root` slot.
	 *
	 * If the name is `root`, the logic behaves differently from other slots,
	 * e.g. the `externalForwardedProps` are spread to `root` slot but not other slots.
	 */
	name, parameters) {
	  const {
	    className,
	    elementType: initialElementType,
	    ownerState,
	    externalForwardedProps,
	    internalForwardedProps,
	    shouldForwardComponentProp = false,
	    ...useSlotPropsParams
	  } = parameters;
	  const {
	    component: rootComponent,
	    slots = {
	      [name]: undefined
	    },
	    slotProps = {
	      [name]: undefined
	    },
	    ...other
	  } = externalForwardedProps;
	  const elementType = slots[name] || initialElementType;

	  // `slotProps[name]` can be a callback that receives the component's ownerState.
	  // `resolvedComponentsProps` is always a plain object.
	  const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
	  const {
	    props: {
	      component: slotComponent,
	      ...mergedProps
	    },
	    internalRef
	  } = mergeSlotProps({
	    className,
	    ...useSlotPropsParams,
	    externalForwardedProps: name === 'root' ? other : undefined,
	    externalSlotProps: resolvedComponentsProps
	  });
	  const ref = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.ref);
	  const LeafComponent = name === 'root' ? slotComponent || rootComponent : slotComponent;
	  const props = appendOwnerState(elementType, {
	    ...(name === 'root' && !rootComponent && !slots[name] && internalForwardedProps),
	    ...(name !== 'root' && !slots[name] && internalForwardedProps),
	    ...mergedProps,
	    ...(LeafComponent && !shouldForwardComponentProp && {
	      as: LeafComponent
	    }),
	    ...(LeafComponent && shouldForwardComponentProp && {
	      component: LeafComponent
	    }),
	    ref
	  }, ownerState);
	  return [elementType, props];
	}

	/**
	 * Returns a boolean indicating if the event's target has :focus-visible
	 */
	function isFocusVisible(element) {
	  try {
	    return element.matches(':focus-visible');
	  } catch (error) {
	  }
	  return false;
	}

	/**
	 * Lazy initialization container for the Ripple instance. This improves
	 * performance by delaying mounting the ripple until it's needed.
	 */
	class LazyRipple {
	  /** React ref to the ripple instance */

	  /** If the ripple component should be mounted */

	  /** Promise that resolves when the ripple component is mounted */

	  /** If the ripple component has been mounted */

	  /** React state hook setter */

	  static create() {
	    return new LazyRipple();
	  }
	  static use() {
	    /* eslint-disable */
	    const ripple = useLazyRef(LazyRipple.create).current;
	    const [shouldMount, setShouldMount] = reactExports.useState(false);
	    ripple.shouldMount = shouldMount;
	    ripple.setShouldMount = setShouldMount;
	    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
	    /* eslint-enable */

	    return ripple;
	  }
	  constructor() {
	    this.ref = {
	      current: null
	    };
	    this.mounted = null;
	    this.didMount = false;
	    this.shouldMount = false;
	    this.setShouldMount = null;
	  }
	  mount() {
	    if (!this.mounted) {
	      this.mounted = createControlledPromise();
	      this.shouldMount = true;
	      this.setShouldMount(this.shouldMount);
	    }
	    return this.mounted;
	  }
	  mountEffect = () => {
	    if (this.shouldMount && !this.didMount) {
	      if (this.ref.current !== null) {
	        this.didMount = true;
	        this.mounted.resolve();
	      }
	    }
	  };

	  /* Ripple API */

	  start(...args) {
	    this.mount().then(() => this.ref.current?.start(...args));
	  }
	  stop(...args) {
	    this.mount().then(() => this.ref.current?.stop(...args));
	  }
	  pulsate(...args) {
	    this.mount().then(() => this.ref.current?.pulsate(...args));
	  }
	}
	function useLazyRipple() {
	  return LazyRipple.use();
	}
	function createControlledPromise() {
	  let resolve;
	  let reject;
	  const p = new Promise((resolveFn, rejectFn) => {
	    resolve = resolveFn;
	    reject = rejectFn;
	  });
	  p.resolve = resolve;
	  p.reject = reject;
	  return p;
	}

	function Ripple(props) {
	  const {
	    className,
	    classes,
	    pulsate = false,
	    rippleX,
	    rippleY,
	    rippleSize,
	    in: inProp,
	    onExited,
	    timeout
	  } = props;
	  const [leaving, setLeaving] = reactExports.useState(false);
	  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
	  const rippleStyles = {
	    width: rippleSize,
	    height: rippleSize,
	    top: -(rippleSize / 2) + rippleY,
	    left: -(rippleSize / 2) + rippleX
	  };
	  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
	  if (!inProp && !leaving) {
	    setLeaving(true);
	  }
	  reactExports.useEffect(() => {
	    if (!inProp && onExited != null) {
	      // react-transition-group#onExited
	      const timeoutId = setTimeout(onExited, timeout);
	      return () => {
	        clearTimeout(timeoutId);
	      };
	    }
	    return undefined;
	  }, [onExited, inProp, timeout]);
	  return /*#__PURE__*/jsxRuntimeExports.jsx("span", {
	    className: rippleClassName,
	    style: rippleStyles,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx("span", {
	      className: childClassName
	    })
	  });
	}

	const touchRippleClasses = generateUtilityClasses('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']);

	const DURATION = 550;
	const DELAY_RIPPLE = 80;
	const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
	const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
	const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
	const TouchRippleRoot = styled('span', {
	  name: 'MuiTouchRipple',
	  slot: 'Root'
	})({
	  overflow: 'hidden',
	  pointerEvents: 'none',
	  position: 'absolute',
	  zIndex: 0,
	  top: 0,
	  right: 0,
	  bottom: 0,
	  left: 0,
	  borderRadius: 'inherit'
	});

	// This `styled()` function invokes keyframes. `styled-components` only supports keyframes
	// in string templates. Do not convert these styles in JS object as it will break.
	const TouchRippleRipple = styled(Ripple, {
	  name: 'MuiTouchRipple',
	  slot: 'Ripple'
	})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;

	/**
	 * @ignore - internal component.
	 *
	 * TODO v5: Make private
	 */
	const TouchRipple = /*#__PURE__*/reactExports.forwardRef(function TouchRipple(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiTouchRipple'
	  });
	  const {
	    center: centerProp = false,
	    classes = {},
	    className,
	    ...other
	  } = props;
	  const [ripples, setRipples] = reactExports.useState([]);
	  const nextKey = reactExports.useRef(0);
	  const rippleCallback = reactExports.useRef(null);
	  reactExports.useEffect(() => {
	    if (rippleCallback.current) {
	      rippleCallback.current();
	      rippleCallback.current = null;
	    }
	  }, [ripples]);

	  // Used to filter out mouse emulated events on mobile.
	  const ignoringMouseDown = reactExports.useRef(false);
	  // We use a timer in order to only show the ripples for touch "click" like events.
	  // We don't want to display the ripple for touch scroll events.
	  const startTimer = useTimeout();

	  // This is the hook called once the previous timeout is ready.
	  const startTimerCommit = reactExports.useRef(null);
	  const container = reactExports.useRef(null);
	  const startCommit = reactExports.useCallback(params => {
	    const {
	      pulsate,
	      rippleX,
	      rippleY,
	      rippleSize,
	      cb
	    } = params;
	    setRipples(oldRipples => [...oldRipples, /*#__PURE__*/jsxRuntimeExports.jsx(TouchRippleRipple, {
	      classes: {
	        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
	        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
	        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
	        child: clsx(classes.child, touchRippleClasses.child),
	        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
	        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
	      },
	      timeout: DURATION,
	      pulsate: pulsate,
	      rippleX: rippleX,
	      rippleY: rippleY,
	      rippleSize: rippleSize
	    }, nextKey.current)]);
	    nextKey.current += 1;
	    rippleCallback.current = cb;
	  }, [classes]);
	  const start = reactExports.useCallback((event = {}, options = {}, cb = () => {}) => {
	    const {
	      pulsate = false,
	      center = centerProp || options.pulsate,
	      fakeElement = false // For test purposes
	    } = options;
	    if (event?.type === 'mousedown' && ignoringMouseDown.current) {
	      ignoringMouseDown.current = false;
	      return;
	    }
	    if (event?.type === 'touchstart') {
	      ignoringMouseDown.current = true;
	    }
	    const element = fakeElement ? null : container.current;
	    const rect = element ? element.getBoundingClientRect() : {
	      width: 0,
	      height: 0,
	      left: 0,
	      top: 0
	    };

	    // Get the size of the ripple
	    let rippleX;
	    let rippleY;
	    let rippleSize;
	    if (center || event === undefined || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
	      rippleX = Math.round(rect.width / 2);
	      rippleY = Math.round(rect.height / 2);
	    } else {
	      const {
	        clientX,
	        clientY
	      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
	      rippleX = Math.round(clientX - rect.left);
	      rippleY = Math.round(clientY - rect.top);
	    }
	    if (center) {
	      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);

	      // For some reason the animation is broken on Mobile Chrome if the size is even.
	      if (rippleSize % 2 === 0) {
	        rippleSize += 1;
	      }
	    } else {
	      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
	      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
	      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
	    }

	    // Touche devices
	    if (event?.touches) {
	      // check that this isn't another touchstart due to multitouch
	      // otherwise we will only clear a single timer when unmounting while two
	      // are running
	      if (startTimerCommit.current === null) {
	        // Prepare the ripple effect.
	        startTimerCommit.current = () => {
	          startCommit({
	            pulsate,
	            rippleX,
	            rippleY,
	            rippleSize,
	            cb
	          });
	        };
	        // Delay the execution of the ripple effect.
	        // We have to make a tradeoff with this delay value.
	        startTimer.start(DELAY_RIPPLE, () => {
	          if (startTimerCommit.current) {
	            startTimerCommit.current();
	            startTimerCommit.current = null;
	          }
	        });
	      }
	    } else {
	      startCommit({
	        pulsate,
	        rippleX,
	        rippleY,
	        rippleSize,
	        cb
	      });
	    }
	  }, [centerProp, startCommit, startTimer]);
	  const pulsate = reactExports.useCallback(() => {
	    start({}, {
	      pulsate: true
	    });
	  }, [start]);
	  const stop = reactExports.useCallback((event, cb) => {
	    startTimer.clear();

	    // The touch interaction occurs too quickly.
	    // We still want to show ripple effect.
	    if (event?.type === 'touchend' && startTimerCommit.current) {
	      startTimerCommit.current();
	      startTimerCommit.current = null;
	      startTimer.start(0, () => {
	        stop(event, cb);
	      });
	      return;
	    }
	    startTimerCommit.current = null;
	    setRipples(oldRipples => {
	      if (oldRipples.length > 0) {
	        return oldRipples.slice(1);
	      }
	      return oldRipples;
	    });
	    rippleCallback.current = cb;
	  }, [startTimer]);
	  reactExports.useImperativeHandle(ref, () => ({
	    pulsate,
	    start,
	    stop
	  }), [pulsate, start, stop]);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(TouchRippleRoot, {
	    className: clsx(touchRippleClasses.root, classes.root, className),
	    ref: container,
	    ...other,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx(TransitionGroup, {
	      component: null,
	      exit: true,
	      children: ripples
	    })
	  });
	});

	function getButtonBaseUtilityClass(slot) {
	  return generateUtilityClass('MuiButtonBase', slot);
	}
	const buttonBaseClasses = generateUtilityClasses('MuiButtonBase', ['root', 'disabled', 'focusVisible']);

	const useUtilityClasses$a = ownerState => {
	  const {
	    disabled,
	    focusVisible,
	    focusVisibleClassName,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible']
	  };
	  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
	  if (focusVisible && focusVisibleClassName) {
	    composedClasses.root += ` ${focusVisibleClassName}`;
	  }
	  return composedClasses;
	};
	const ButtonBaseRoot = styled('button', {
	  name: 'MuiButtonBase',
	  slot: 'Root'
	})({
	  display: 'inline-flex',
	  alignItems: 'center',
	  justifyContent: 'center',
	  position: 'relative',
	  boxSizing: 'border-box',
	  WebkitTapHighlightColor: 'transparent',
	  backgroundColor: 'transparent',
	  // Reset default value
	  // We disable the focus ring for mouse, touch and keyboard users.
	  outline: 0,
	  border: 0,
	  margin: 0,
	  // Remove the margin in Safari
	  borderRadius: 0,
	  padding: 0,
	  // Remove the padding in Firefox
	  cursor: 'pointer',
	  userSelect: 'none',
	  verticalAlign: 'middle',
	  MozAppearance: 'none',
	  // Reset
	  WebkitAppearance: 'none',
	  // Reset
	  textDecoration: 'none',
	  // So we take precedent over the style of a native <a /> element.
	  color: 'inherit',
	  '&::-moz-focus-inner': {
	    borderStyle: 'none' // Remove Firefox dotted outline.
	  },
	  [`&.${buttonBaseClasses.disabled}`]: {
	    pointerEvents: 'none',
	    // Disable link interactions
	    cursor: 'default'
	  },
	  '@media print': {
	    colorAdjust: 'exact'
	  }
	});

	/**
	 * `ButtonBase` contains as few styles as possible.
	 * It aims to be a simple building block for creating a button.
	 * It contains a load of style reset and some focus/ripple logic.
	 */
	const ButtonBase = /*#__PURE__*/reactExports.forwardRef(function ButtonBase(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiButtonBase'
	  });
	  const {
	    action,
	    centerRipple = false,
	    children,
	    className,
	    component = 'button',
	    disabled = false,
	    disableRipple = false,
	    disableTouchRipple = false,
	    focusRipple = false,
	    focusVisibleClassName,
	    LinkComponent = 'a',
	    onBlur,
	    onClick,
	    onContextMenu,
	    onDragLeave,
	    onFocus,
	    onFocusVisible,
	    onKeyDown,
	    onKeyUp,
	    onMouseDown,
	    onMouseLeave,
	    onMouseUp,
	    onTouchEnd,
	    onTouchMove,
	    onTouchStart,
	    tabIndex = 0,
	    TouchRippleProps,
	    touchRippleRef,
	    type,
	    ...other
	  } = props;
	  const buttonRef = reactExports.useRef(null);
	  const ripple = useLazyRipple();
	  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
	  const [focusVisible, setFocusVisible] = reactExports.useState(false);
	  if (disabled && focusVisible) {
	    setFocusVisible(false);
	  }
	  reactExports.useImperativeHandle(action, () => ({
	    focusVisible: () => {
	      setFocusVisible(true);
	      buttonRef.current.focus();
	    }
	  }), []);
	  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
	  reactExports.useEffect(() => {
	    if (focusVisible && focusRipple && !disableRipple) {
	      ripple.pulsate();
	    }
	  }, [disableRipple, focusRipple, focusVisible, ripple]);
	  const handleMouseDown = useRippleHandler(ripple, 'start', onMouseDown, disableTouchRipple);
	  const handleContextMenu = useRippleHandler(ripple, 'stop', onContextMenu, disableTouchRipple);
	  const handleDragLeave = useRippleHandler(ripple, 'stop', onDragLeave, disableTouchRipple);
	  const handleMouseUp = useRippleHandler(ripple, 'stop', onMouseUp, disableTouchRipple);
	  const handleMouseLeave = useRippleHandler(ripple, 'stop', event => {
	    if (focusVisible) {
	      event.preventDefault();
	    }
	    if (onMouseLeave) {
	      onMouseLeave(event);
	    }
	  }, disableTouchRipple);
	  const handleTouchStart = useRippleHandler(ripple, 'start', onTouchStart, disableTouchRipple);
	  const handleTouchEnd = useRippleHandler(ripple, 'stop', onTouchEnd, disableTouchRipple);
	  const handleTouchMove = useRippleHandler(ripple, 'stop', onTouchMove, disableTouchRipple);
	  const handleBlur = useRippleHandler(ripple, 'stop', event => {
	    if (!isFocusVisible(event.target)) {
	      setFocusVisible(false);
	    }
	    if (onBlur) {
	      onBlur(event);
	    }
	  }, false);
	  const handleFocus = useEventCallback(event => {
	    // Fix for https://github.com/facebook/react/issues/7769
	    if (!buttonRef.current) {
	      buttonRef.current = event.currentTarget;
	    }
	    if (isFocusVisible(event.target)) {
	      setFocusVisible(true);
	      if (onFocusVisible) {
	        onFocusVisible(event);
	      }
	    }
	    if (onFocus) {
	      onFocus(event);
	    }
	  });
	  const isNonNativeButton = () => {
	    const button = buttonRef.current;
	    return component && component !== 'button' && !(button.tagName === 'A' && button.href);
	  };
	  const handleKeyDown = useEventCallback(event => {
	    // Check if key is already down to avoid repeats being counted as multiple activations
	    if (focusRipple && !event.repeat && focusVisible && event.key === ' ') {
	      ripple.stop(event, () => {
	        ripple.start(event);
	      });
	    }
	    if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
	      event.preventDefault();
	    }
	    if (onKeyDown) {
	      onKeyDown(event);
	    }

	    // Keyboard accessibility for non interactive elements
	    if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
	      event.preventDefault();
	      if (onClick) {
	        onClick(event);
	      }
	    }
	  });
	  const handleKeyUp = useEventCallback(event => {
	    // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
	    // https://codesandbox.io/p/sandbox/button-keyup-preventdefault-dn7f0
	    if (focusRipple && event.key === ' ' && focusVisible && !event.defaultPrevented) {
	      ripple.stop(event, () => {
	        ripple.pulsate(event);
	      });
	    }
	    if (onKeyUp) {
	      onKeyUp(event);
	    }

	    // Keyboard accessibility for non interactive elements
	    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
	      onClick(event);
	    }
	  });
	  let ComponentProp = component;
	  if (ComponentProp === 'button' && (other.href || other.to)) {
	    ComponentProp = LinkComponent;
	  }
	  const buttonProps = {};
	  if (ComponentProp === 'button') {
	    buttonProps.type = type === undefined ? 'button' : type;
	    buttonProps.disabled = disabled;
	  } else {
	    if (!other.href && !other.to) {
	      buttonProps.role = 'button';
	    }
	    if (disabled) {
	      buttonProps['aria-disabled'] = disabled;
	    }
	  }
	  const handleRef = useForkRef(ref, buttonRef);
	  const ownerState = {
	    ...props,
	    centerRipple,
	    component,
	    disabled,
	    disableRipple,
	    disableTouchRipple,
	    focusRipple,
	    tabIndex,
	    focusVisible
	  };
	  const classes = useUtilityClasses$a(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(ButtonBaseRoot, {
	    as: ComponentProp,
	    className: clsx(classes.root, className),
	    ownerState: ownerState,
	    onBlur: handleBlur,
	    onClick: onClick,
	    onContextMenu: handleContextMenu,
	    onFocus: handleFocus,
	    onKeyDown: handleKeyDown,
	    onKeyUp: handleKeyUp,
	    onMouseDown: handleMouseDown,
	    onMouseLeave: handleMouseLeave,
	    onMouseUp: handleMouseUp,
	    onDragLeave: handleDragLeave,
	    onTouchEnd: handleTouchEnd,
	    onTouchMove: handleTouchMove,
	    onTouchStart: handleTouchStart,
	    ref: handleRef,
	    tabIndex: disabled ? -1 : tabIndex,
	    type: type,
	    ...buttonProps,
	    ...other,
	    children: [children, enableTouchRipple ? /*#__PURE__*/jsxRuntimeExports.jsx(TouchRipple, {
	      ref: handleRippleRef,
	      center: centerRipple,
	      ...TouchRippleProps
	    }) : null]
	  });
	});
	function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
	  return useEventCallback(event => {
	    if (eventCallback) {
	      eventCallback(event);
	    }
	    if (!skipRippleAction) {
	      ripple[rippleAction](event);
	    }
	    return true;
	  });
	}

	/**
	 * Type guard to check if the object has a "main" property of type string.
	 *
	 * @param obj - the object to check
	 * @returns boolean
	 */
	function hasCorrectMainProperty(obj) {
	  return typeof obj.main === 'string';
	}
	/**
	 * Checks if the object conforms to the SimplePaletteColorOptions type.
	 * The minimum requirement is that the object has a "main" property of type string, this is always checked.
	 * Optionally, you can pass additional properties to check.
	 *
	 * @param obj - The object to check
	 * @param additionalPropertiesToCheck - Array containing "light", "dark", and/or "contrastText"
	 * @returns boolean
	 */
	function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
	  if (!hasCorrectMainProperty(obj)) {
	    return false;
	  }
	  for (const value of additionalPropertiesToCheck) {
	    if (!obj.hasOwnProperty(value) || typeof obj[value] !== 'string') {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * Creates a filter function used to filter simple palette color options.
	 * The minimum requirement is that the object has a "main" property of type string, this is always checked.
	 * Optionally, you can pass additional properties to check.
	 *
	 * @param additionalPropertiesToCheck - Array containing "light", "dark", and/or "contrastText"
	 * @returns ([, value]: [any, PaletteColorOptions]) => boolean
	 */
	function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
	  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
	}

	function getCircularProgressUtilityClass(slot) {
	  return generateUtilityClass('MuiCircularProgress', slot);
	}
	generateUtilityClasses('MuiCircularProgress', ['root', 'determinate', 'indeterminate', 'colorPrimary', 'colorSecondary', 'svg', 'circle', 'circleDeterminate', 'circleIndeterminate', 'circleDisableShrink']);

	const SIZE = 44;
	const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
	const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;

	// This implementation is for supporting both Styled-components v4+ and Pigment CSS.
	// A global animation has to be created here for Styled-components v4+ (https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#12).
	// which can be done by checking typeof indeterminate1Keyframe !== 'string' (at runtime, Pigment CSS transform keyframes`` to a string).
	const rotateAnimation = typeof circularRotateKeyframe !== 'string' ? css$2`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
	const dashAnimation = typeof circularDashKeyframe !== 'string' ? css$2`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
	const useUtilityClasses$9 = ownerState => {
	  const {
	    classes,
	    variant,
	    color,
	    disableShrink
	  } = ownerState;
	  const slots = {
	    root: ['root', variant, `color${capitalize(color)}`],
	    svg: ['svg'],
	    circle: ['circle', `circle${capitalize(variant)}`, disableShrink && 'circleDisableShrink']
	  };
	  return composeClasses(slots, getCircularProgressUtilityClass, classes);
	};
	const CircularProgressRoot = styled('span', {
	  name: 'MuiCircularProgress',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, styles[ownerState.variant], styles[`color${capitalize(ownerState.color)}`]];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  display: 'inline-block',
	  variants: [{
	    props: {
	      variant: 'determinate'
	    },
	    style: {
	      transition: theme.transitions.create('transform')
	    }
	  }, {
	    props: {
	      variant: 'indeterminate'
	    },
	    style: rotateAnimation || {
	      animation: `${circularRotateKeyframe} 1.4s linear infinite`
	    }
	  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({
	    props: {
	      color
	    },
	    style: {
	      color: (theme.vars || theme).palette[color].main
	    }
	  }))]
	})));
	const CircularProgressSVG = styled('svg', {
	  name: 'MuiCircularProgress',
	  slot: 'Svg'
	})({
	  display: 'block' // Keeps the progress centered
	});
	const CircularProgressCircle = styled('circle', {
	  name: 'MuiCircularProgress',
	  slot: 'Circle',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.circle, styles[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles.circleDisableShrink];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  stroke: 'currentColor',
	  variants: [{
	    props: {
	      variant: 'determinate'
	    },
	    style: {
	      transition: theme.transitions.create('stroke-dashoffset')
	    }
	  }, {
	    props: {
	      variant: 'indeterminate'
	    },
	    style: {
	      // Some default value that looks fine waiting for the animation to kicks in.
	      strokeDasharray: '80px, 200px',
	      strokeDashoffset: 0 // Add the unit to fix a Edge 16 and below bug.
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.variant === 'indeterminate' && !ownerState.disableShrink,
	    style: dashAnimation || {
	      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
	      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
	    }
	  }]
	})));

	/**
	 * ## ARIA
	 *
	 * If the progress bar is describing the loading progress of a particular region of a page,
	 * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`
	 * attribute to `true` on that region until it has finished loading.
	 */
	const CircularProgress = /*#__PURE__*/reactExports.forwardRef(function CircularProgress(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiCircularProgress'
	  });
	  const {
	    className,
	    color = 'primary',
	    disableShrink = false,
	    size = 40,
	    style,
	    thickness = 3.6,
	    value = 0,
	    variant = 'indeterminate',
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    color,
	    disableShrink,
	    size,
	    thickness,
	    value,
	    variant
	  };
	  const classes = useUtilityClasses$9(ownerState);
	  const circleStyle = {};
	  const rootStyle = {};
	  const rootProps = {};
	  if (variant === 'determinate') {
	    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
	    circleStyle.strokeDasharray = circumference.toFixed(3);
	    rootProps['aria-valuenow'] = Math.round(value);
	    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
	    rootStyle.transform = 'rotate(-90deg)';
	  }
	  return /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressRoot, {
	    className: clsx(classes.root, className),
	    style: {
	      width: size,
	      height: size,
	      ...rootStyle,
	      ...style
	    },
	    ownerState: ownerState,
	    ref: ref,
	    role: "progressbar",
	    ...rootProps,
	    ...other,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressSVG, {
	      className: classes.svg,
	      ownerState: ownerState,
	      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
	      children: /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressCircle, {
	        className: classes.circle,
	        style: circleStyle,
	        ownerState: ownerState,
	        cx: SIZE,
	        cy: SIZE,
	        r: (SIZE - thickness) / 2,
	        fill: "none",
	        strokeWidth: thickness
	      })
	    })
	  });
	});

	function getTypographyUtilityClass(slot) {
	  return generateUtilityClass('MuiTypography', slot);
	}
	const typographyClasses = generateUtilityClasses('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph']);

	const v6Colors = {
	  primary: true,
	  secondary: true,
	  error: true,
	  info: true,
	  success: true,
	  warning: true,
	  textPrimary: true,
	  textSecondary: true,
	  textDisabled: true
	};
	const extendSxProp = internal_createExtendSxProp();
	const useUtilityClasses$8 = ownerState => {
	  const {
	    align,
	    gutterBottom,
	    noWrap,
	    paragraph,
	    variant,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', variant, ownerState.align !== 'inherit' && `align${capitalize(align)}`, gutterBottom && 'gutterBottom', noWrap && 'noWrap', paragraph && 'paragraph']
	  };
	  return composeClasses(slots, getTypographyUtilityClass, classes);
	};
	const TypographyRoot = styled('span', {
	  name: 'MuiTypography',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== 'inherit' && styles[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  margin: 0,
	  variants: [{
	    props: {
	      variant: 'inherit'
	    },
	    style: {
	      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
	      font: 'inherit',
	      lineHeight: 'inherit',
	      letterSpacing: 'inherit'
	    }
	  }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== 'inherit' && value && typeof value === 'object').map(([variant, value]) => ({
	    props: {
	      variant
	    },
	    style: value
	  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({
	    props: {
	      color
	    },
	    style: {
	      color: (theme.vars || theme).palette[color].main
	    }
	  })), ...Object.entries(theme.palette?.text || {}).filter(([, value]) => typeof value === 'string').map(([color]) => ({
	    props: {
	      color: `text${capitalize(color)}`
	    },
	    style: {
	      color: (theme.vars || theme).palette.text[color]
	    }
	  })), {
	    props: ({
	      ownerState
	    }) => ownerState.align !== 'inherit',
	    style: {
	      textAlign: 'var(--Typography-textAlign)'
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.noWrap,
	    style: {
	      overflow: 'hidden',
	      textOverflow: 'ellipsis',
	      whiteSpace: 'nowrap'
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.gutterBottom,
	    style: {
	      marginBottom: '0.35em'
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.paragraph,
	    style: {
	      marginBottom: 16
	    }
	  }]
	})));
	const defaultVariantMapping = {
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  subtitle1: 'h6',
	  subtitle2: 'h6',
	  body1: 'p',
	  body2: 'p',
	  inherit: 'p'
	};
	const Typography = /*#__PURE__*/reactExports.forwardRef(function Typography(inProps, ref) {
	  const {
	    color,
	    ...themeProps
	  } = useDefaultProps({
	    props: inProps,
	    name: 'MuiTypography'
	  });
	  const isSxColor = !v6Colors[color];
	  // TODO: Remove `extendSxProp` in v7
	  const props = extendSxProp({
	    ...themeProps,
	    ...(isSxColor && {
	      color
	    })
	  });
	  const {
	    align = 'inherit',
	    className,
	    component,
	    gutterBottom = false,
	    noWrap = false,
	    paragraph = false,
	    variant = 'body1',
	    variantMapping = defaultVariantMapping,
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    align,
	    color,
	    className,
	    component,
	    gutterBottom,
	    noWrap,
	    paragraph,
	    variant,
	    variantMapping
	  };
	  const Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
	  const classes = useUtilityClasses$8(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(TypographyRoot, {
	    as: Component,
	    ref: ref,
	    className: clsx(classes.root, className),
	    ...other,
	    ownerState: ownerState,
	    style: {
	      ...(align !== 'inherit' && {
	        '--Typography-textAlign': align
	      }),
	      ...other.style
	    }
	  });
	});

	/**
	 * Returns the ref of a React element handling differences between React 19 and older versions.
	 * It will throw runtime error if the element is not a valid React element.
	 *
	 * @param element React.ReactElement
	 * @returns React.Ref<any> | null
	 */
	function getReactElementRef(element) {
	  // 'ref' is passed as prop in React 19, whereas 'ref' is directly attached to children in older versions
	  if (parseInt(reactExports.version, 10) >= 19) {
	    return element?.props?.ref || null;
	  }
	  // @ts-expect-error element.ref is not included in the ReactElement type
	  // https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/70189
	  return element?.ref || null;
	}

	function getContainer$1(container) {
	  return typeof container === 'function' ? container() : container;
	}

	/**
	 * Portals provide a first-class way to render children into a DOM node
	 * that exists outside the DOM hierarchy of the parent component.
	 *
	 * Demos:
	 *
	 * - [Portal](https://mui.com/material-ui/react-portal/)
	 *
	 * API:
	 *
	 * - [Portal API](https://mui.com/material-ui/api/portal/)
	 */
	const Portal = /*#__PURE__*/reactExports.forwardRef(function Portal(props, forwardedRef) {
	  const {
	    children,
	    container,
	    disablePortal = false
	  } = props;
	  const [mountNode, setMountNode] = reactExports.useState(null);
	  const handleRef = useForkRef(/*#__PURE__*/reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
	  useEnhancedEffect(() => {
	    if (!disablePortal) {
	      setMountNode(getContainer$1(container) || document.body);
	    }
	  }, [container, disablePortal]);
	  useEnhancedEffect(() => {
	    if (mountNode && !disablePortal) {
	      setRef(forwardedRef, mountNode);
	      return () => {
	        setRef(forwardedRef, null);
	      };
	    }
	    return undefined;
	  }, [forwardedRef, mountNode, disablePortal]);
	  if (disablePortal) {
	    if (/*#__PURE__*/reactExports.isValidElement(children)) {
	      const newProps = {
	        ref: handleRef
	      };
	      return /*#__PURE__*/reactExports.cloneElement(children, newProps);
	    }
	    return children;
	  }
	  return mountNode ? /*#__PURE__*/reactDomExports.createPortal(children, mountNode) : mountNode;
	});

	function getStyleValue(value) {
	  return parseInt(value, 10) || 0;
	}
	const styles$1 = {
	  shadow: {
	    // Visibility needed to hide the extra text area on iPads
	    visibility: 'hidden',
	    // Remove from the content flow
	    position: 'absolute',
	    // Ignore the scrollbar width
	    overflow: 'hidden',
	    height: 0,
	    top: 0,
	    left: 0,
	    // Create a new layer, increase the isolation of the computed values
	    transform: 'translateZ(0)'
	  }
	};
	function isObjectEmpty(object) {
	  // eslint-disable-next-line
	  for (const _ in object) {
	    return false;
	  }
	  return true;
	}
	function isEmpty(obj) {
	  return isObjectEmpty(obj) || obj.outerHeightStyle === 0 && !obj.overflowing;
	}

	/**
	 *
	 * Demos:
	 *
	 * - [Textarea Autosize](https://mui.com/material-ui/react-textarea-autosize/)
	 *
	 * API:
	 *
	 * - [TextareaAutosize API](https://mui.com/material-ui/api/textarea-autosize/)
	 */
	const TextareaAutosize = /*#__PURE__*/reactExports.forwardRef(function TextareaAutosize(props, forwardedRef) {
	  const {
	    onChange,
	    maxRows,
	    minRows = 1,
	    style,
	    value,
	    ...other
	  } = props;
	  const {
	    current: isControlled
	  } = reactExports.useRef(value != null);
	  const textareaRef = reactExports.useRef(null);
	  const handleRef = useForkRef(forwardedRef, textareaRef);
	  const heightRef = reactExports.useRef(null);
	  const hiddenTextareaRef = reactExports.useRef(null);
	  const calculateTextareaStyles = reactExports.useCallback(() => {
	    const textarea = textareaRef.current;
	    const hiddenTextarea = hiddenTextareaRef.current;
	    if (!textarea || !hiddenTextarea) {
	      return undefined;
	    }
	    const containerWindow = ownerWindow(textarea);
	    const computedStyle = containerWindow.getComputedStyle(textarea);

	    // If input's width is shrunk and it's not visible, don't sync height.
	    if (computedStyle.width === '0px') {
	      return {
	        outerHeightStyle: 0,
	        overflowing: false
	      };
	    }
	    hiddenTextarea.style.width = computedStyle.width;
	    hiddenTextarea.value = textarea.value || props.placeholder || 'x';
	    if (hiddenTextarea.value.slice(-1) === '\n') {
	      // Certain fonts which overflow the line height will cause the textarea
	      // to report a different scrollHeight depending on whether the last line
	      // is empty. Make it non-empty to avoid this issue.
	      hiddenTextarea.value += ' ';
	    }
	    const boxSizing = computedStyle.boxSizing;
	    const padding = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
	    const border = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);

	    // The height of the inner content
	    const innerHeight = hiddenTextarea.scrollHeight;

	    // Measure height of a textarea with a single row
	    hiddenTextarea.value = 'x';
	    const singleRowHeight = hiddenTextarea.scrollHeight;

	    // The height of the outer content
	    let outerHeight = innerHeight;
	    if (minRows) {
	      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
	    }
	    if (maxRows) {
	      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
	    }
	    outerHeight = Math.max(outerHeight, singleRowHeight);

	    // Take the box sizing into account for applying this value as a style.
	    const outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
	    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
	    return {
	      outerHeightStyle,
	      overflowing
	    };
	  }, [maxRows, minRows, props.placeholder]);
	  const didHeightChange = useEventCallback(() => {
	    const textarea = textareaRef.current;
	    const textareaStyles = calculateTextareaStyles();
	    if (!textarea || !textareaStyles || isEmpty(textareaStyles)) {
	      return false;
	    }
	    const outerHeightStyle = textareaStyles.outerHeightStyle;
	    return heightRef.current != null && heightRef.current !== outerHeightStyle;
	  });
	  const syncHeight = reactExports.useCallback(() => {
	    const textarea = textareaRef.current;
	    const textareaStyles = calculateTextareaStyles();
	    if (!textarea || !textareaStyles || isEmpty(textareaStyles)) {
	      return;
	    }
	    const outerHeightStyle = textareaStyles.outerHeightStyle;
	    if (heightRef.current !== outerHeightStyle) {
	      heightRef.current = outerHeightStyle;
	      textarea.style.height = `${outerHeightStyle}px`;
	    }
	    textarea.style.overflow = textareaStyles.overflowing ? 'hidden' : '';
	  }, [calculateTextareaStyles]);
	  const frameRef = reactExports.useRef(-1);
	  useEnhancedEffect(() => {
	    const debouncedHandleResize = debounce(syncHeight);
	    const textarea = textareaRef?.current;
	    if (!textarea) {
	      return undefined;
	    }
	    const containerWindow = ownerWindow(textarea);
	    containerWindow.addEventListener('resize', debouncedHandleResize);
	    let resizeObserver;
	    if (typeof ResizeObserver !== 'undefined') {
	      resizeObserver = new ResizeObserver(() => {
	        if (didHeightChange()) {
	          // avoid "ResizeObserver loop completed with undelivered notifications" error
	          // by temporarily unobserving the textarea element while manipulating the height
	          // and reobserving one frame later
	          resizeObserver.unobserve(textarea);
	          cancelAnimationFrame(frameRef.current);
	          syncHeight();
	          frameRef.current = requestAnimationFrame(() => {
	            resizeObserver.observe(textarea);
	          });
	        }
	      });
	      resizeObserver.observe(textarea);
	    }
	    return () => {
	      debouncedHandleResize.clear();
	      cancelAnimationFrame(frameRef.current);
	      containerWindow.removeEventListener('resize', debouncedHandleResize);
	      if (resizeObserver) {
	        resizeObserver.disconnect();
	      }
	    };
	  }, [calculateTextareaStyles, syncHeight, didHeightChange]);
	  useEnhancedEffect(() => {
	    syncHeight();
	  });
	  const handleChange = event => {
	    if (!isControlled) {
	      syncHeight();
	    }
	    const textarea = event.target;
	    const countOfCharacters = textarea.value.length;
	    const isLastCharacterNewLine = textarea.value.endsWith('\n');
	    const isEndOfTheLine = textarea.selectionStart === countOfCharacters;

	    // Set the cursor position to the very end of the text.
	    if (isLastCharacterNewLine && isEndOfTheLine) {
	      textarea.setSelectionRange(countOfCharacters, countOfCharacters);
	    }
	    if (onChange) {
	      onChange(event);
	    }
	  };
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
	    children: [/*#__PURE__*/jsxRuntimeExports.jsx("textarea", {
	      value: value,
	      onChange: handleChange,
	      ref: handleRef
	      // Apply the rows prop to get a "correct" first SSR paint
	      ,
	      rows: minRows,
	      style: style,
	      ...other
	    }), /*#__PURE__*/jsxRuntimeExports.jsx("textarea", {
	      "aria-hidden": true,
	      className: props.className,
	      readOnly: true,
	      ref: hiddenTextareaRef,
	      tabIndex: -1,
	      style: {
	        ...styles$1.shadow,
	        ...style,
	        paddingTop: 0,
	        paddingBottom: 0
	      }
	    })]
	  });
	});

	/**
	 * Determines if a given element is a DOM element name (i.e. not a React component).
	 */
	function isHostComponent(element) {
	  return typeof element === 'string';
	}

	function formControlState({
	  props,
	  states,
	  muiFormControl
	}) {
	  return states.reduce((acc, state) => {
	    acc[state] = props[state];
	    if (muiFormControl) {
	      if (typeof props[state] === 'undefined') {
	        acc[state] = muiFormControl[state];
	      }
	    }
	    return acc;
	  }, {});
	}

	/**
	 * @ignore - internal component.
	 */
	const FormControlContext = /*#__PURE__*/reactExports.createContext(undefined);

	function useFormControl() {
	  return reactExports.useContext(FormControlContext);
	}

	// Supports determination of isControlled().
	// Controlled input accepts its current value as a prop.
	//
	// @see https://facebook.github.io/react/docs/forms.html#controlled-components
	// @param value
	// @returns {boolean} true if string (including '') or number (including zero)
	function hasValue(value) {
	  return value != null && !(Array.isArray(value) && value.length === 0);
	}

	// Determine if field is empty or filled.
	// Response determines if label is presented above field or as placeholder.
	//
	// @param obj
	// @param SSR
	// @returns {boolean} False when not present or empty string.
	//                    True when any number or string with length.
	function isFilled(obj, SSR = false) {
	  return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
	}

	function getInputBaseUtilityClass(slot) {
	  return generateUtilityClass('MuiInputBase', slot);
	}
	const inputBaseClasses = generateUtilityClasses('MuiInputBase', ['root', 'formControl', 'focused', 'disabled', 'adornedStart', 'adornedEnd', 'error', 'sizeSmall', 'multiline', 'colorSecondary', 'fullWidth', 'hiddenLabel', 'readOnly', 'input', 'inputSizeSmall', 'inputMultiline', 'inputTypeSearch', 'inputAdornedStart', 'inputAdornedEnd', 'inputHiddenLabel']);

	var _InputGlobalStyles;
	const rootOverridesResolver = (props, styles) => {
	  const {
	    ownerState
	  } = props;
	  return [styles.root, ownerState.formControl && styles.formControl, ownerState.startAdornment && styles.adornedStart, ownerState.endAdornment && styles.adornedEnd, ownerState.error && styles.error, ownerState.size === 'small' && styles.sizeSmall, ownerState.multiline && styles.multiline, ownerState.color && styles[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles.fullWidth, ownerState.hiddenLabel && styles.hiddenLabel];
	};
	const inputOverridesResolver = (props, styles) => {
	  const {
	    ownerState
	  } = props;
	  return [styles.input, ownerState.size === 'small' && styles.inputSizeSmall, ownerState.multiline && styles.inputMultiline, ownerState.type === 'search' && styles.inputTypeSearch, ownerState.startAdornment && styles.inputAdornedStart, ownerState.endAdornment && styles.inputAdornedEnd, ownerState.hiddenLabel && styles.inputHiddenLabel];
	};
	const useUtilityClasses$7 = ownerState => {
	  const {
	    classes,
	    color,
	    disabled,
	    error,
	    endAdornment,
	    focused,
	    formControl,
	    fullWidth,
	    hiddenLabel,
	    multiline,
	    readOnly,
	    size,
	    startAdornment,
	    type
	  } = ownerState;
	  const slots = {
	    root: ['root', `color${capitalize(color)}`, disabled && 'disabled', error && 'error', fullWidth && 'fullWidth', focused && 'focused', formControl && 'formControl', size && size !== 'medium' && `size${capitalize(size)}`, multiline && 'multiline', startAdornment && 'adornedStart', endAdornment && 'adornedEnd', hiddenLabel && 'hiddenLabel', readOnly && 'readOnly'],
	    input: ['input', disabled && 'disabled', type === 'search' && 'inputTypeSearch', multiline && 'inputMultiline', size === 'small' && 'inputSizeSmall', hiddenLabel && 'inputHiddenLabel', startAdornment && 'inputAdornedStart', endAdornment && 'inputAdornedEnd', readOnly && 'readOnly']
	  };
	  return composeClasses(slots, getInputBaseUtilityClass, classes);
	};
	const InputBaseRoot = styled('div', {
	  name: 'MuiInputBase',
	  slot: 'Root',
	  overridesResolver: rootOverridesResolver
	})(memoTheme(({
	  theme
	}) => ({
	  ...theme.typography.body1,
	  color: (theme.vars || theme).palette.text.primary,
	  lineHeight: '1.4375em',
	  // 23px
	  boxSizing: 'border-box',
	  // Prevent padding issue with fullWidth.
	  position: 'relative',
	  cursor: 'text',
	  display: 'inline-flex',
	  alignItems: 'center',
	  [`&.${inputBaseClasses.disabled}`]: {
	    color: (theme.vars || theme).palette.text.disabled,
	    cursor: 'default'
	  },
	  variants: [{
	    props: ({
	      ownerState
	    }) => ownerState.multiline,
	    style: {
	      padding: '4px 0 5px'
	    }
	  }, {
	    props: ({
	      ownerState,
	      size
	    }) => ownerState.multiline && size === 'small',
	    style: {
	      paddingTop: 1
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.fullWidth,
	    style: {
	      width: '100%'
	    }
	  }]
	})));
	const InputBaseInput = styled('input', {
	  name: 'MuiInputBase',
	  slot: 'Input',
	  overridesResolver: inputOverridesResolver
	})(memoTheme(({
	  theme
	}) => {
	  const light = theme.palette.mode === 'light';
	  const placeholder = {
	    color: 'currentColor',
	    ...(theme.vars ? {
	      opacity: theme.vars.opacity.inputPlaceholder
	    } : {
	      opacity: light ? 0.42 : 0.5
	    }),
	    transition: theme.transitions.create('opacity', {
	      duration: theme.transitions.duration.shorter
	    })
	  };
	  const placeholderHidden = {
	    opacity: '0 !important'
	  };
	  const placeholderVisible = theme.vars ? {
	    opacity: theme.vars.opacity.inputPlaceholder
	  } : {
	    opacity: light ? 0.42 : 0.5
	  };
	  return {
	    font: 'inherit',
	    letterSpacing: 'inherit',
	    color: 'currentColor',
	    padding: '4px 0 5px',
	    border: 0,
	    boxSizing: 'content-box',
	    background: 'none',
	    height: '1.4375em',
	    // Reset 23pxthe native input line-height
	    margin: 0,
	    // Reset for Safari
	    WebkitTapHighlightColor: 'transparent',
	    display: 'block',
	    // Make the flex item shrink with Firefox
	    minWidth: 0,
	    width: '100%',
	    '&::-webkit-input-placeholder': placeholder,
	    '&::-moz-placeholder': placeholder,
	    // Firefox 19+
	    '&::-ms-input-placeholder': placeholder,
	    // Edge
	    '&:focus': {
	      outline: 0
	    },
	    // Reset Firefox invalid required input style
	    '&:invalid': {
	      boxShadow: 'none'
	    },
	    '&::-webkit-search-decoration': {
	      // Remove the padding when type=search.
	      WebkitAppearance: 'none'
	    },
	    // Show and hide the placeholder logic
	    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
	      '&::-webkit-input-placeholder': placeholderHidden,
	      '&::-moz-placeholder': placeholderHidden,
	      // Firefox 19+
	      '&::-ms-input-placeholder': placeholderHidden,
	      // Edge
	      '&:focus::-webkit-input-placeholder': placeholderVisible,
	      '&:focus::-moz-placeholder': placeholderVisible,
	      // Firefox 19+
	      '&:focus::-ms-input-placeholder': placeholderVisible // Edge
	    },
	    [`&.${inputBaseClasses.disabled}`]: {
	      opacity: 1,
	      // Reset iOS opacity
	      WebkitTextFillColor: (theme.vars || theme).palette.text.disabled // Fix opacity Safari bug
	    },
	    variants: [{
	      props: ({
	        ownerState
	      }) => !ownerState.disableInjectingGlobalStyles,
	      style: {
	        animationName: 'mui-auto-fill-cancel',
	        animationDuration: '10ms',
	        '&:-webkit-autofill': {
	          animationDuration: '5000s',
	          animationName: 'mui-auto-fill'
	        }
	      }
	    }, {
	      props: {
	        size: 'small'
	      },
	      style: {
	        paddingTop: 1
	      }
	    }, {
	      props: ({
	        ownerState
	      }) => ownerState.multiline,
	      style: {
	        height: 'auto',
	        resize: 'none',
	        padding: 0,
	        paddingTop: 0
	      }
	    }, {
	      props: {
	        type: 'search'
	      },
	      style: {
	        MozAppearance: 'textfield' // Improve type search style.
	      }
	    }]
	  };
	}));
	const InputGlobalStyles = globalCss({
	  '@keyframes mui-auto-fill': {
	    from: {
	      display: 'block'
	    }
	  },
	  '@keyframes mui-auto-fill-cancel': {
	    from: {
	      display: 'block'
	    }
	  }
	});

	/**
	 * `InputBase` contains as few styles as possible.
	 * It aims to be a simple building block for creating an input.
	 * It contains a load of style reset and some state logic.
	 */
	const InputBase = /*#__PURE__*/reactExports.forwardRef(function InputBase(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiInputBase'
	  });
	  const {
	    'aria-describedby': ariaDescribedby,
	    autoComplete,
	    autoFocus,
	    className,
	    color,
	    components = {},
	    componentsProps = {},
	    defaultValue,
	    disabled,
	    disableInjectingGlobalStyles,
	    endAdornment,
	    error,
	    fullWidth = false,
	    id,
	    inputComponent = 'input',
	    inputProps: inputPropsProp = {},
	    inputRef: inputRefProp,
	    margin,
	    maxRows,
	    minRows,
	    multiline = false,
	    name,
	    onBlur,
	    onChange,
	    onClick,
	    onFocus,
	    onKeyDown,
	    onKeyUp,
	    placeholder,
	    readOnly,
	    renderSuffix,
	    rows,
	    size,
	    slotProps = {},
	    slots = {},
	    startAdornment,
	    type = 'text',
	    value: valueProp,
	    ...other
	  } = props;
	  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
	  const {
	    current: isControlled
	  } = reactExports.useRef(value != null);
	  const inputRef = reactExports.useRef();
	  const handleInputRefWarning = reactExports.useCallback(instance => {
	  }, []);
	  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
	  const [focused, setFocused] = reactExports.useState(false);
	  const muiFormControl = useFormControl();
	  const fcs = formControlState({
	    props,
	    muiFormControl,
	    states: ['color', 'disabled', 'error', 'hiddenLabel', 'size', 'required', 'filled']
	  });
	  fcs.focused = muiFormControl ? muiFormControl.focused : focused;

	  // The blur won't fire when the disabled state is set on a focused input.
	  // We need to book keep the focused state manually.
	  reactExports.useEffect(() => {
	    if (!muiFormControl && disabled && focused) {
	      setFocused(false);
	      if (onBlur) {
	        onBlur();
	      }
	    }
	  }, [muiFormControl, disabled, focused, onBlur]);
	  const onFilled = muiFormControl && muiFormControl.onFilled;
	  const onEmpty = muiFormControl && muiFormControl.onEmpty;
	  const checkDirty = reactExports.useCallback(obj => {
	    if (isFilled(obj)) {
	      if (onFilled) {
	        onFilled();
	      }
	    } else if (onEmpty) {
	      onEmpty();
	    }
	  }, [onFilled, onEmpty]);
	  useEnhancedEffect(() => {
	    if (isControlled) {
	      checkDirty({
	        value
	      });
	    }
	  }, [value, checkDirty, isControlled]);
	  const handleFocus = event => {
	    if (onFocus) {
	      onFocus(event);
	    }
	    if (inputPropsProp.onFocus) {
	      inputPropsProp.onFocus(event);
	    }
	    if (muiFormControl && muiFormControl.onFocus) {
	      muiFormControl.onFocus(event);
	    } else {
	      setFocused(true);
	    }
	  };
	  const handleBlur = event => {
	    if (onBlur) {
	      onBlur(event);
	    }
	    if (inputPropsProp.onBlur) {
	      inputPropsProp.onBlur(event);
	    }
	    if (muiFormControl && muiFormControl.onBlur) {
	      muiFormControl.onBlur(event);
	    } else {
	      setFocused(false);
	    }
	  };
	  const handleChange = (event, ...args) => {
	    if (!isControlled) {
	      const element = event.target || inputRef.current;
	      if (element == null) {
	        throw new Error(formatMuiErrorMessage(1));
	      }
	      checkDirty({
	        value: element.value
	      });
	    }
	    if (inputPropsProp.onChange) {
	      inputPropsProp.onChange(event, ...args);
	    }

	    // Perform in the willUpdate
	    if (onChange) {
	      onChange(event, ...args);
	    }
	  };

	  // Check the input state on mount, in case it was filled by the user
	  // or auto filled by the browser before the hydration (for SSR).
	  reactExports.useEffect(() => {
	    checkDirty(inputRef.current);
	    // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, []);
	  const handleClick = event => {
	    if (inputRef.current && event.currentTarget === event.target) {
	      inputRef.current.focus();
	    }
	    if (onClick) {
	      onClick(event);
	    }
	  };
	  let InputComponent = inputComponent;
	  let inputProps = inputPropsProp;
	  if (multiline && InputComponent === 'input') {
	    if (rows) {
	      inputProps = {
	        type: undefined,
	        minRows: rows,
	        maxRows: rows,
	        ...inputProps
	      };
	    } else {
	      inputProps = {
	        type: undefined,
	        maxRows,
	        minRows,
	        ...inputProps
	      };
	    }
	    InputComponent = TextareaAutosize;
	  }
	  const handleAutoFill = event => {
	    // Provide a fake value as Chrome might not let you access it for security reasons.
	    checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {
	      value: 'x'
	    });
	  };
	  reactExports.useEffect(() => {
	    if (muiFormControl) {
	      muiFormControl.setAdornedStart(Boolean(startAdornment));
	    }
	  }, [muiFormControl, startAdornment]);
	  const ownerState = {
	    ...props,
	    color: fcs.color || 'primary',
	    disabled: fcs.disabled,
	    endAdornment,
	    error: fcs.error,
	    focused: fcs.focused,
	    formControl: muiFormControl,
	    fullWidth,
	    hiddenLabel: fcs.hiddenLabel,
	    multiline,
	    size: fcs.size,
	    startAdornment,
	    type
	  };
	  const classes = useUtilityClasses$7(ownerState);
	  const Root = slots.root || components.Root || InputBaseRoot;
	  const rootProps = slotProps.root || componentsProps.root || {};
	  const Input = slots.input || components.Input || InputBaseInput;
	  inputProps = {
	    ...inputProps,
	    ...(slotProps.input ?? componentsProps.input)
	  };
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
	    children: [!disableInjectingGlobalStyles && typeof InputGlobalStyles === 'function' && (// For Emotion/Styled-components, InputGlobalStyles will be a function
	    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
	    _InputGlobalStyles || (_InputGlobalStyles = /*#__PURE__*/jsxRuntimeExports.jsx(InputGlobalStyles, {}))), /*#__PURE__*/jsxRuntimeExports.jsxs(Root, {
	      ...rootProps,
	      ref: ref,
	      onClick: handleClick,
	      ...other,
	      ...(!isHostComponent(Root) && {
	        ownerState: {
	          ...ownerState,
	          ...rootProps.ownerState
	        }
	      }),
	      className: clsx(classes.root, rootProps.className, className, readOnly && 'MuiInputBase-readOnly'),
	      children: [startAdornment, /*#__PURE__*/jsxRuntimeExports.jsx(FormControlContext.Provider, {
	        value: null,
	        children: /*#__PURE__*/jsxRuntimeExports.jsx(Input, {
	          "aria-invalid": fcs.error,
	          "aria-describedby": ariaDescribedby,
	          autoComplete: autoComplete,
	          autoFocus: autoFocus,
	          defaultValue: defaultValue,
	          disabled: fcs.disabled,
	          id: id,
	          onAnimationStart: handleAutoFill,
	          name: name,
	          placeholder: placeholder,
	          readOnly: readOnly,
	          required: fcs.required,
	          rows: rows,
	          value: value,
	          onKeyDown: onKeyDown,
	          onKeyUp: onKeyUp,
	          type: type,
	          ...inputProps,
	          ...(!isHostComponent(Input) && {
	            as: InputComponent,
	            ownerState: {
	              ...ownerState,
	              ...inputProps.ownerState
	            }
	          }),
	          ref: handleInputRef,
	          className: clsx(classes.input, inputProps.className, readOnly && 'MuiInputBase-readOnly'),
	          onBlur: handleBlur,
	          onChange: handleChange,
	          onFocus: handleFocus
	        })
	      }), endAdornment, renderSuffix ? renderSuffix({
	        ...fcs,
	        startAdornment
	      }) : null]
	    })]
	  });
	});

	function getOutlinedInputUtilityClass(slot) {
	  return generateUtilityClass('MuiOutlinedInput', slot);
	}
	const outlinedInputClasses = {
	  ...inputBaseClasses,
	  ...generateUtilityClasses('MuiOutlinedInput', ['root', 'notchedOutline', 'input'])
	};

	const styles = {
	  entering: {
	    opacity: 1
	  },
	  entered: {
	    opacity: 1
	  }
	};

	/**
	 * The Fade transition is used by the [Modal](/material-ui/react-modal/) component.
	 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
	 */
	const Fade = /*#__PURE__*/reactExports.forwardRef(function Fade(props, ref) {
	  const theme = useTheme();
	  const defaultTimeout = {
	    enter: theme.transitions.duration.enteringScreen,
	    exit: theme.transitions.duration.leavingScreen
	  };
	  const {
	    addEndListener,
	    appear = true,
	    children,
	    easing,
	    in: inProp,
	    onEnter,
	    onEntered,
	    onEntering,
	    onExit,
	    onExited,
	    onExiting,
	    style,
	    timeout = defaultTimeout,
	    // eslint-disable-next-line react/prop-types
	    TransitionComponent = Transition,
	    ...other
	  } = props;
	  const nodeRef = reactExports.useRef(null);
	  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
	  const normalizedTransitionCallback = callback => maybeIsAppearing => {
	    if (callback) {
	      const node = nodeRef.current;

	      // onEnterXxx and onExitXxx callbacks have a different arguments.length value.
	      if (maybeIsAppearing === undefined) {
	        callback(node);
	      } else {
	        callback(node, maybeIsAppearing);
	      }
	    }
	  };
	  const handleEntering = normalizedTransitionCallback(onEntering);
	  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
	    reflow(node); // So the animation always start from the start.

	    const transitionProps = getTransitionProps({
	      style,
	      timeout,
	      easing
	    }, {
	      mode: 'enter'
	    });
	    node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
	    node.style.transition = theme.transitions.create('opacity', transitionProps);
	    if (onEnter) {
	      onEnter(node, isAppearing);
	    }
	  });
	  const handleEntered = normalizedTransitionCallback(onEntered);
	  const handleExiting = normalizedTransitionCallback(onExiting);
	  const handleExit = normalizedTransitionCallback(node => {
	    const transitionProps = getTransitionProps({
	      style,
	      timeout,
	      easing
	    }, {
	      mode: 'exit'
	    });
	    node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
	    node.style.transition = theme.transitions.create('opacity', transitionProps);
	    if (onExit) {
	      onExit(node);
	    }
	  });
	  const handleExited = normalizedTransitionCallback(onExited);
	  const handleAddEndListener = next => {
	    if (addEndListener) {
	      // Old call signature before `react-transition-group` implemented `nodeRef`
	      addEndListener(nodeRef.current, next);
	    }
	  };
	  return /*#__PURE__*/jsxRuntimeExports.jsx(TransitionComponent, {
	    appear: appear,
	    in: inProp,
	    nodeRef: nodeRef ,
	    onEnter: handleEnter,
	    onEntered: handleEntered,
	    onEntering: handleEntering,
	    onExit: handleExit,
	    onExited: handleExited,
	    onExiting: handleExiting,
	    addEndListener: handleAddEndListener,
	    timeout: timeout,
	    ...other,
	    children: (state, {
	      ownerState,
	      ...restChildProps
	    }) => {
	      return /*#__PURE__*/reactExports.cloneElement(children, {
	        style: {
	          opacity: 0,
	          visibility: state === 'exited' && !inProp ? 'hidden' : undefined,
	          ...styles[state],
	          ...style,
	          ...children.props.style
	        },
	        ref: handleRef,
	        ...restChildProps
	      });
	    }
	  });
	});

	function getBackdropUtilityClass(slot) {
	  return generateUtilityClass('MuiBackdrop', slot);
	}
	generateUtilityClasses('MuiBackdrop', ['root', 'invisible']);

	const useUtilityClasses$6 = ownerState => {
	  const {
	    classes,
	    invisible
	  } = ownerState;
	  const slots = {
	    root: ['root', invisible && 'invisible']
	  };
	  return composeClasses(slots, getBackdropUtilityClass, classes);
	};
	const BackdropRoot = styled('div', {
	  name: 'MuiBackdrop',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, ownerState.invisible && styles.invisible];
	  }
	})({
	  position: 'fixed',
	  display: 'flex',
	  alignItems: 'center',
	  justifyContent: 'center',
	  right: 0,
	  bottom: 0,
	  top: 0,
	  left: 0,
	  backgroundColor: 'rgba(0, 0, 0, 0.5)',
	  WebkitTapHighlightColor: 'transparent',
	  variants: [{
	    props: {
	      invisible: true
	    },
	    style: {
	      backgroundColor: 'transparent'
	    }
	  }]
	});
	const Backdrop = /*#__PURE__*/reactExports.forwardRef(function Backdrop(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiBackdrop'
	  });
	  const {
	    children,
	    className,
	    component = 'div',
	    invisible = false,
	    open,
	    components = {},
	    componentsProps = {},
	    slotProps = {},
	    slots = {},
	    TransitionComponent: TransitionComponentProp,
	    transitionDuration,
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    component,
	    invisible
	  };
	  const classes = useUtilityClasses$6(ownerState);
	  const backwardCompatibleSlots = {
	    transition: TransitionComponentProp,
	    root: components.Root,
	    ...slots
	  };
	  const backwardCompatibleSlotProps = {
	    ...componentsProps,
	    ...slotProps
	  };
	  const externalForwardedProps = {
	    slots: backwardCompatibleSlots,
	    slotProps: backwardCompatibleSlotProps
	  };
	  const [RootSlot, rootProps] = useSlot('root', {
	    elementType: BackdropRoot,
	    externalForwardedProps,
	    className: clsx(classes.root, className),
	    ownerState
	  });
	  const [TransitionSlot, transitionProps] = useSlot('transition', {
	    elementType: Fade,
	    externalForwardedProps,
	    ownerState
	  });
	  return /*#__PURE__*/jsxRuntimeExports.jsx(TransitionSlot, {
	    in: open,
	    timeout: transitionDuration,
	    ...other,
	    ...transitionProps,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx(RootSlot, {
	      "aria-hidden": true,
	      ...rootProps,
	      classes: classes,
	      ref: ref,
	      children: children
	    })
	  });
	});

	const boxClasses = generateUtilityClasses('MuiBox', ['root']);

	const defaultTheme$1 = createTheme();
	const Box = createBox({
	  themeId: THEME_ID,
	  defaultTheme: defaultTheme$1,
	  defaultClassName: boxClasses.root,
	  generateClassName: ClassNameGenerator.generate
	});

	function getButtonUtilityClass(slot) {
	  return generateUtilityClass('MuiButton', slot);
	}
	const buttonClasses = generateUtilityClasses('MuiButton', ['root', 'text', 'textInherit', 'textPrimary', 'textSecondary', 'textSuccess', 'textError', 'textInfo', 'textWarning', 'outlined', 'outlinedInherit', 'outlinedPrimary', 'outlinedSecondary', 'outlinedSuccess', 'outlinedError', 'outlinedInfo', 'outlinedWarning', 'contained', 'containedInherit', 'containedPrimary', 'containedSecondary', 'containedSuccess', 'containedError', 'containedInfo', 'containedWarning', 'disableElevation', 'focusVisible', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorError', 'colorInfo', 'colorWarning', 'textSizeSmall', 'textSizeMedium', 'textSizeLarge', 'outlinedSizeSmall', 'outlinedSizeMedium', 'outlinedSizeLarge', 'containedSizeSmall', 'containedSizeMedium', 'containedSizeLarge', 'sizeMedium', 'sizeSmall', 'sizeLarge', 'fullWidth', 'startIcon', 'endIcon', 'icon', 'iconSizeSmall', 'iconSizeMedium', 'iconSizeLarge', 'loading', 'loadingWrapper', 'loadingIconPlaceholder', 'loadingIndicator', 'loadingPositionCenter', 'loadingPositionStart', 'loadingPositionEnd']);

	/**
	 * @ignore - internal component.
	 */
	const ButtonGroupContext = /*#__PURE__*/reactExports.createContext({});

	/**
	 * @ignore - internal component.
	 */
	const ButtonGroupButtonContext = /*#__PURE__*/reactExports.createContext(undefined);

	const useUtilityClasses$5 = ownerState => {
	  const {
	    color,
	    disableElevation,
	    fullWidth,
	    size,
	    variant,
	    loading,
	    loadingPosition,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', loading && 'loading', variant, `${variant}${capitalize(color)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, `color${capitalize(color)}`, disableElevation && 'disableElevation', fullWidth && 'fullWidth', loading && `loadingPosition${capitalize(loadingPosition)}`],
	    startIcon: ['icon', 'startIcon', `iconSize${capitalize(size)}`],
	    endIcon: ['icon', 'endIcon', `iconSize${capitalize(size)}`],
	    loadingIndicator: ['loadingIndicator'],
	    loadingWrapper: ['loadingWrapper']
	  };
	  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
	  return {
	    ...classes,
	    // forward the focused, disabled, etc. classes to the ButtonBase
	    ...composedClasses
	  };
	};
	const commonIconStyles = [{
	  props: {
	    size: 'small'
	  },
	  style: {
	    '& > *:nth-of-type(1)': {
	      fontSize: 18
	    }
	  }
	}, {
	  props: {
	    size: 'medium'
	  },
	  style: {
	    '& > *:nth-of-type(1)': {
	      fontSize: 20
	    }
	  }
	}, {
	  props: {
	    size: 'large'
	  },
	  style: {
	    '& > *:nth-of-type(1)': {
	      fontSize: 22
	    }
	  }
	}];
	const ButtonRoot = styled(ButtonBase, {
	  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
	  name: 'MuiButton',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, styles[ownerState.variant], styles[`${ownerState.variant}${capitalize(ownerState.color)}`], styles[`size${capitalize(ownerState.size)}`], styles[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, ownerState.disableElevation && styles.disableElevation, ownerState.fullWidth && styles.fullWidth, ownerState.loading && styles.loading];
	  }
	})(memoTheme(({
	  theme
	}) => {
	  const inheritContainedBackgroundColor = theme.palette.mode === 'light' ? theme.palette.grey[300] : theme.palette.grey[800];
	  const inheritContainedHoverBackgroundColor = theme.palette.mode === 'light' ? theme.palette.grey.A100 : theme.palette.grey[700];
	  return {
	    ...theme.typography.button,
	    minWidth: 64,
	    padding: '6px 16px',
	    border: 0,
	    borderRadius: (theme.vars || theme).shape.borderRadius,
	    transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], {
	      duration: theme.transitions.duration.short
	    }),
	    '&:hover': {
	      textDecoration: 'none'
	    },
	    [`&.${buttonClasses.disabled}`]: {
	      color: (theme.vars || theme).palette.action.disabled
	    },
	    variants: [{
	      props: {
	        variant: 'contained'
	      },
	      style: {
	        color: `var(--variant-containedColor)`,
	        backgroundColor: `var(--variant-containedBg)`,
	        boxShadow: (theme.vars || theme).shadows[2],
	        '&:hover': {
	          boxShadow: (theme.vars || theme).shadows[4],
	          // Reset on touch devices, it doesn't add specificity
	          '@media (hover: none)': {
	            boxShadow: (theme.vars || theme).shadows[2]
	          }
	        },
	        '&:active': {
	          boxShadow: (theme.vars || theme).shadows[8]
	        },
	        [`&.${buttonClasses.focusVisible}`]: {
	          boxShadow: (theme.vars || theme).shadows[6]
	        },
	        [`&.${buttonClasses.disabled}`]: {
	          color: (theme.vars || theme).palette.action.disabled,
	          boxShadow: (theme.vars || theme).shadows[0],
	          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
	        }
	      }
	    }, {
	      props: {
	        variant: 'outlined'
	      },
	      style: {
	        padding: '5px 15px',
	        border: '1px solid currentColor',
	        borderColor: `var(--variant-outlinedBorder, currentColor)`,
	        backgroundColor: `var(--variant-outlinedBg)`,
	        color: `var(--variant-outlinedColor)`,
	        [`&.${buttonClasses.disabled}`]: {
	          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
	        }
	      }
	    }, {
	      props: {
	        variant: 'text'
	      },
	      style: {
	        padding: '6px 8px',
	        color: `var(--variant-textColor)`,
	        backgroundColor: `var(--variant-textBg)`
	      }
	    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({
	      props: {
	        color
	      },
	      style: {
	        '--variant-textColor': (theme.vars || theme).palette[color].main,
	        '--variant-outlinedColor': (theme.vars || theme).palette[color].main,
	        '--variant-outlinedBorder': theme.vars ? `rgba(${theme.vars.palette[color].mainChannel} / 0.5)` : alpha(theme.palette[color].main, 0.5),
	        '--variant-containedColor': (theme.vars || theme).palette[color].contrastText,
	        '--variant-containedBg': (theme.vars || theme).palette[color].main,
	        '@media (hover: hover)': {
	          '&:hover': {
	            '--variant-containedBg': (theme.vars || theme).palette[color].dark,
	            '--variant-textBg': theme.vars ? `rgba(${theme.vars.palette[color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color].main, theme.palette.action.hoverOpacity),
	            '--variant-outlinedBorder': (theme.vars || theme).palette[color].main,
	            '--variant-outlinedBg': theme.vars ? `rgba(${theme.vars.palette[color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color].main, theme.palette.action.hoverOpacity)
	          }
	        }
	      }
	    })), {
	      props: {
	        color: 'inherit'
	      },
	      style: {
	        color: 'inherit',
	        borderColor: 'currentColor',
	        '--variant-containedBg': theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
	        '@media (hover: hover)': {
	          '&:hover': {
	            '--variant-containedBg': theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
	            '--variant-textBg': theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
	            '--variant-outlinedBg': theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
	          }
	        }
	      }
	    }, {
	      props: {
	        size: 'small',
	        variant: 'text'
	      },
	      style: {
	        padding: '4px 5px',
	        fontSize: theme.typography.pxToRem(13)
	      }
	    }, {
	      props: {
	        size: 'large',
	        variant: 'text'
	      },
	      style: {
	        padding: '8px 11px',
	        fontSize: theme.typography.pxToRem(15)
	      }
	    }, {
	      props: {
	        size: 'small',
	        variant: 'outlined'
	      },
	      style: {
	        padding: '3px 9px',
	        fontSize: theme.typography.pxToRem(13)
	      }
	    }, {
	      props: {
	        size: 'large',
	        variant: 'outlined'
	      },
	      style: {
	        padding: '7px 21px',
	        fontSize: theme.typography.pxToRem(15)
	      }
	    }, {
	      props: {
	        size: 'small',
	        variant: 'contained'
	      },
	      style: {
	        padding: '4px 10px',
	        fontSize: theme.typography.pxToRem(13)
	      }
	    }, {
	      props: {
	        size: 'large',
	        variant: 'contained'
	      },
	      style: {
	        padding: '8px 22px',
	        fontSize: theme.typography.pxToRem(15)
	      }
	    }, {
	      props: {
	        disableElevation: true
	      },
	      style: {
	        boxShadow: 'none',
	        '&:hover': {
	          boxShadow: 'none'
	        },
	        [`&.${buttonClasses.focusVisible}`]: {
	          boxShadow: 'none'
	        },
	        '&:active': {
	          boxShadow: 'none'
	        },
	        [`&.${buttonClasses.disabled}`]: {
	          boxShadow: 'none'
	        }
	      }
	    }, {
	      props: {
	        fullWidth: true
	      },
	      style: {
	        width: '100%'
	      }
	    }, {
	      props: {
	        loadingPosition: 'center'
	      },
	      style: {
	        transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color'], {
	          duration: theme.transitions.duration.short
	        }),
	        [`&.${buttonClasses.loading}`]: {
	          color: 'transparent'
	        }
	      }
	    }]
	  };
	}));
	const ButtonStartIcon = styled('span', {
	  name: 'MuiButton',
	  slot: 'StartIcon',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.startIcon, ownerState.loading && styles.startIconLoadingStart, styles[`iconSize${capitalize(ownerState.size)}`]];
	  }
	})(({
	  theme
	}) => ({
	  display: 'inherit',
	  marginRight: 8,
	  marginLeft: -4,
	  variants: [{
	    props: {
	      size: 'small'
	    },
	    style: {
	      marginLeft: -2
	    }
	  }, {
	    props: {
	      loadingPosition: 'start',
	      loading: true
	    },
	    style: {
	      transition: theme.transitions.create(['opacity'], {
	        duration: theme.transitions.duration.short
	      }),
	      opacity: 0
	    }
	  }, {
	    props: {
	      loadingPosition: 'start',
	      loading: true,
	      fullWidth: true
	    },
	    style: {
	      marginRight: -8
	    }
	  }, ...commonIconStyles]
	}));
	const ButtonEndIcon = styled('span', {
	  name: 'MuiButton',
	  slot: 'EndIcon',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.endIcon, ownerState.loading && styles.endIconLoadingEnd, styles[`iconSize${capitalize(ownerState.size)}`]];
	  }
	})(({
	  theme
	}) => ({
	  display: 'inherit',
	  marginRight: -4,
	  marginLeft: 8,
	  variants: [{
	    props: {
	      size: 'small'
	    },
	    style: {
	      marginRight: -2
	    }
	  }, {
	    props: {
	      loadingPosition: 'end',
	      loading: true
	    },
	    style: {
	      transition: theme.transitions.create(['opacity'], {
	        duration: theme.transitions.duration.short
	      }),
	      opacity: 0
	    }
	  }, {
	    props: {
	      loadingPosition: 'end',
	      loading: true,
	      fullWidth: true
	    },
	    style: {
	      marginLeft: -8
	    }
	  }, ...commonIconStyles]
	}));
	const ButtonLoadingIndicator = styled('span', {
	  name: 'MuiButton',
	  slot: 'LoadingIndicator'
	})(({
	  theme
	}) => ({
	  display: 'none',
	  position: 'absolute',
	  visibility: 'visible',
	  variants: [{
	    props: {
	      loading: true
	    },
	    style: {
	      display: 'flex'
	    }
	  }, {
	    props: {
	      loadingPosition: 'start'
	    },
	    style: {
	      left: 14
	    }
	  }, {
	    props: {
	      loadingPosition: 'start',
	      size: 'small'
	    },
	    style: {
	      left: 10
	    }
	  }, {
	    props: {
	      variant: 'text',
	      loadingPosition: 'start'
	    },
	    style: {
	      left: 6
	    }
	  }, {
	    props: {
	      loadingPosition: 'center'
	    },
	    style: {
	      left: '50%',
	      transform: 'translate(-50%)',
	      color: (theme.vars || theme).palette.action.disabled
	    }
	  }, {
	    props: {
	      loadingPosition: 'end'
	    },
	    style: {
	      right: 14
	    }
	  }, {
	    props: {
	      loadingPosition: 'end',
	      size: 'small'
	    },
	    style: {
	      right: 10
	    }
	  }, {
	    props: {
	      variant: 'text',
	      loadingPosition: 'end'
	    },
	    style: {
	      right: 6
	    }
	  }, {
	    props: {
	      loadingPosition: 'start',
	      fullWidth: true
	    },
	    style: {
	      position: 'relative',
	      left: -10
	    }
	  }, {
	    props: {
	      loadingPosition: 'end',
	      fullWidth: true
	    },
	    style: {
	      position: 'relative',
	      right: -10
	    }
	  }]
	}));
	const ButtonLoadingIconPlaceholder = styled('span', {
	  name: 'MuiButton',
	  slot: 'LoadingIconPlaceholder'
	})({
	  display: 'inline-block',
	  width: '1em',
	  height: '1em'
	});
	const Button = /*#__PURE__*/reactExports.forwardRef(function Button(inProps, ref) {
	  // props priority: `inProps` > `contextProps` > `themeDefaultProps`
	  const contextProps = reactExports.useContext(ButtonGroupContext);
	  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
	  const resolvedProps = resolveProps(contextProps, inProps);
	  const props = useDefaultProps({
	    props: resolvedProps,
	    name: 'MuiButton'
	  });
	  const {
	    children,
	    color = 'primary',
	    component = 'button',
	    className,
	    disabled = false,
	    disableElevation = false,
	    disableFocusRipple = false,
	    endIcon: endIconProp,
	    focusVisibleClassName,
	    fullWidth = false,
	    id: idProp,
	    loading = null,
	    loadingIndicator: loadingIndicatorProp,
	    loadingPosition = 'center',
	    size = 'medium',
	    startIcon: startIconProp,
	    type,
	    variant = 'text',
	    ...other
	  } = props;
	  const loadingId = useId(idProp);
	  const loadingIndicator = loadingIndicatorProp ?? /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgress, {
	    "aria-labelledby": loadingId,
	    color: "inherit",
	    size: 16
	  });
	  const ownerState = {
	    ...props,
	    color,
	    component,
	    disabled,
	    disableElevation,
	    disableFocusRipple,
	    fullWidth,
	    loading,
	    loadingIndicator,
	    loadingPosition,
	    size,
	    type,
	    variant
	  };
	  const classes = useUtilityClasses$5(ownerState);
	  const startIcon = (startIconProp || loading && loadingPosition === 'start') && /*#__PURE__*/jsxRuntimeExports.jsx(ButtonStartIcon, {
	    className: classes.startIcon,
	    ownerState: ownerState,
	    children: startIconProp || /*#__PURE__*/jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
	      className: classes.loadingIconPlaceholder,
	      ownerState: ownerState
	    })
	  });
	  const endIcon = (endIconProp || loading && loadingPosition === 'end') && /*#__PURE__*/jsxRuntimeExports.jsx(ButtonEndIcon, {
	    className: classes.endIcon,
	    ownerState: ownerState,
	    children: endIconProp || /*#__PURE__*/jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
	      className: classes.loadingIconPlaceholder,
	      ownerState: ownerState
	    })
	  });
	  const positionClassName = buttonGroupButtonContextPositionClassName || '';
	  const loader = typeof loading === 'boolean' ?
	  /*#__PURE__*/
	  // use plain HTML span to minimize the runtime overhead
	  jsxRuntimeExports.jsx("span", {
	    className: classes.loadingWrapper,
	    style: {
	      display: 'contents'
	    },
	    children: loading && /*#__PURE__*/jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
	      className: classes.loadingIndicator,
	      ownerState: ownerState,
	      children: loadingIndicator
	    })
	  }) : null;
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(ButtonRoot, {
	    ownerState: ownerState,
	    className: clsx(contextProps.className, classes.root, className, positionClassName),
	    component: component,
	    disabled: disabled || loading,
	    focusRipple: !disableFocusRipple,
	    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
	    ref: ref,
	    type: type,
	    id: loading ? loadingId : idProp,
	    ...other,
	    classes: classes,
	    children: [startIcon, loadingPosition !== 'end' && loader, children, loadingPosition === 'end' && loader, endIcon]
	  });
	});

	function getCardUtilityClass(slot) {
	  return generateUtilityClass('MuiCard', slot);
	}
	generateUtilityClasses('MuiCard', ['root']);

	const useUtilityClasses$4 = ownerState => {
	  const {
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root']
	  };
	  return composeClasses(slots, getCardUtilityClass, classes);
	};
	const CardRoot = styled(Paper, {
	  name: 'MuiCard',
	  slot: 'Root'
	})({
	  overflow: 'hidden'
	});
	const Card = /*#__PURE__*/reactExports.forwardRef(function Card(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiCard'
	  });
	  const {
	    className,
	    raised = false,
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    raised
	  };
	  const classes = useUtilityClasses$4(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(CardRoot, {
	    className: clsx(classes.root, className),
	    elevation: raised ? 8 : undefined,
	    ref: ref,
	    ownerState: ownerState,
	    ...other
	  });
	});

	function getCardContentUtilityClass(slot) {
	  return generateUtilityClass('MuiCardContent', slot);
	}
	generateUtilityClasses('MuiCardContent', ['root']);

	const useUtilityClasses$3 = ownerState => {
	  const {
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root']
	  };
	  return composeClasses(slots, getCardContentUtilityClass, classes);
	};
	const CardContentRoot = styled('div', {
	  name: 'MuiCardContent',
	  slot: 'Root'
	})({
	  padding: 16,
	  '&:last-child': {
	    paddingBottom: 24
	  }
	});
	const CardContent = /*#__PURE__*/reactExports.forwardRef(function CardContent(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiCardContent'
	  });
	  const {
	    className,
	    component = 'div',
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    component
	  };
	  const classes = useUtilityClasses$3(ownerState);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(CardContentRoot, {
	    as: component,
	    className: clsx(classes.root, className),
	    ownerState: ownerState,
	    ref: ref,
	    ...other
	  });
	});

	function getCardHeaderUtilityClass(slot) {
	  return generateUtilityClass('MuiCardHeader', slot);
	}
	const cardHeaderClasses = generateUtilityClasses('MuiCardHeader', ['root', 'avatar', 'action', 'content', 'title', 'subheader']);

	const useUtilityClasses$2 = ownerState => {
	  const {
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root'],
	    avatar: ['avatar'],
	    action: ['action'],
	    content: ['content'],
	    title: ['title'],
	    subheader: ['subheader']
	  };
	  return composeClasses(slots, getCardHeaderUtilityClass, classes);
	};
	const CardHeaderRoot = styled('div', {
	  name: 'MuiCardHeader',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    return [{
	      [`& .${cardHeaderClasses.title}`]: styles.title
	    }, {
	      [`& .${cardHeaderClasses.subheader}`]: styles.subheader
	    }, styles.root];
	  }
	})({
	  display: 'flex',
	  alignItems: 'center',
	  padding: 16
	});
	const CardHeaderAvatar = styled('div', {
	  name: 'MuiCardHeader',
	  slot: 'Avatar'
	})({
	  display: 'flex',
	  flex: '0 0 auto',
	  marginRight: 16
	});
	const CardHeaderAction = styled('div', {
	  name: 'MuiCardHeader',
	  slot: 'Action'
	})({
	  flex: '0 0 auto',
	  alignSelf: 'flex-start',
	  marginTop: -4,
	  marginRight: -8,
	  marginBottom: -4
	});
	const CardHeaderContent = styled('div', {
	  name: 'MuiCardHeader',
	  slot: 'Content'
	})({
	  flex: '1 1 auto',
	  [`.${typographyClasses.root}:where(& .${cardHeaderClasses.title})`]: {
	    display: 'block'
	  },
	  [`.${typographyClasses.root}:where(& .${cardHeaderClasses.subheader})`]: {
	    display: 'block'
	  }
	});
	const CardHeader = /*#__PURE__*/reactExports.forwardRef(function CardHeader(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiCardHeader'
	  });
	  const {
	    action,
	    avatar,
	    component = 'div',
	    disableTypography = false,
	    subheader: subheaderProp,
	    subheaderTypographyProps,
	    title: titleProp,
	    titleTypographyProps,
	    slots = {},
	    slotProps = {},
	    ...other
	  } = props;
	  const ownerState = {
	    ...props,
	    component,
	    disableTypography
	  };
	  const classes = useUtilityClasses$2(ownerState);
	  const externalForwardedProps = {
	    slots,
	    slotProps: {
	      title: titleTypographyProps,
	      subheader: subheaderTypographyProps,
	      ...slotProps
	    }
	  };
	  let title = titleProp;
	  const [TitleSlot, titleSlotProps] = useSlot('title', {
	    className: classes.title,
	    elementType: Typography,
	    externalForwardedProps,
	    ownerState,
	    additionalProps: {
	      variant: avatar ? 'body2' : 'h5',
	      component: 'span'
	    }
	  });
	  if (title != null && title.type !== Typography && !disableTypography) {
	    title = /*#__PURE__*/jsxRuntimeExports.jsx(TitleSlot, {
	      ...titleSlotProps,
	      children: title
	    });
	  }
	  let subheader = subheaderProp;
	  const [SubheaderSlot, subheaderSlotProps] = useSlot('subheader', {
	    className: classes.subheader,
	    elementType: Typography,
	    externalForwardedProps,
	    ownerState,
	    additionalProps: {
	      variant: avatar ? 'body2' : 'body1',
	      color: 'textSecondary',
	      component: 'span'
	    }
	  });
	  if (subheader != null && subheader.type !== Typography && !disableTypography) {
	    subheader = /*#__PURE__*/jsxRuntimeExports.jsx(SubheaderSlot, {
	      ...subheaderSlotProps,
	      children: subheader
	    });
	  }
	  const [RootSlot, rootSlotProps] = useSlot('root', {
	    ref,
	    className: classes.root,
	    elementType: CardHeaderRoot,
	    externalForwardedProps: {
	      ...externalForwardedProps,
	      ...other,
	      component
	    },
	    ownerState
	  });
	  const [AvatarSlot, avatarSlotProps] = useSlot('avatar', {
	    className: classes.avatar,
	    elementType: CardHeaderAvatar,
	    externalForwardedProps,
	    ownerState
	  });
	  const [ContentSlot, contentSlotProps] = useSlot('content', {
	    className: classes.content,
	    elementType: CardHeaderContent,
	    externalForwardedProps,
	    ownerState
	  });
	  const [ActionSlot, actionSlotProps] = useSlot('action', {
	    className: classes.action,
	    elementType: CardHeaderAction,
	    externalForwardedProps,
	    ownerState
	  });
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(RootSlot, {
	    ...rootSlotProps,
	    children: [avatar && /*#__PURE__*/jsxRuntimeExports.jsx(AvatarSlot, {
	      ...avatarSlotProps,
	      children: avatar
	    }), /*#__PURE__*/jsxRuntimeExports.jsxs(ContentSlot, {
	      ...contentSlotProps,
	      children: [title, subheader]
	    }), action && /*#__PURE__*/jsxRuntimeExports.jsx(ActionSlot, {
	      ...actionSlotProps,
	      children: action
	    })]
	  });
	});

	// A change of the browser zoom change the scrollbar size.
	// Credit https://github.com/twbs/bootstrap/blob/488fd8afc535ca3a6ad4dc581f5e89217b6a36ac/js/src/util/scrollbar.js#L14-L18
	function getScrollbarSize(win = window) {
	  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
	  const documentWidth = win.document.documentElement.clientWidth;
	  return win.innerWidth - documentWidth;
	}

	// Is a vertical scrollbar displayed?
	function isOverflowing(container) {
	  const doc = ownerDocument(container);
	  if (doc.body === container) {
	    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
	  }
	  return container.scrollHeight > container.clientHeight;
	}
	function ariaHidden(element, hide) {
	  if (hide) {
	    element.setAttribute('aria-hidden', 'true');
	  } else {
	    element.removeAttribute('aria-hidden');
	  }
	}
	function getPaddingRight(element) {
	  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
	}
	function isAriaHiddenForbiddenOnElement(element) {
	  // The forbidden HTML tags are the ones from ARIA specification that
	  // can be children of body and can't have aria-hidden attribute.
	  // cf. https://www.w3.org/TR/html-aria/#docconformance
	  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
	  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
	  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
	  return isForbiddenTagName || isInputHidden;
	}
	function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {
	  const blacklist = [mountElement, currentElement, ...elementsToExclude];
	  [].forEach.call(container.children, element => {
	    const isNotExcludedElement = !blacklist.includes(element);
	    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
	    if (isNotExcludedElement && isNotForbiddenElement) {
	      ariaHidden(element, hide);
	    }
	  });
	}
	function findIndexOf(items, callback) {
	  let idx = -1;
	  items.some((item, index) => {
	    if (callback(item)) {
	      idx = index;
	      return true;
	    }
	    return false;
	  });
	  return idx;
	}
	function handleContainer(containerInfo, props) {
	  const restoreStyle = [];
	  const container = containerInfo.container;
	  if (!props.disableScrollLock) {
	    if (isOverflowing(container)) {
	      // Compute the size before applying overflow hidden to avoid any scroll jumps.
	      const scrollbarSize = getScrollbarSize(ownerWindow(container));
	      restoreStyle.push({
	        value: container.style.paddingRight,
	        property: 'padding-right',
	        el: container
	      });
	      // Use computed style, here to get the real padding to add our scrollbar width.
	      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;

	      // .mui-fixed is a global helper.
	      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
	      [].forEach.call(fixedElements, element => {
	        restoreStyle.push({
	          value: element.style.paddingRight,
	          property: 'padding-right',
	          el: element
	        });
	        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
	      });
	    }
	    let scrollContainer;
	    if (container.parentNode instanceof DocumentFragment) {
	      scrollContainer = ownerDocument(container).body;
	    } else {
	      // Support html overflow-y: auto for scroll stability between pages
	      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
	      const parent = container.parentElement;
	      const containerWindow = ownerWindow(container);
	      scrollContainer = parent?.nodeName === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
	    }

	    // Block the scroll even if no scrollbar is visible to account for mobile keyboard
	    // screensize shrink.
	    restoreStyle.push({
	      value: scrollContainer.style.overflow,
	      property: 'overflow',
	      el: scrollContainer
	    }, {
	      value: scrollContainer.style.overflowX,
	      property: 'overflow-x',
	      el: scrollContainer
	    }, {
	      value: scrollContainer.style.overflowY,
	      property: 'overflow-y',
	      el: scrollContainer
	    });
	    scrollContainer.style.overflow = 'hidden';
	  }
	  const restore = () => {
	    restoreStyle.forEach(({
	      value,
	      el,
	      property
	    }) => {
	      if (value) {
	        el.style.setProperty(property, value);
	      } else {
	        el.style.removeProperty(property);
	      }
	    });
	  };
	  return restore;
	}
	function getHiddenSiblings(container) {
	  const hiddenSiblings = [];
	  [].forEach.call(container.children, element => {
	    if (element.getAttribute('aria-hidden') === 'true') {
	      hiddenSiblings.push(element);
	    }
	  });
	  return hiddenSiblings;
	}
	/**
	 * @ignore - do not document.
	 *
	 * Proper state management for containers and the modals in those containers.
	 * Simplified, but inspired by react-overlay's ModalManager class.
	 * Used by the Modal to ensure proper styling of containers.
	 */
	class ModalManager {
	  constructor() {
	    this.modals = [];
	    this.containers = [];
	  }
	  add(modal, container) {
	    let modalIndex = this.modals.indexOf(modal);
	    if (modalIndex !== -1) {
	      return modalIndex;
	    }
	    modalIndex = this.modals.length;
	    this.modals.push(modal);

	    // If the modal we are adding is already in the DOM.
	    if (modal.modalRef) {
	      ariaHidden(modal.modalRef, false);
	    }
	    const hiddenSiblings = getHiddenSiblings(container);
	    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
	    const containerIndex = findIndexOf(this.containers, item => item.container === container);
	    if (containerIndex !== -1) {
	      this.containers[containerIndex].modals.push(modal);
	      return modalIndex;
	    }
	    this.containers.push({
	      modals: [modal],
	      container,
	      restore: null,
	      hiddenSiblings
	    });
	    return modalIndex;
	  }
	  mount(modal, props) {
	    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));
	    const containerInfo = this.containers[containerIndex];
	    if (!containerInfo.restore) {
	      containerInfo.restore = handleContainer(containerInfo, props);
	    }
	  }
	  remove(modal, ariaHiddenState = true) {
	    const modalIndex = this.modals.indexOf(modal);
	    if (modalIndex === -1) {
	      return modalIndex;
	    }
	    const containerIndex = findIndexOf(this.containers, item => item.modals.includes(modal));
	    const containerInfo = this.containers[containerIndex];
	    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
	    this.modals.splice(modalIndex, 1);

	    // If that was the last modal in a container, clean up the container.
	    if (containerInfo.modals.length === 0) {
	      // The modal might be closed before it had the chance to be mounted in the DOM.
	      if (containerInfo.restore) {
	        containerInfo.restore();
	      }
	      if (modal.modalRef) {
	        // In case the modal wasn't in the DOM yet.
	        ariaHidden(modal.modalRef, ariaHiddenState);
	      }
	      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
	      this.containers.splice(containerIndex, 1);
	    } else {
	      // Otherwise make sure the next top modal is visible to a screen reader.
	      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
	      // as soon as a modal is adding its modalRef is undefined. it can't set
	      // aria-hidden because the dom element doesn't exist either
	      // when modal was unmounted before modalRef gets null
	      if (nextTop.modalRef) {
	        ariaHidden(nextTop.modalRef, false);
	      }
	    }
	    return modalIndex;
	  }
	  isTopModal(modal) {
	    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
	  }
	}

	// Inspired by https://github.com/focus-trap/tabbable
	const candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',');
	function getTabIndex(node) {
	  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);
	  if (!Number.isNaN(tabindexAttr)) {
	    return tabindexAttr;
	  }

	  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
	  // https://issues.chromium.org/issues/41283952
	  // so if they don't have a tabindex attribute specifically set, assume it's 0.
	  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
	  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
	  //  yet they are still part of the regular tab order; in FF, they get a default
	  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
	  //  order, consider their tab index to be 0.
	  if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
	    return 0;
	  }
	  return node.tabIndex;
	}
	function isNonTabbableRadio(node) {
	  if (node.tagName !== 'INPUT' || node.type !== 'radio') {
	    return false;
	  }
	  if (!node.name) {
	    return false;
	  }
	  const getRadio = selector => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);
	  let roving = getRadio(`[name="${node.name}"]:checked`);
	  if (!roving) {
	    roving = getRadio(`[name="${node.name}"]`);
	  }
	  return roving !== node;
	}
	function isNodeMatchingSelectorFocusable(node) {
	  if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {
	    return false;
	  }
	  return true;
	}
	function defaultGetTabbable(root) {
	  const regularTabNodes = [];
	  const orderedTabNodes = [];
	  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
	    const nodeTabIndex = getTabIndex(node);
	    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
	      return;
	    }
	    if (nodeTabIndex === 0) {
	      regularTabNodes.push(node);
	    } else {
	      orderedTabNodes.push({
	        documentOrder: i,
	        tabIndex: nodeTabIndex,
	        node: node
	      });
	    }
	  });
	  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);
	}
	function defaultIsEnabled() {
	  return true;
	}

	/**
	 * @ignore - internal component.
	 */
	function FocusTrap(props) {
	  const {
	    children,
	    disableAutoFocus = false,
	    disableEnforceFocus = false,
	    disableRestoreFocus = false,
	    getTabbable = defaultGetTabbable,
	    isEnabled = defaultIsEnabled,
	    open
	  } = props;
	  const ignoreNextEnforceFocus = reactExports.useRef(false);
	  const sentinelStart = reactExports.useRef(null);
	  const sentinelEnd = reactExports.useRef(null);
	  const nodeToRestore = reactExports.useRef(null);
	  const reactFocusEventTarget = reactExports.useRef(null);
	  // This variable is useful when disableAutoFocus is true.
	  // It waits for the active element to move into the component to activate.
	  const activated = reactExports.useRef(false);
	  const rootRef = reactExports.useRef(null);
	  const handleRef = useForkRef(getReactElementRef(children), rootRef);
	  const lastKeydown = reactExports.useRef(null);
	  reactExports.useEffect(() => {
	    // We might render an empty child.
	    if (!open || !rootRef.current) {
	      return;
	    }
	    activated.current = !disableAutoFocus;
	  }, [disableAutoFocus, open]);
	  reactExports.useEffect(() => {
	    // We might render an empty child.
	    if (!open || !rootRef.current) {
	      return;
	    }
	    const doc = ownerDocument(rootRef.current);
	    if (!rootRef.current.contains(doc.activeElement)) {
	      if (!rootRef.current.hasAttribute('tabIndex')) {
	        rootRef.current.setAttribute('tabIndex', '-1');
	      }
	      if (activated.current) {
	        rootRef.current.focus();
	      }
	    }
	    return () => {
	      // restoreLastFocus()
	      if (!disableRestoreFocus) {
	        // In IE11 it is possible for document.activeElement to be null resulting
	        // in nodeToRestore.current being null.
	        // Not all elements in IE11 have a focus method.
	        // Once IE11 support is dropped the focus() call can be unconditional.
	        if (nodeToRestore.current && nodeToRestore.current.focus) {
	          ignoreNextEnforceFocus.current = true;
	          nodeToRestore.current.focus();
	        }
	        nodeToRestore.current = null;
	      }
	    };
	    // Missing `disableRestoreFocus` which is fine.
	    // We don't support changing that prop on an open FocusTrap
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [open]);
	  reactExports.useEffect(() => {
	    // We might render an empty child.
	    if (!open || !rootRef.current) {
	      return;
	    }
	    const doc = ownerDocument(rootRef.current);
	    const loopFocus = nativeEvent => {
	      lastKeydown.current = nativeEvent;
	      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {
	        return;
	      }

	      // Make sure the next tab starts from the right place.
	      // doc.activeElement refers to the origin.
	      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
	        // We need to ignore the next contain as
	        // it will try to move the focus back to the rootRef element.
	        ignoreNextEnforceFocus.current = true;
	        if (sentinelEnd.current) {
	          sentinelEnd.current.focus();
	        }
	      }
	    };
	    const contain = () => {
	      const rootElement = rootRef.current;

	      // Cleanup functions are executed lazily in React 17.
	      // Contain can be called between the component being unmounted and its cleanup function being run.
	      if (rootElement === null) {
	        return;
	      }
	      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
	        ignoreNextEnforceFocus.current = false;
	        return;
	      }

	      // The focus is already inside
	      if (rootElement.contains(doc.activeElement)) {
	        return;
	      }

	      // The disableEnforceFocus is set and the focus is outside of the focus trap (and sentinel nodes)
	      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
	        return;
	      }

	      // if the focus event is not coming from inside the children's react tree, reset the refs
	      if (doc.activeElement !== reactFocusEventTarget.current) {
	        reactFocusEventTarget.current = null;
	      } else if (reactFocusEventTarget.current !== null) {
	        return;
	      }
	      if (!activated.current) {
	        return;
	      }
	      let tabbable = [];
	      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
	        tabbable = getTabbable(rootRef.current);
	      }

	      // one of the sentinel nodes was focused, so move the focus
	      // to the first/last tabbable element inside the focus trap
	      if (tabbable.length > 0) {
	        const isShiftTab = Boolean(lastKeydown.current?.shiftKey && lastKeydown.current?.key === 'Tab');
	        const focusNext = tabbable[0];
	        const focusPrevious = tabbable[tabbable.length - 1];
	        if (typeof focusNext !== 'string' && typeof focusPrevious !== 'string') {
	          if (isShiftTab) {
	            focusPrevious.focus();
	          } else {
	            focusNext.focus();
	          }
	        }
	        // no tabbable elements in the trap focus or the focus was outside of the focus trap
	      } else {
	        rootElement.focus();
	      }
	    };
	    doc.addEventListener('focusin', contain);
	    doc.addEventListener('keydown', loopFocus, true);

	    // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.
	    // for example https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
	    // Instead, we can look if the active element was restored on the BODY element.
	    //
	    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
	    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.
	    const interval = setInterval(() => {
	      if (doc.activeElement && doc.activeElement.tagName === 'BODY') {
	        contain();
	      }
	    }, 50);
	    return () => {
	      clearInterval(interval);
	      doc.removeEventListener('focusin', contain);
	      doc.removeEventListener('keydown', loopFocus, true);
	    };
	  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
	  const onFocus = event => {
	    if (nodeToRestore.current === null) {
	      nodeToRestore.current = event.relatedTarget;
	    }
	    activated.current = true;
	    reactFocusEventTarget.current = event.target;
	    const childrenPropsHandler = children.props.onFocus;
	    if (childrenPropsHandler) {
	      childrenPropsHandler(event);
	    }
	  };
	  const handleFocusSentinel = event => {
	    if (nodeToRestore.current === null) {
	      nodeToRestore.current = event.relatedTarget;
	    }
	    activated.current = true;
	  };
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
	    children: [/*#__PURE__*/jsxRuntimeExports.jsx("div", {
	      tabIndex: open ? 0 : -1,
	      onFocus: handleFocusSentinel,
	      ref: sentinelStart,
	      "data-testid": "sentinelStart"
	    }), /*#__PURE__*/reactExports.cloneElement(children, {
	      ref: handleRef,
	      onFocus
	    }), /*#__PURE__*/jsxRuntimeExports.jsx("div", {
	      tabIndex: open ? 0 : -1,
	      onFocus: handleFocusSentinel,
	      ref: sentinelEnd,
	      "data-testid": "sentinelEnd"
	    })]
	  });
	}

	function getContainer(container) {
	  return typeof container === 'function' ? container() : container;
	}
	function getHasTransition(children) {
	  return children ? children.props.hasOwnProperty('in') : false;
	}
	const noop$2 = () => {};

	// A modal manager used to track and manage the state of open Modals.
	// Modals don't open on the server so this won't conflict with concurrent requests.
	const manager = new ModalManager();
	function useModal(parameters) {
	  const {
	    container,
	    disableEscapeKeyDown = false,
	    disableScrollLock = false,
	    closeAfterTransition = false,
	    onTransitionEnter,
	    onTransitionExited,
	    children,
	    onClose,
	    open,
	    rootRef
	  } = parameters;

	  // @ts-ignore internal logic
	  const modal = reactExports.useRef({});
	  const mountNodeRef = reactExports.useRef(null);
	  const modalRef = reactExports.useRef(null);
	  const handleRef = useForkRef(modalRef, rootRef);
	  const [exited, setExited] = reactExports.useState(!open);
	  const hasTransition = getHasTransition(children);
	  let ariaHiddenProp = true;
	  if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {
	    ariaHiddenProp = false;
	  }
	  const getDoc = () => ownerDocument(mountNodeRef.current);
	  const getModal = () => {
	    modal.current.modalRef = modalRef.current;
	    modal.current.mount = mountNodeRef.current;
	    return modal.current;
	  };
	  const handleMounted = () => {
	    manager.mount(getModal(), {
	      disableScrollLock
	    });

	    // Fix a bug on Chrome where the scroll isn't initially 0.
	    if (modalRef.current) {
	      modalRef.current.scrollTop = 0;
	    }
	  };
	  const handleOpen = useEventCallback(() => {
	    const resolvedContainer = getContainer(container) || getDoc().body;
	    manager.add(getModal(), resolvedContainer);

	    // The element was already mounted.
	    if (modalRef.current) {
	      handleMounted();
	    }
	  });
	  const isTopModal = () => manager.isTopModal(getModal());
	  const handlePortalRef = useEventCallback(node => {
	    mountNodeRef.current = node;
	    if (!node) {
	      return;
	    }
	    if (open && isTopModal()) {
	      handleMounted();
	    } else if (modalRef.current) {
	      ariaHidden(modalRef.current, ariaHiddenProp);
	    }
	  });
	  const handleClose = reactExports.useCallback(() => {
	    manager.remove(getModal(), ariaHiddenProp);
	  }, [ariaHiddenProp]);
	  reactExports.useEffect(() => {
	    return () => {
	      handleClose();
	    };
	  }, [handleClose]);
	  reactExports.useEffect(() => {
	    if (open) {
	      handleOpen();
	    } else if (!hasTransition || !closeAfterTransition) {
	      handleClose();
	    }
	  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
	  const createHandleKeyDown = otherHandlers => event => {
	    otherHandlers.onKeyDown?.(event);

	    // The handler doesn't take event.defaultPrevented into account:
	    //
	    // event.preventDefault() is meant to stop default behaviors like
	    // clicking a checkbox to check it, hitting a button to submit a form,
	    // and hitting left arrow to move the cursor in a text input etc.
	    // Only special HTML elements have these default behaviors.
	    if (event.key !== 'Escape' || event.which === 229 ||
	    // Wait until IME is settled.
	    !isTopModal()) {
	      return;
	    }
	    if (!disableEscapeKeyDown) {
	      // Swallow the event, in case someone is listening for the escape key on the body.
	      event.stopPropagation();
	      if (onClose) {
	        onClose(event, 'escapeKeyDown');
	      }
	    }
	  };
	  const createHandleBackdropClick = otherHandlers => event => {
	    otherHandlers.onClick?.(event);
	    if (event.target !== event.currentTarget) {
	      return;
	    }
	    if (onClose) {
	      onClose(event, 'backdropClick');
	    }
	  };
	  const getRootProps = (otherHandlers = {}) => {
	    const propsEventHandlers = extractEventHandlers(parameters);

	    // The custom event handlers shouldn't be spread on the root element
	    delete propsEventHandlers.onTransitionEnter;
	    delete propsEventHandlers.onTransitionExited;
	    const externalEventHandlers = {
	      ...propsEventHandlers,
	      ...otherHandlers
	    };
	    return {
	      /*
	       * Marking an element with the role presentation indicates to assistive technology
	       * that this element should be ignored; it exists to support the web application and
	       * is not meant for humans to interact with directly.
	       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
	       */
	      role: 'presentation',
	      ...externalEventHandlers,
	      onKeyDown: createHandleKeyDown(externalEventHandlers),
	      ref: handleRef
	    };
	  };
	  const getBackdropProps = (otherHandlers = {}) => {
	    const externalEventHandlers = otherHandlers;
	    return {
	      'aria-hidden': true,
	      ...externalEventHandlers,
	      onClick: createHandleBackdropClick(externalEventHandlers),
	      open
	    };
	  };
	  const getTransitionProps = () => {
	    const handleEnter = () => {
	      setExited(false);
	      if (onTransitionEnter) {
	        onTransitionEnter();
	      }
	    };
	    const handleExited = () => {
	      setExited(true);
	      if (onTransitionExited) {
	        onTransitionExited();
	      }
	      if (closeAfterTransition) {
	        handleClose();
	      }
	    };
	    return {
	      onEnter: createChainedFunction(handleEnter, children?.props.onEnter ?? noop$2),
	      onExited: createChainedFunction(handleExited, children?.props.onExited ?? noop$2)
	    };
	  };
	  return {
	    getRootProps,
	    getBackdropProps,
	    getTransitionProps,
	    rootRef: handleRef,
	    portalRef: handlePortalRef,
	    isTopModal,
	    exited,
	    hasTransition
	  };
	}

	function getModalUtilityClass(slot) {
	  return generateUtilityClass('MuiModal', slot);
	}
	generateUtilityClasses('MuiModal', ['root', 'hidden', 'backdrop']);

	const useUtilityClasses$1 = ownerState => {
	  const {
	    open,
	    exited,
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root', !open && exited && 'hidden'],
	    backdrop: ['backdrop']
	  };
	  return composeClasses(slots, getModalUtilityClass, classes);
	};
	const ModalRoot = styled('div', {
	  name: 'MuiModal',
	  slot: 'Root',
	  overridesResolver: (props, styles) => {
	    const {
	      ownerState
	    } = props;
	    return [styles.root, !ownerState.open && ownerState.exited && styles.hidden];
	  }
	})(memoTheme(({
	  theme
	}) => ({
	  position: 'fixed',
	  zIndex: (theme.vars || theme).zIndex.modal,
	  right: 0,
	  bottom: 0,
	  top: 0,
	  left: 0,
	  variants: [{
	    props: ({
	      ownerState
	    }) => !ownerState.open && ownerState.exited,
	    style: {
	      visibility: 'hidden'
	    }
	  }]
	})));
	const ModalBackdrop = styled(Backdrop, {
	  name: 'MuiModal',
	  slot: 'Backdrop'
	})({
	  zIndex: -1
	});

	/**
	 * Modal is a lower-level construct that is leveraged by the following components:
	 *
	 * - [Dialog](/material-ui/api/dialog/)
	 * - [Drawer](/material-ui/api/drawer/)
	 * - [Menu](/material-ui/api/menu/)
	 * - [Popover](/material-ui/api/popover/)
	 *
	 * If you are creating a modal dialog, you probably want to use the [Dialog](/material-ui/api/dialog/) component
	 * rather than directly using Modal.
	 *
	 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
	 */
	const Modal = /*#__PURE__*/reactExports.forwardRef(function Modal(inProps, ref) {
	  const props = useDefaultProps({
	    name: 'MuiModal',
	    props: inProps
	  });
	  const {
	    BackdropComponent = ModalBackdrop,
	    BackdropProps,
	    classes: classesProp,
	    className,
	    closeAfterTransition = false,
	    children,
	    container,
	    component,
	    components = {},
	    componentsProps = {},
	    disableAutoFocus = false,
	    disableEnforceFocus = false,
	    disableEscapeKeyDown = false,
	    disablePortal = false,
	    disableRestoreFocus = false,
	    disableScrollLock = false,
	    hideBackdrop = false,
	    keepMounted = false,
	    onClose,
	    onTransitionEnter,
	    onTransitionExited,
	    open,
	    slotProps = {},
	    slots = {},
	    // eslint-disable-next-line react/prop-types
	    theme,
	    ...other
	  } = props;
	  const propsWithDefaults = {
	    ...props,
	    closeAfterTransition,
	    disableAutoFocus,
	    disableEnforceFocus,
	    disableEscapeKeyDown,
	    disablePortal,
	    disableRestoreFocus,
	    disableScrollLock,
	    hideBackdrop,
	    keepMounted
	  };
	  const {
	    getRootProps,
	    getBackdropProps,
	    getTransitionProps,
	    portalRef,
	    isTopModal,
	    exited,
	    hasTransition
	  } = useModal({
	    ...propsWithDefaults,
	    rootRef: ref
	  });
	  const ownerState = {
	    ...propsWithDefaults,
	    exited
	  };
	  const classes = useUtilityClasses$1(ownerState);
	  const childProps = {};
	  if (children.props.tabIndex === undefined) {
	    childProps.tabIndex = '-1';
	  }

	  // It's a Transition like component
	  if (hasTransition) {
	    const {
	      onEnter,
	      onExited
	    } = getTransitionProps();
	    childProps.onEnter = onEnter;
	    childProps.onExited = onExited;
	  }
	  const externalForwardedProps = {
	    slots: {
	      root: components.Root,
	      backdrop: components.Backdrop,
	      ...slots
	    },
	    slotProps: {
	      ...componentsProps,
	      ...slotProps
	    }
	  };
	  const [RootSlot, rootProps] = useSlot('root', {
	    ref,
	    elementType: ModalRoot,
	    externalForwardedProps: {
	      ...externalForwardedProps,
	      ...other,
	      component
	    },
	    getSlotProps: getRootProps,
	    ownerState,
	    className: clsx(className, classes?.root, !ownerState.open && ownerState.exited && classes?.hidden)
	  });
	  const [BackdropSlot, backdropProps] = useSlot('backdrop', {
	    ref: BackdropProps?.ref,
	    elementType: BackdropComponent,
	    externalForwardedProps,
	    shouldForwardComponentProp: true,
	    additionalProps: BackdropProps,
	    getSlotProps: otherHandlers => {
	      return getBackdropProps({
	        ...otherHandlers,
	        onClick: event => {
	          if (otherHandlers?.onClick) {
	            otherHandlers.onClick(event);
	          }
	        }
	      });
	    },
	    className: clsx(BackdropProps?.className, classes?.backdrop),
	    ownerState
	  });
	  if (!keepMounted && !open && (!hasTransition || exited)) {
	    return null;
	  }
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Portal, {
	    ref: portalRef,
	    container: container,
	    disablePortal: disablePortal,
	    children: /*#__PURE__*/jsxRuntimeExports.jsxs(RootSlot, {
	      ...rootProps,
	      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/jsxRuntimeExports.jsx(BackdropSlot, {
	        ...backdropProps
	      }) : null, /*#__PURE__*/jsxRuntimeExports.jsx(FocusTrap, {
	        disableEnforceFocus: disableEnforceFocus,
	        disableAutoFocus: disableAutoFocus,
	        disableRestoreFocus: disableRestoreFocus,
	        isEnabled: isTopModal,
	        open: open,
	        children: /*#__PURE__*/reactExports.cloneElement(children, childProps)
	      })]
	    })
	  });
	});

	/**
	 *
	 * Demos:
	 *
	 * - [Grid](https://mui.com/material-ui/react-grid/)
	 *
	 * API:
	 *
	 * - [Grid API](https://mui.com/material-ui/api/grid/)
	 */
	const Grid = createGrid({
	  createStyledComponent: styled('div', {
	    name: 'MuiGrid',
	    slot: 'Root',
	    overridesResolver: (props, styles) => {
	      const {
	        ownerState
	      } = props;
	      return [styles.root, ownerState.container && styles.container];
	    }
	  }),
	  componentName: 'MuiGrid',
	  useThemeProps: inProps => useDefaultProps({
	    props: inProps,
	    name: 'MuiGrid'
	  }),
	  useTheme
	});

	var _span;
	const NotchedOutlineRoot$1 = styled('fieldset', {
	  shouldForwardProp: rootShouldForwardProp
	})({
	  textAlign: 'left',
	  position: 'absolute',
	  bottom: 0,
	  right: 0,
	  top: -5,
	  left: 0,
	  margin: 0,
	  padding: '0 8px',
	  pointerEvents: 'none',
	  borderRadius: 'inherit',
	  borderStyle: 'solid',
	  borderWidth: 1,
	  overflow: 'hidden',
	  minWidth: '0%'
	});
	const NotchedOutlineLegend = styled('legend', {
	  shouldForwardProp: rootShouldForwardProp
	})(memoTheme(({
	  theme
	}) => ({
	  float: 'unset',
	  // Fix conflict with bootstrap
	  width: 'auto',
	  // Fix conflict with bootstrap
	  overflow: 'hidden',
	  // Fix Horizontal scroll when label too long
	  variants: [{
	    props: ({
	      ownerState
	    }) => !ownerState.withLabel,
	    style: {
	      padding: 0,
	      lineHeight: '11px',
	      // sync with `height` in `legend` styles
	      transition: theme.transitions.create('width', {
	        duration: 150,
	        easing: theme.transitions.easing.easeOut
	      })
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.withLabel,
	    style: {
	      display: 'block',
	      // Fix conflict with normalize.css and sanitize.css
	      padding: 0,
	      height: 11,
	      // sync with `lineHeight` in `legend` styles
	      fontSize: '0.75em',
	      visibility: 'hidden',
	      maxWidth: 0.01,
	      transition: theme.transitions.create('max-width', {
	        duration: 50,
	        easing: theme.transitions.easing.easeOut
	      }),
	      whiteSpace: 'nowrap',
	      '& > span': {
	        paddingLeft: 5,
	        paddingRight: 5,
	        display: 'inline-block',
	        opacity: 0,
	        visibility: 'visible'
	      }
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.withLabel && ownerState.notched,
	    style: {
	      maxWidth: '100%',
	      transition: theme.transitions.create('max-width', {
	        duration: 100,
	        easing: theme.transitions.easing.easeOut,
	        delay: 50
	      })
	    }
	  }]
	})));

	/**
	 * @ignore - internal component.
	 */
	function NotchedOutline(props) {
	  const {
	    children,
	    classes,
	    className,
	    label,
	    notched,
	    ...other
	  } = props;
	  const withLabel = label != null && label !== '';
	  const ownerState = {
	    ...props,
	    notched,
	    withLabel
	  };
	  return /*#__PURE__*/jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
	    "aria-hidden": true,
	    className: className,
	    ownerState: ownerState,
	    ...other,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx(NotchedOutlineLegend, {
	      ownerState: ownerState,
	      children: withLabel ? /*#__PURE__*/jsxRuntimeExports.jsx("span", {
	        children: label
	      }) : // notranslate needed while Google Translate will not fix zero-width space issue
	      _span || (_span = /*#__PURE__*/jsxRuntimeExports.jsx("span", {
	        className: "notranslate",
	        "aria-hidden": true,
	        children: "\u200B"
	      }))
	    })
	  });
	}

	const useUtilityClasses = ownerState => {
	  const {
	    classes
	  } = ownerState;
	  const slots = {
	    root: ['root'],
	    notchedOutline: ['notchedOutline'],
	    input: ['input']
	  };
	  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
	  return {
	    ...classes,
	    // forward classes to the InputBase
	    ...composedClasses
	  };
	};
	const OutlinedInputRoot = styled(InputBaseRoot, {
	  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
	  name: 'MuiOutlinedInput',
	  slot: 'Root',
	  overridesResolver: rootOverridesResolver
	})(memoTheme(({
	  theme
	}) => {
	  const borderColor = theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
	  return {
	    position: 'relative',
	    borderRadius: (theme.vars || theme).shape.borderRadius,
	    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
	      borderColor: (theme.vars || theme).palette.text.primary
	    },
	    // Reset on touch devices, it doesn't add specificity
	    '@media (hover: none)': {
	      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
	        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
	      }
	    },
	    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
	      borderWidth: 2
	    },
	    variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({
	      props: {
	        color
	      },
	      style: {
	        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
	          borderColor: (theme.vars || theme).palette[color].main
	        }
	      }
	    })), {
	      props: {},
	      // to overide the above style
	      style: {
	        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
	          borderColor: (theme.vars || theme).palette.error.main
	        },
	        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
	          borderColor: (theme.vars || theme).palette.action.disabled
	        }
	      }
	    }, {
	      props: ({
	        ownerState
	      }) => ownerState.startAdornment,
	      style: {
	        paddingLeft: 14
	      }
	    }, {
	      props: ({
	        ownerState
	      }) => ownerState.endAdornment,
	      style: {
	        paddingRight: 14
	      }
	    }, {
	      props: ({
	        ownerState
	      }) => ownerState.multiline,
	      style: {
	        padding: '16.5px 14px'
	      }
	    }, {
	      props: ({
	        ownerState,
	        size
	      }) => ownerState.multiline && size === 'small',
	      style: {
	        padding: '8.5px 14px'
	      }
	    }]
	  };
	}));
	const NotchedOutlineRoot = styled(NotchedOutline, {
	  name: 'MuiOutlinedInput',
	  slot: 'NotchedOutline'
	})(memoTheme(({
	  theme
	}) => {
	  const borderColor = theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
	  return {
	    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
	  };
	}));
	const OutlinedInputInput = styled(InputBaseInput, {
	  name: 'MuiOutlinedInput',
	  slot: 'Input',
	  overridesResolver: inputOverridesResolver
	})(memoTheme(({
	  theme
	}) => ({
	  padding: '16.5px 14px',
	  ...(!theme.vars && {
	    '&:-webkit-autofill': {
	      WebkitBoxShadow: theme.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
	      WebkitTextFillColor: theme.palette.mode === 'light' ? null : '#fff',
	      caretColor: theme.palette.mode === 'light' ? null : '#fff',
	      borderRadius: 'inherit'
	    }
	  }),
	  ...(theme.vars && {
	    '&:-webkit-autofill': {
	      borderRadius: 'inherit'
	    },
	    [theme.getColorSchemeSelector('dark')]: {
	      '&:-webkit-autofill': {
	        WebkitBoxShadow: '0 0 0 100px #266798 inset',
	        WebkitTextFillColor: '#fff',
	        caretColor: '#fff'
	      }
	    }
	  }),
	  variants: [{
	    props: {
	      size: 'small'
	    },
	    style: {
	      padding: '8.5px 14px'
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.multiline,
	    style: {
	      padding: 0
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.startAdornment,
	    style: {
	      paddingLeft: 0
	    }
	  }, {
	    props: ({
	      ownerState
	    }) => ownerState.endAdornment,
	    style: {
	      paddingRight: 0
	    }
	  }]
	})));
	const OutlinedInput = /*#__PURE__*/reactExports.forwardRef(function OutlinedInput(inProps, ref) {
	  const props = useDefaultProps({
	    props: inProps,
	    name: 'MuiOutlinedInput'
	  });
	  const {
	    components = {},
	    fullWidth = false,
	    inputComponent = 'input',
	    label,
	    multiline = false,
	    notched,
	    slots = {},
	    slotProps = {},
	    type = 'text',
	    ...other
	  } = props;
	  const classes = useUtilityClasses(props);
	  const muiFormControl = useFormControl();
	  const fcs = formControlState({
	    props,
	    muiFormControl,
	    states: ['color', 'disabled', 'error', 'focused', 'hiddenLabel', 'size', 'required']
	  });
	  const ownerState = {
	    ...props,
	    color: fcs.color || 'primary',
	    disabled: fcs.disabled,
	    error: fcs.error,
	    focused: fcs.focused,
	    formControl: muiFormControl,
	    fullWidth,
	    hiddenLabel: fcs.hiddenLabel,
	    multiline,
	    size: fcs.size,
	    type
	  };
	  const RootSlot = slots.root ?? components.Root ?? OutlinedInputRoot;
	  const InputSlot = slots.input ?? components.Input ?? OutlinedInputInput;
	  const [NotchedSlot, notchedProps] = useSlot('notchedOutline', {
	    elementType: NotchedOutlineRoot,
	    className: classes.notchedOutline,
	    shouldForwardComponentProp: true,
	    ownerState,
	    externalForwardedProps: {
	      slots,
	      slotProps
	    },
	    additionalProps: {
	      label: label != null && label !== '' && fcs.required ? /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
	        children: [label, "\u2009", '*']
	      }) : label
	    }
	  });
	  return /*#__PURE__*/jsxRuntimeExports.jsx(InputBase, {
	    slots: {
	      root: RootSlot,
	      input: InputSlot
	    },
	    slotProps: slotProps,
	    renderSuffix: state => /*#__PURE__*/jsxRuntimeExports.jsx(NotchedSlot, {
	      ...notchedProps,
	      notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
	    }),
	    fullWidth: fullWidth,
	    inputComponent: inputComponent,
	    multiline: multiline,
	    ref: ref,
	    type: type,
	    ...other,
	    classes: {
	      ...classes,
	      notchedOutline: null
	    }
	  });
	});
	OutlinedInput.muiName = 'Input';

	var CloseIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
	  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
	}));

	var ReplayIcon = createSvgIcon(/*#__PURE__*/jsxRuntimeExports.jsx("path", {
	  d: "M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8"
	}));

	const style$i = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	async function callAPI$5(amount) {
	  let response = await fetch(`http://localhost:8080/tools2/api/dwarf.php?amount=${amount}`);
	  return await response.json();
	}
	async function replaceName$3(_ref) {
	  let {
	    label,
	    idx
	  } = _ref;
	  let newName = await callAPI$5(1);
	  if (label === 'male') {
	    newName = newName[0][0];
	  } else if (label === 'female') {
	    newName = newName[1][0];
	  } else if (label === 'stronghold') {
	    newName = newName[1][0];
	  }
	  document.getElementById(`${label}-${idx}-span`).innerHTML = newName;
	}
	function NameList$3(_ref2) {
	  let {
	    label,
	    names
	  } = _ref2;
	  return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	    id: `${label}-${idx}-span`
	  }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "9pt"
	    },
	    onClick: () => replaceName$3({
	      label,
	      idx
	    })
	  }))));
	}
	function DwarfName() {
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getNames(20);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async amount => {
	    const nameData = await callAPI$5(amount);
	    setNames(nameData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Dwarf"), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$i
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Dwarf Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Male Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$3, {
	    label: "male",
	    names: names[0]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Female Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$3, {
	    label: "female",
	    names: names[1]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Stronghold Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$3, {
	    label: "stronghold",
	    names: names[2]
	  })))))));
	}

	const style$h = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	async function callAPI$4(amount, type) {
	  let response = await fetch(`http://localhost:8080/tools2/api/mfnames.php?amount=${amount}&type=${type}`);
	  return await response.json();
	}
	async function replaceName$2(_ref) {
	  let {
	    label,
	    idx,
	    type
	  } = _ref;
	  let newName = await callAPI$4(1, type);
	  if (label === 'male') {
	    newName = newName[0][0];
	  } else if (label === 'female') {
	    newName = newName[1][0];
	  }
	  document.getElementById(`${label}-${idx}-span`).innerHTML = newName;
	}
	function NameList$2(_ref2) {
	  let {
	    label,
	    names,
	    type
	  } = _ref2;
	  return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", {
	    id: `${label}-${idx}-div`
	  }, /*#__PURE__*/reactExports.createElement("span", {
	    id: `${label}-${idx}-span`
	  }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "9pt"
	    },
	    onClick: () => replaceName$2({
	      label,
	      idx,
	      type
	    })
	  }))));
	}
	function MFName(props) {
	  let {
	    type
	  } = props;
	  const validTypes = ["arabic", "drow", "german", "viking", "cornish"];
	  if (!validTypes.includes(type)) {
	    type = 'drow';
	  }
	  const ucType = type.charAt(0).toUpperCase() + type.slice(1);
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getNames(20, type);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async (amount, type) => {
	    const nameData = await callAPI$4(amount, type);
	    setNames(nameData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, ucType), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$h
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, ucType, " Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20, type)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 6
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Male Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$2, {
	    label: "male",
	    names: names[0],
	    type: type
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 6
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Female Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$2, {
	    label: "female",
	    names: names[1],
	    type: type
	  })))))));
	}

	const style$g = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function TwoPartName(props) {
	  let {
	    type
	  } = props;
	  const validTypes = ['elf', 'gaelic', 'orc'];
	  if (!validTypes.includes(type)) {
	    type = 'elf';
	  }
	  const ucType = type.charAt(0).toUpperCase() + type.slice(1);
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getNames(20, type);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async (amount, type) => {
	    const nameData = await callAPI(amount, type);
	    setNames(nameData);
	    setOpen(true);
	  };
	  const updateName = async (indexToUpdate, newValue) => {
	    setNames(names.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(amount, type) {
	    let response = await fetch(`http://localhost:8080/tools2/api/twopartnames.php?amount=${amount}&type=${type}`);
	    return await response.json();
	  }
	  async function replaceName(_ref) {
	    let {
	      idx,
	      type
	    } = _ref;
	    let newName = await callAPI(1, type);
	    updateName(idx, newName[0]);
	  }
	  function NameList(_ref2) {
	    let {
	      column,
	      names,
	      type
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${column}-${idx}`
	    }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceName({
	        idx,
	        type
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, ucType), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$g
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, ucType, " Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20, type)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 1,
	    names: names[0],
	    type: type
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 2,
	    names: names[1],
	    type: type
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 3,
	    names: names[2],
	    type: type
	  })))))));
	}

	const style$f = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	async function callAPI$3(amount) {
	  let response = await fetch(`http://localhost:8080/tools2/api/korean.php?amount=${amount}`);
	  return await response.json();
	}
	async function replaceName$1(_ref) {
	  let {
	    label,
	    idx
	  } = _ref;
	  let newName = await callAPI$3(1);
	  if (label === 'male') {
	    newName = newName[0][0];
	  } else if (label === 'female') {
	    newName = newName[1][0];
	  }
	  document.getElementById(`${label}-${idx}-span`).innerHTML = newName;
	}
	function NameList$1(_ref2) {
	  let {
	    label,
	    names
	  } = _ref2;
	  return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	    id: `${label}-${idx}-span`
	  }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "9pt"
	    },
	    onClick: () => replaceName$1({
	      label,
	      idx
	    })
	  }))));
	}
	function KoreanName() {
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getNames(20);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async amount => {
	    const nameData = await callAPI$3(amount);
	    setNames(nameData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Korean"), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$f
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Korean Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 6
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Male Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$1, {
	    label: "male",
	    names: names[0]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 6
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h6",
	    component: "h2"
	  }, "Female Names"), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList$1, {
	    label: "female",
	    names: names[1]
	  })))))));
	}

	const style$e = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function AllNames() {
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getNames(20);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async amount => {
	    const nameData = await callAPI(amount);
	    setNames(nameData);
	    setOpen(true);
	  };
	  const updateName = async (indexToUpdate, newValue) => {
	    setNames(names.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(amount) {
	    let response = await fetch(`http://localhost:8080/tools2/api/twopartnames.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceName(_ref) {
	    let {
	      idx
	    } = _ref;
	    let newName = await callAPI(1);
	    updateName(idx, newName[0]);
	  }
	  function NameList(_ref2) {
	    let {
	      column,
	      names
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${column}-${idx}`
	    }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceName({
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "All Names"), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$e
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "All Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 1,
	    names: names[0]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 2,
	    names: names[1]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 3,
	    names: names[2]
	  })))))));
	}

	const style$d = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	const c = "b c d f g h j k l m n p q r s t v w x y z";
	const ch = "ck ch th sh gh st qu ph";
	const v = "a e i o u";
	const vo = "ae ea oo ee ei ie ou";
	const allowedCharsMerge = c + ' ' + c.toUpperCase() + ' ' + v + ' ' + v.toUpperCase() + ' ' + '\' = - _ . *';
	const conMerge = c + ' ' + c + ' ' + ch;
	const vowMerge = v + ' ' + v + ' ' + vo;
	const allMerge = conMerge + ' ' + vowMerge;
	const con = conMerge.split(' ');
	const vow = vowMerge.split(' ');
	const all = allMerge.split(' ');
	let allowedChars = allowedCharsMerge.split(' ');
	allowedChars.push(' ');
	function getRandom(arr) {
	  const randomIndex = Math.floor(Math.random() * arr.length);
	  return arr[randomIndex];
	}
	function makeName(pattern) {
	  let lastchar = '';
	  let newchar = '';
	  let name = '';
	  for (let x = 0; x < pattern.length; ++x) {
	    let char = pattern[x];
	    if (!allowedChars.includes(char)) {
	      continue;
	    }
	    if (char === '-') {
	      newchar = getRandom(con);
	    } else if (char === '=') {
	      newchar = getRandom(vow);
	    } else if (char === '*') {
	      newchar = getRandom(all);
	    } else if (char === '.') {
	      newchar = lastchar;
	    } else {
	      newchar = char;
	    }
	    lastchar = newchar;
	    name += newchar;
	  }
	  name = name.toLowerCase();
	  name = name.charAt(0).toUpperCase() + name.slice(1);
	  return name;
	}
	function makeNames(amount, pattern) {
	  let names = [[], [], []];
	  for (let x = 0; x < amount; ++x) {
	    names[0][x] = makeName(pattern);
	    names[1][x] = makeName(pattern);
	    names[2][x] = makeName(pattern);
	  }
	  return names;
	}
	function replaceName(_ref) {
	  let {
	    column,
	    idx
	  } = _ref;
	  const pattern = document.getElementById('pattern').value;
	  const newName = makeNames(1, pattern);
	  document.getElementById(`span-${column}-${idx}`).innerHTML = newName[0][0];
	}
	function NameList(_ref2) {
	  let {
	    column,
	    names
	  } = _ref2;
	  return /*#__PURE__*/reactExports.createElement("div", null, names.map((name, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	    id: `span-${column}-${idx}`
	  }, name), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "9pt"
	    },
	    onClick: () => replaceName({
	      column,
	      idx
	    })
	  }))));
	}
	function setPattern() {
	  const prebuilt = document.getElementById('prebuilt');
	  document.getElementById('pattern').value = prebuilt.value;
	}
	function RandomNames() {
	  const [openForm, setOpenForm] = reactExports.useState(false);
	  const handleOpenForm = () => {
	    setOpenForm(true);
	  };
	  const handleCloseForm = () => {
	    setOpenForm(false);
	  };
	  const [openNames, setOpenNames] = reactExports.useState(false);
	  const handleOpenNames = () => {
	    const pattern = document.getElementById('pattern').value;
	    const nameData = makeNames(20, pattern);
	    setNames(nameData);
	    setOpenNames(true);
	  };
	  const handleCloseNames = () => {
	    setOpenNames(false);
	    setNames(null);
	  };
	  const [names, setNames] = reactExports.useState(null);
	  const getNames = async amount => {
	    const pattern = document.getElementById('pattern').value;
	    const nameData = makeNames(amount, pattern);
	    setNames(nameData);
	    setOpenNames(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpenForm
	  }, "Random Names"), /*#__PURE__*/reactExports.createElement(Modal, {
	    open: openForm,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$d
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleCloseForm
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Random Names Interface"), /*#__PURE__*/reactExports.createElement(Typography, null, "All names are comprised of consonants and vowel. This allows you to build random names based off of prebuilt combinations of letters. All characters in the sequence will be shown as-is, except for the following:", /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement("b", null, "-"), " :: Will be replaced with a consonant.", /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement("b", null, "="), " :: Will be replaced with a vowel.", /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement("b", null, "."), " :: Will repeat the previous character.", /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement("b", null, "*"), " :: Will be replaced with a random letter.", /*#__PURE__*/reactExports.createElement("br", null)), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement("select", {
	    id: "prebuilt",
	    onChange: setPattern
	  }, /*#__PURE__*/reactExports.createElement("option", {
	    value: ""
	  }, "Select a Prebuilt or Type Your Own"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=--=-"
	  }, "-=--=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-=-"
	  }, "-=-=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-=-="
	  }, "-=-=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-.=-"
	  }, "-=-.=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-="
	  }, "-=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-=="
	  }, "-=-=="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-==-=-"
	  }, "-==-=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-==-=="
	  }, "-==-=="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=--=-="
	  }, "-=--=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-=--=-="
	  }, "=-=--=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=- -=-.=-"
	  }, "-=- -=-.=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-=-"
	  }, "-=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "-==--==-"
	  }, "-==--==-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-==-"
	  }, "=-==-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-="
	  }, "=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-=-"
	  }, "=-=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-=-="
	  }, "=-=-="), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-.=-"
	  }, "=-.=-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "=-=.-"
	  }, "=-=.-"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "****"
	  }, "****"), /*#__PURE__*/reactExports.createElement("option", {
	    value: "Z=-.=-"
	  }, "Z=-.=-")), /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement("input", {
	    type: "text",
	    id: "pattern",
	    size: "20"
	  }), /*#__PURE__*/reactExports.createElement("br", null), /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpenNames
	  }, "Generate Names")))), names && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: openNames,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$d
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleCloseNames
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Random Names", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getNames(20)
	  })), /*#__PURE__*/reactExports.createElement(Grid, {
	    container: true,
	    spacing: 2
	  }, /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 1,
	    names: names[0]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 2,
	    names: names[1]
	  }))), /*#__PURE__*/reactExports.createElement(Grid, {
	    size: 4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(NameList, {
	    column: 3,
	    names: names[2]
	  })))))));
	}

	class NameGenerators extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "Name Generators"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(MFName, {
	      type: "arabic"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(MFName, {
	      type: "cornish"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(MFName, {
	      type: "drow"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(DwarfName, null), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(TwoPartName, {
	      type: "elf"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(TwoPartName, {
	      type: "gaelic"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(MFName, {
	      type: "german"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(KoreanName, null), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(TwoPartName, {
	      type: "orc"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(MFName, {
	      type: "viking"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(AllNames, null), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(RandomNames, null), /*#__PURE__*/React.createElement("br", null)));
	  }
	}

	const style$c = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function Dressing(props) {
	  let {
	    type,
	    label
	  } = props;
	  const validTypes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'];
	  if (!validTypes.includes(type)) {
	    type = '1';
	  }
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getDressings(20, type);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setDressings(null);
	  };
	  const [dressings, setDressings] = reactExports.useState(null);
	  const getDressings = async (amount, type) => {
	    const dressingData = await callAPI(amount, type);
	    setDressings(dressingData);
	    setOpen(true);
	  };
	  const updateDressing = async (indexToUpdate, newValue) => {
	    setDressings(dressings.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(amount, type) {
	    let response = await fetch(`http://localhost:8080/tools2/api/dressing.php?amount=${amount}&type=${type}`);
	    return await response.json();
	  }
	  async function replaceDressing(_ref) {
	    let {
	      idx,
	      type
	    } = _ref;
	    let newDressing = await callAPI(1, type);
	    updateDressing(idx, newDressing[0]);
	  }
	  function DressingList(_ref2) {
	    let {
	      dressings,
	      type
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, dressings.map((dressing, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${idx}`
	    }, dressing), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceDressing({
	        idx,
	        type
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, label), dressings && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$c
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, label, /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getDressings(20, type)
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(DressingList, {
	    dressings: dressings,
	    type: type
	  })))));
	}

	class DungeonDressing extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "Dungeon Dressing"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Dressing, {
	      label: "Air Current",
	      type: "1"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Air Odor",
	      type: "2"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Air Content",
	      type: "3"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Sounds",
	      type: "4"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "General Items",
	      type: "5"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Furniture",
	      type: "6"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Religious Items",
	      type: "7"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Torture Chamber",
	      type: "8"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Mage Furnishings",
	      type: "9"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Container Contents",
	      type: "10"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Utensils",
	      type: "11"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Dressing, {
	      label: "Random Assortment",
	      type: "0"
	    }), /*#__PURE__*/React.createElement("br", null)));
	  }
	}

	const style$b = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function Trap(props) {
	  let {
	    type,
	    label
	  } = props;
	  const validTypes = ['harmless', 'moderate', 'deadly', 'tricks'];
	  if (!validTypes.includes(type)) {
	    type = 'harmless';
	  }
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getTraps(5, type);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setTraps(null);
	  };
	  const [traps, setTraps] = reactExports.useState(null);
	  const getTraps = async (amount, type) => {
	    const trapData = await callAPI(amount, type);
	    setTraps(trapData);
	    setOpen(true);
	  };
	  const updateTrap = async (indexToUpdate, newValue) => {
	    setTraps(traps.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(amount, type) {
	    let response = await fetch(`http://localhost:8080/tools2/api/traps.php?amount=${amount}&type=${type}`);
	    return await response.json();
	  }
	  async function replaceTrap(_ref) {
	    let {
	      idx,
	      type
	    } = _ref;
	    let newTrap = await callAPI(1, type);
	    updateTrap(idx, newTrap[0]);
	  }
	  function TrapList(_ref2) {
	    let {
	      traps,
	      type
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, traps.map((trap, idx) => /*#__PURE__*/reactExports.createElement("div", {
	      style: {
	        paddingBottom: "10px"
	      }
	    }, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${idx}`
	    }, trap), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceTrap({
	        idx,
	        type
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, label), traps && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$b
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, label, /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getTraps(5, type)
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    }
	  }, /*#__PURE__*/reactExports.createElement(TrapList, {
	    traps: traps,
	    type: type
	  })))));
	}

	class Traps extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "Traps"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Trap, {
	      label: "Harmless Traps",
	      type: "harmless"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Trap, {
	      label: "Moderate Traps",
	      type: "moderate"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Trap, {
	      label: "Deadly Traps",
	      type: "deadly"
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Trap, {
	      label: "Nasty Tricks",
	      type: "tricks"
	    }), /*#__PURE__*/React.createElement("br", null)));
	  }
	}

	const style$a = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenGems3(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getGems(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setGems(null);
	  };
	  const [gems, setGems] = reactExports.useState(null);
	  const getGems = async source => {
	    const gemsData = await callAPI(source);
	    setGems(gemsData);
	    setOpen(true);
	  };
	  const updateGem = async (indexToUpdate, newValue) => {
	    setGems(gems.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/gems3.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceGem(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newGem = await callAPI(source, 1);
	    updateGem(idx, newGem[0]);
	  }
	  function GemsList(_ref2) {
	    let {
	      source,
	      gems
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, gems.map((gem, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${idx}`
	    }, gem), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceGem({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Gems"), gems && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$a
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Gems", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getGems(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(GemsList, {
	    source: source,
	    gems: gems
	  })))));
	}

	const style$9 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenArt3(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getArt(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setArt(null);
	  };
	  const [arts, setArt] = reactExports.useState(null);
	  const getArt = async source => {
	    const artData = await callAPI(source);
	    setArt(artData);
	    setOpen(true);
	  };
	  const updateArt = async (indexToUpdate, newValue) => {
	    setArt(arts.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/art.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceArt(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newArt = await callAPI(source, 1);
	    updateArt(idx, newArt[0]);
	  }
	  function ArtList(_ref2) {
	    let {
	      source,
	      arts
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, arts.map((art, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", null, art), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceArt({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Artwork"), arts && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$9
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Artwork", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getArt(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(ArtList, {
	    source: source,
	    arts: arts
	  })))));
	}

	const style$8 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenMundane3(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getMundane(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setMundane(null);
	  };
	  const [mundanes, setMundane] = reactExports.useState(null);
	  const getMundane = async source => {
	    const mundaneData = await callAPI(source);
	    setMundane(mundaneData);
	    setOpen(true);
	  };
	  const updateMundane = async (indexToUpdate, newValue) => {
	    setMundane(mundanes.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/mundane.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceMundane(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newMundane = await callAPI(source, 1);
	    updateMundane(idx, newMundane[0]);
	  }
	  function MundaneList(_ref2) {
	    let {
	      source,
	      mundanes
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, mundanes.map((mundane, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${idx}`
	    }, mundane), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceMundane({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Mundane Items"), mundanes && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$8
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Mundane Items", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getMundane(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(MundaneList, {
	    source: source,
	    mundanes: mundanes
	  })))));
	}

	const style$7 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenMagicItems3(props) {
	  const {
	    sourcePrefix
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getItems(sourcePrefix);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setMinor(null);
	    setMedium(null);
	    setMajor(null);
	  };
	  const [minor, setMinor] = reactExports.useState(null);
	  const [medium, setMedium] = reactExports.useState(null);
	  const [major, setMajor] = reactExports.useState(null);
	  const getItems = async sourcePrefix => {
	    const itemData = await callAPI(sourcePrefix, 'all');
	    setMinor(itemData['Minor']);
	    setMedium(itemData['Medium']);
	    setMajor(itemData['Major']);
	    setOpen(true);
	  };
	  const updateItem = async (indexToUpdate, newValue, type) => {
	    if (type === 'Minor') {
	      setMinor(minor.map((item, index) => index === indexToUpdate ? newValue : item));
	    }
	    if (type === 'Medium') {
	      setMedium(medium.map((item, index) => index === indexToUpdate ? newValue : item));
	    }
	    if (type === 'Major') {
	      setMajor(major.map((item, index) => index === indexToUpdate ? newValue : item));
	    }
	  };
	  async function callAPI(sourcePrefix, type) {
	    let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    let args = '';
	    if (type === 'all') {
	      const minor = Math.max(0, Math.min(200, parseInt(document.getElementById(sourcePrefix + '-Minor').value)));
	      const medium = Math.max(0, Math.min(200, parseInt(document.getElementById(sourcePrefix + '-Medium').value)));
	      const major = Math.max(0, Math.min(200, parseInt(document.getElementById(sourcePrefix + '-Major').value)));
	      args = `minor=${minor}&medium=${medium}&major=${major}`;
	    } else {
	      const amountInput = document.getElementById(sourcePrefix + type);
	      let newAmount = 0;
	      if (amountInput) {
	        newAmount = parseInt(amountInput.value);
	      }
	      if (amount === 0) {
	        amount = newAmount;
	      }
	      const argsType = type.toLowerCase();
	      args = `${argsType}=${amount}`;
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/mi.php?${args}`);
	    return await response.json();
	  }
	  async function replaceItem(_ref) {
	    let {
	      sourcePrefix,
	      idx,
	      type
	    } = _ref;
	    let newItem = await callAPI(sourcePrefix, type, 1);
	    updateItem(idx, newItem[type][0], type);
	  }
	  function ItemList(_ref2) {
	    let {
	      sourcePrefix,
	      items,
	      type
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, items.map((item, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${sourcePrefix}-${type}-${idx}`
	    }, item), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceItem({
	        sourcePrefix,
	        idx,
	        type
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Magic Items"), (minor || medium || major) && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$7
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Magic Items", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getItems(sourcePrefix)
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center",
	      fontWeight: "bold"
	    }
	  }, "Minor Magic Items"), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(ItemList, {
	    sourcePrefix: sourcePrefix,
	    items: minor,
	    type: "Minor"
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center",
	      fontWeight: "bold"
	    }
	  }, "Medium Magic Items"), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(ItemList, {
	    sourcePrefix: sourcePrefix,
	    items: medium,
	    type: "Medium"
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center",
	      fontWeight: "bold"
	    }
	  }, "Major Magic Items"), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(ItemList, {
	    sourcePrefix: sourcePrefix,
	    items: major,
	    type: "Major"
	  })))));
	}

	const style$6 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	async function callAPI$2() {
	  const treasure3_cr0 = Math.max(0, Math.min(20, parseInt(document.getElementById('treasure3_cr0').value)));
	  const treasure3_cr1 = Math.max(0, Math.min(20, parseInt(document.getElementById('treasure3_cr1').value)));
	  const treasure3_cr2 = Math.max(0, Math.min(20, parseInt(document.getElementById('treasure3_cr2').value)));
	  const treasure3_cr3 = Math.max(0, Math.min(20, parseInt(document.getElementById('treasure3_cr3').value)));
	  const treasure3_cr4 = Math.max(0, Math.min(20, parseInt(document.getElementById('treasure3_cr4').value)));
	  const treasure3_q0 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure3_q0').value)));
	  const treasure3_q1 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure3_q1').value)));
	  const treasure3_q2 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure3_q2').value)));
	  const treasure3_q3 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure3_q3').value)));
	  const treasure3_q4 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure3_q4').value)));
	  let args = '';
	  if (treasure3_cr0 !== 0 && treasure3_q0 !== 0) {
	    args += `&cr0=${treasure3_cr0}&q0=${treasure3_q0}`;
	  }
	  if (treasure3_cr1 !== 0 && treasure3_q1 !== 0) {
	    args += `&cr1=${treasure3_cr1}&q1=${treasure3_q1}`;
	  }
	  if (treasure3_cr2 !== 0 && treasure3_q2 !== 0) {
	    args += `&cr2=${treasure3_cr2}&q2=${treasure3_q2}`;
	  }
	  if (treasure3_cr3 !== 0 && treasure3_q3 !== 0) {
	    args += `&cr3=${treasure3_cr3}&q3=${treasure3_q3}`;
	  }
	  if (treasure3_cr4 !== 0 && treasure3_q4 !== 0) {
	    args += `&cr4=${treasure3_cr4}&q4=${treasure3_q4}`;
	  }
	  if (args === '') {
	    return '[]';
	  }
	  args = args.slice(1);
	  let response = await fetch(`http://localhost:8080/tools2/api/treasure3.php?${args}`);
	  return await response.json();
	}
	async function replaceTreasure$1(_ref) {
	  let {
	    source,
	    key
	  } = _ref;
	  let newTreasure = await callAPI$2();
	  document.getElementById(`span-${key}`).innerHTML = `${key}: ${newTreasure[key]}`;
	  if (source !== '') {
	    document.getElementById(source).value = newTreasure[key];
	  }
	}
	function TreasureList$1(_ref2) {
	  let {
	    treasure
	  } = _ref2;
	  let totalTreasure = 0;
	  Object.keys(treasure).forEach(function (key) {
	    totalTreasure += treasure[key];
	  });
	  return /*#__PURE__*/reactExports.createElement("div", null, totalTreasure === 0 ? 'No Treasure' : Object.keys(treasure).map(function (key) {
	    let addButton = /*#__PURE__*/reactExports.createElement("span", null);
	    let addForm = /*#__PURE__*/reactExports.createElement("input", {
	      type: "hidden",
	      id: `treasure3-${key}`,
	      value: treasure[key]
	    });
	    let source = '';
	    if (key === 'Gems' && treasure[key] > 0) {
	      source = 'treasure3-Gems';
	      addButton = /*#__PURE__*/reactExports.createElement(GenGems3, {
	        source: `${source}`
	      });
	    }
	    if (key === 'Art' && treasure[key] > 0) {
	      source = 'treasure3-Art';
	      addButton = /*#__PURE__*/reactExports.createElement(GenArt3, {
	        source: `${source}`
	      });
	    }
	    if (key === 'Mundane' && treasure[key] > 0) {
	      source = 'treasure3-Mundane';
	      addButton = /*#__PURE__*/reactExports.createElement(GenMundane3, {
	        source: `${source}`
	      });
	    }
	    if (key === 'Minor' && treasure[key] > 0) {
	      source = 'treasure3-Minor';
	    }
	    if (key === 'Medium' && treasure[key] > 0) {
	      source = 'treasure3-Medium';
	    }
	    if (key === 'Major' && treasure[key] > 0) {
	      source = 'treasure3-Major';
	    }
	    return /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-${key}`
	    }, key, ": ", treasure[key]), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceTreasure$1({
	        source,
	        key
	      })
	    }), /*#__PURE__*/reactExports.createElement("br", null), addButton, addForm);
	  }));
	}
	function GenTreasure3() {
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getTreasure();
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setTreasure(null);
	  };
	  const [treasure, setTreasure] = reactExports.useState(null);
	  const getTreasure = async () => {
	    const treasureData = await callAPI$2();
	    setTreasure(treasureData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Treasure"), treasure && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$6
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Treasure", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getTreasure()
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(TreasureList$1, {
	    treasure: treasure
	  }), treasure['Minor'] + treasure['Medium'] + treasure['Major'] > 0 ? /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement(GenMagicItems3, {
	    sourcePrefix: "treasure3"
	  })) : /*#__PURE__*/reactExports.createElement("div", null)))));
	}

	class Treasure3 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "D&D 3e/3.5/Pathfinder 1 Treasure"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Grid, {
	      container: true,
	      spacing: 2
	    }, /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(Typography, {
	      sx: {
	        textAlign: "center"
	      },
	      variant: "h6",
	      component: "h2"
	    }, "CR (1-20)")), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(Typography, {
	      sx: {
	        textAlign: "center"
	      },
	      variant: "h6",
	      component: "h2"
	    }, "Quantity (1-200)")), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_cr0",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_q0",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_cr1",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_q1",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_cr2",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_q2",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_cr3",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_q3",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_cr4",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure3_q4",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }))), /*#__PURE__*/React.createElement(GenTreasure3, null)));
	  }
	}

	class Baubles3 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "D&D 3e/3.5/Pathfinder 1 Baubles"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "Gems",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenGems3, {
	      source: "Gems"
	    })), /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "Art",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenArt3, {
	      source: "Art"
	    })), /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "Mundane",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenMundane3, {
	      source: "Mundane"
	    }))));
	  }
	}

	class MagicItems3 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "D&D 3e/3.5/Pathfinder 1 Magic Items"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Grid, {
	      container: true
	    }, /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Minor Magic Items:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "main-Minor",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Medium Magic Items:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "main-Medium",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Major Magic Items:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "main-Major",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }))), /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(GenMagicItems3, {
	      sourcePrefix: "main"
	    }))));
	  }
	}

	var lib$7 = {};

	var lib$6 = {};

	var htmlToDom = {};

	var lib$5 = {};

	var lib$4 = {};

	var hasRequiredLib$7;

	function requireLib$7 () {
		if (hasRequiredLib$7) return lib$4;
		hasRequiredLib$7 = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
			/** Types of elements found in htmlparser2's DOM */
			var ElementType;
			(function (ElementType) {
			    /** Type for the root element of a document */
			    ElementType["Root"] = "root";
			    /** Type for Text */
			    ElementType["Text"] = "text";
			    /** Type for <? ... ?> */
			    ElementType["Directive"] = "directive";
			    /** Type for <!-- ... --> */
			    ElementType["Comment"] = "comment";
			    /** Type for <script> tags */
			    ElementType["Script"] = "script";
			    /** Type for <style> tags */
			    ElementType["Style"] = "style";
			    /** Type for Any tag */
			    ElementType["Tag"] = "tag";
			    /** Type for <![CDATA[ ... ]]> */
			    ElementType["CDATA"] = "cdata";
			    /** Type for <!doctype ...> */
			    ElementType["Doctype"] = "doctype";
			})(ElementType = exports.ElementType || (exports.ElementType = {}));
			/**
			 * Tests whether an element is a tag or not.
			 *
			 * @param elem Element to test
			 */
			function isTag(elem) {
			    return (elem.type === ElementType.Tag ||
			        elem.type === ElementType.Script ||
			        elem.type === ElementType.Style);
			}
			exports.isTag = isTag;
			// Exports for backwards compatibility
			/** Type for the root element of a document */
			exports.Root = ElementType.Root;
			/** Type for Text */
			exports.Text = ElementType.Text;
			/** Type for <? ... ?> */
			exports.Directive = ElementType.Directive;
			/** Type for <!-- ... --> */
			exports.Comment = ElementType.Comment;
			/** Type for <script> tags */
			exports.Script = ElementType.Script;
			/** Type for <style> tags */
			exports.Style = ElementType.Style;
			/** Type for Any tag */
			exports.Tag = ElementType.Tag;
			/** Type for <![CDATA[ ... ]]> */
			exports.CDATA = ElementType.CDATA;
			/** Type for <!doctype ...> */
			exports.Doctype = ElementType.Doctype; 
		} (lib$4));
		return lib$4;
	}

	var node = {};

	var hasRequiredNode;

	function requireNode () {
		if (hasRequiredNode) return node;
		hasRequiredNode = 1;
		var __extends = (node && node.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		var __assign = (node && node.__assign) || function () {
		    __assign = Object.assign || function(t) {
		        for (var s, i = 1, n = arguments.length; i < n; i++) {
		            s = arguments[i];
		            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
		                t[p] = s[p];
		        }
		        return t;
		    };
		    return __assign.apply(this, arguments);
		};
		Object.defineProperty(node, "__esModule", { value: true });
		node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.CDATA = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
		var domelementtype_1 = /*@__PURE__*/ requireLib$7();
		/**
		 * This object will be used as the prototype for Nodes when creating a
		 * DOM-Level-1-compliant structure.
		 */
		var Node = /** @class */ (function () {
		    function Node() {
		        /** Parent of the node */
		        this.parent = null;
		        /** Previous sibling */
		        this.prev = null;
		        /** Next sibling */
		        this.next = null;
		        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
		        this.startIndex = null;
		        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
		        this.endIndex = null;
		    }
		    Object.defineProperty(Node.prototype, "parentNode", {
		        // Read-write aliases for properties
		        /**
		         * Same as {@link parent}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.parent;
		        },
		        set: function (parent) {
		            this.parent = parent;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Node.prototype, "previousSibling", {
		        /**
		         * Same as {@link prev}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.prev;
		        },
		        set: function (prev) {
		            this.prev = prev;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Node.prototype, "nextSibling", {
		        /**
		         * Same as {@link next}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.next;
		        },
		        set: function (next) {
		            this.next = next;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    /**
		     * Clone this node, and optionally its children.
		     *
		     * @param recursive Clone child nodes as well.
		     * @returns A clone of the node.
		     */
		    Node.prototype.cloneNode = function (recursive) {
		        if (recursive === void 0) { recursive = false; }
		        return cloneNode(this, recursive);
		    };
		    return Node;
		}());
		node.Node = Node;
		/**
		 * A node that contains some data.
		 */
		var DataNode = /** @class */ (function (_super) {
		    __extends(DataNode, _super);
		    /**
		     * @param data The content of the data node
		     */
		    function DataNode(data) {
		        var _this = _super.call(this) || this;
		        _this.data = data;
		        return _this;
		    }
		    Object.defineProperty(DataNode.prototype, "nodeValue", {
		        /**
		         * Same as {@link data}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.data;
		        },
		        set: function (data) {
		            this.data = data;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return DataNode;
		}(Node));
		node.DataNode = DataNode;
		/**
		 * Text within the document.
		 */
		var Text = /** @class */ (function (_super) {
		    __extends(Text, _super);
		    function Text() {
		        var _this = _super !== null && _super.apply(this, arguments) || this;
		        _this.type = domelementtype_1.ElementType.Text;
		        return _this;
		    }
		    Object.defineProperty(Text.prototype, "nodeType", {
		        get: function () {
		            return 3;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return Text;
		}(DataNode));
		node.Text = Text;
		/**
		 * Comments within the document.
		 */
		var Comment = /** @class */ (function (_super) {
		    __extends(Comment, _super);
		    function Comment() {
		        var _this = _super !== null && _super.apply(this, arguments) || this;
		        _this.type = domelementtype_1.ElementType.Comment;
		        return _this;
		    }
		    Object.defineProperty(Comment.prototype, "nodeType", {
		        get: function () {
		            return 8;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return Comment;
		}(DataNode));
		node.Comment = Comment;
		/**
		 * Processing instructions, including doc types.
		 */
		var ProcessingInstruction = /** @class */ (function (_super) {
		    __extends(ProcessingInstruction, _super);
		    function ProcessingInstruction(name, data) {
		        var _this = _super.call(this, data) || this;
		        _this.name = name;
		        _this.type = domelementtype_1.ElementType.Directive;
		        return _this;
		    }
		    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
		        get: function () {
		            return 1;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return ProcessingInstruction;
		}(DataNode));
		node.ProcessingInstruction = ProcessingInstruction;
		/**
		 * A `Node` that can have children.
		 */
		var NodeWithChildren = /** @class */ (function (_super) {
		    __extends(NodeWithChildren, _super);
		    /**
		     * @param children Children of the node. Only certain node types can have children.
		     */
		    function NodeWithChildren(children) {
		        var _this = _super.call(this) || this;
		        _this.children = children;
		        return _this;
		    }
		    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
		        // Aliases
		        /** First child of the node. */
		        get: function () {
		            var _a;
		            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
		        /** Last child of the node. */
		        get: function () {
		            return this.children.length > 0
		                ? this.children[this.children.length - 1]
		                : null;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
		        /**
		         * Same as {@link children}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.children;
		        },
		        set: function (children) {
		            this.children = children;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return NodeWithChildren;
		}(Node));
		node.NodeWithChildren = NodeWithChildren;
		var CDATA = /** @class */ (function (_super) {
		    __extends(CDATA, _super);
		    function CDATA() {
		        var _this = _super !== null && _super.apply(this, arguments) || this;
		        _this.type = domelementtype_1.ElementType.CDATA;
		        return _this;
		    }
		    Object.defineProperty(CDATA.prototype, "nodeType", {
		        get: function () {
		            return 4;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return CDATA;
		}(NodeWithChildren));
		node.CDATA = CDATA;
		/**
		 * The root node of the document.
		 */
		var Document = /** @class */ (function (_super) {
		    __extends(Document, _super);
		    function Document() {
		        var _this = _super !== null && _super.apply(this, arguments) || this;
		        _this.type = domelementtype_1.ElementType.Root;
		        return _this;
		    }
		    Object.defineProperty(Document.prototype, "nodeType", {
		        get: function () {
		            return 9;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return Document;
		}(NodeWithChildren));
		node.Document = Document;
		/**
		 * An element within the DOM.
		 */
		var Element = /** @class */ (function (_super) {
		    __extends(Element, _super);
		    /**
		     * @param name Name of the tag, eg. `div`, `span`.
		     * @param attribs Object mapping attribute names to attribute values.
		     * @param children Children of the node.
		     */
		    function Element(name, attribs, children, type) {
		        if (children === void 0) { children = []; }
		        if (type === void 0) { type = name === "script"
		            ? domelementtype_1.ElementType.Script
		            : name === "style"
		                ? domelementtype_1.ElementType.Style
		                : domelementtype_1.ElementType.Tag; }
		        var _this = _super.call(this, children) || this;
		        _this.name = name;
		        _this.attribs = attribs;
		        _this.type = type;
		        return _this;
		    }
		    Object.defineProperty(Element.prototype, "nodeType", {
		        get: function () {
		            return 1;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Element.prototype, "tagName", {
		        // DOM Level 1 aliases
		        /**
		         * Same as {@link name}.
		         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
		         */
		        get: function () {
		            return this.name;
		        },
		        set: function (name) {
		            this.name = name;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Element.prototype, "attributes", {
		        get: function () {
		            var _this = this;
		            return Object.keys(this.attribs).map(function (name) {
		                var _a, _b;
		                return ({
		                    name: name,
		                    value: _this.attribs[name],
		                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
		                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
		                });
		            });
		        },
		        enumerable: false,
		        configurable: true
		    });
		    return Element;
		}(NodeWithChildren));
		node.Element = Element;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node is a `Element`, `false` otherwise.
		 */
		function isTag(node) {
		    return (0, domelementtype_1.isTag)(node);
		}
		node.isTag = isTag;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
		 */
		function isCDATA(node) {
		    return node.type === domelementtype_1.ElementType.CDATA;
		}
		node.isCDATA = isCDATA;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has the type `Text`, `false` otherwise.
		 */
		function isText(node) {
		    return node.type === domelementtype_1.ElementType.Text;
		}
		node.isText = isText;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has the type `Comment`, `false` otherwise.
		 */
		function isComment(node) {
		    return node.type === domelementtype_1.ElementType.Comment;
		}
		node.isComment = isComment;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
		 */
		function isDirective(node) {
		    return node.type === domelementtype_1.ElementType.Directive;
		}
		node.isDirective = isDirective;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
		 */
		function isDocument(node) {
		    return node.type === domelementtype_1.ElementType.Root;
		}
		node.isDocument = isDocument;
		/**
		 * @param node Node to check.
		 * @returns `true` if the node has children, `false` otherwise.
		 */
		function hasChildren(node) {
		    return Object.prototype.hasOwnProperty.call(node, "children");
		}
		node.hasChildren = hasChildren;
		/**
		 * Clone a node, and optionally its children.
		 *
		 * @param recursive Clone child nodes as well.
		 * @returns A clone of the node.
		 */
		function cloneNode(node, recursive) {
		    if (recursive === void 0) { recursive = false; }
		    var result;
		    if (isText(node)) {
		        result = new Text(node.data);
		    }
		    else if (isComment(node)) {
		        result = new Comment(node.data);
		    }
		    else if (isTag(node)) {
		        var children = recursive ? cloneChildren(node.children) : [];
		        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
		        children.forEach(function (child) { return (child.parent = clone_1); });
		        if (node.namespace != null) {
		            clone_1.namespace = node.namespace;
		        }
		        if (node["x-attribsNamespace"]) {
		            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
		        }
		        if (node["x-attribsPrefix"]) {
		            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
		        }
		        result = clone_1;
		    }
		    else if (isCDATA(node)) {
		        var children = recursive ? cloneChildren(node.children) : [];
		        var clone_2 = new CDATA(children);
		        children.forEach(function (child) { return (child.parent = clone_2); });
		        result = clone_2;
		    }
		    else if (isDocument(node)) {
		        var children = recursive ? cloneChildren(node.children) : [];
		        var clone_3 = new Document(children);
		        children.forEach(function (child) { return (child.parent = clone_3); });
		        if (node["x-mode"]) {
		            clone_3["x-mode"] = node["x-mode"];
		        }
		        result = clone_3;
		    }
		    else if (isDirective(node)) {
		        var instruction = new ProcessingInstruction(node.name, node.data);
		        if (node["x-name"] != null) {
		            instruction["x-name"] = node["x-name"];
		            instruction["x-publicId"] = node["x-publicId"];
		            instruction["x-systemId"] = node["x-systemId"];
		        }
		        result = instruction;
		    }
		    else {
		        throw new Error("Not implemented yet: ".concat(node.type));
		    }
		    result.startIndex = node.startIndex;
		    result.endIndex = node.endIndex;
		    if (node.sourceCodeLocation != null) {
		        result.sourceCodeLocation = node.sourceCodeLocation;
		    }
		    return result;
		}
		node.cloneNode = cloneNode;
		function cloneChildren(childs) {
		    var children = childs.map(function (child) { return cloneNode(child, true); });
		    for (var i = 1; i < children.length; i++) {
		        children[i].prev = children[i - 1];
		        children[i - 1].next = children[i];
		    }
		    return children;
		}
		return node;
	}

	var hasRequiredLib$6;

	function requireLib$6 () {
		if (hasRequiredLib$6) return lib$5;
		hasRequiredLib$6 = 1;
		(function (exports) {
			var __createBinding = (lib$5 && lib$5.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (lib$5 && lib$5.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.DomHandler = void 0;
			var domelementtype_1 = /*@__PURE__*/ requireLib$7();
			var node_js_1 = /*@__PURE__*/ requireNode();
			__exportStar(/*@__PURE__*/ requireNode(), exports);
			// Default options
			var defaultOpts = {
			    withStartIndices: false,
			    withEndIndices: false,
			    xmlMode: false,
			};
			var DomHandler = /** @class */ (function () {
			    /**
			     * @param callback Called once parsing has completed.
			     * @param options Settings for the handler.
			     * @param elementCB Callback whenever a tag is closed.
			     */
			    function DomHandler(callback, options, elementCB) {
			        /** The elements of the DOM */
			        this.dom = [];
			        /** The root element for the DOM */
			        this.root = new node_js_1.Document(this.dom);
			        /** Indicated whether parsing has been completed. */
			        this.done = false;
			        /** Stack of open tags. */
			        this.tagStack = [this.root];
			        /** A data node that is still being written to. */
			        this.lastNode = null;
			        /** Reference to the parser instance. Used for location information. */
			        this.parser = null;
			        // Make it possible to skip arguments, for backwards-compatibility
			        if (typeof options === "function") {
			            elementCB = options;
			            options = defaultOpts;
			        }
			        if (typeof callback === "object") {
			            options = callback;
			            callback = undefined;
			        }
			        this.callback = callback !== null && callback !== void 0 ? callback : null;
			        this.options = options !== null && options !== void 0 ? options : defaultOpts;
			        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
			    }
			    DomHandler.prototype.onparserinit = function (parser) {
			        this.parser = parser;
			    };
			    // Resets the handler back to starting state
			    DomHandler.prototype.onreset = function () {
			        this.dom = [];
			        this.root = new node_js_1.Document(this.dom);
			        this.done = false;
			        this.tagStack = [this.root];
			        this.lastNode = null;
			        this.parser = null;
			    };
			    // Signals the handler that parsing is done
			    DomHandler.prototype.onend = function () {
			        if (this.done)
			            return;
			        this.done = true;
			        this.parser = null;
			        this.handleCallback(null);
			    };
			    DomHandler.prototype.onerror = function (error) {
			        this.handleCallback(error);
			    };
			    DomHandler.prototype.onclosetag = function () {
			        this.lastNode = null;
			        var elem = this.tagStack.pop();
			        if (this.options.withEndIndices) {
			            elem.endIndex = this.parser.endIndex;
			        }
			        if (this.elementCB)
			            this.elementCB(elem);
			    };
			    DomHandler.prototype.onopentag = function (name, attribs) {
			        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
			        var element = new node_js_1.Element(name, attribs, undefined, type);
			        this.addNode(element);
			        this.tagStack.push(element);
			    };
			    DomHandler.prototype.ontext = function (data) {
			        var lastNode = this.lastNode;
			        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
			            lastNode.data += data;
			            if (this.options.withEndIndices) {
			                lastNode.endIndex = this.parser.endIndex;
			            }
			        }
			        else {
			            var node = new node_js_1.Text(data);
			            this.addNode(node);
			            this.lastNode = node;
			        }
			    };
			    DomHandler.prototype.oncomment = function (data) {
			        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
			            this.lastNode.data += data;
			            return;
			        }
			        var node = new node_js_1.Comment(data);
			        this.addNode(node);
			        this.lastNode = node;
			    };
			    DomHandler.prototype.oncommentend = function () {
			        this.lastNode = null;
			    };
			    DomHandler.prototype.oncdatastart = function () {
			        var text = new node_js_1.Text("");
			        var node = new node_js_1.CDATA([text]);
			        this.addNode(node);
			        text.parent = node;
			        this.lastNode = text;
			    };
			    DomHandler.prototype.oncdataend = function () {
			        this.lastNode = null;
			    };
			    DomHandler.prototype.onprocessinginstruction = function (name, data) {
			        var node = new node_js_1.ProcessingInstruction(name, data);
			        this.addNode(node);
			    };
			    DomHandler.prototype.handleCallback = function (error) {
			        if (typeof this.callback === "function") {
			            this.callback(error, this.dom);
			        }
			        else if (error) {
			            throw error;
			        }
			    };
			    DomHandler.prototype.addNode = function (node) {
			        var parent = this.tagStack[this.tagStack.length - 1];
			        var previousSibling = parent.children[parent.children.length - 1];
			        if (this.options.withStartIndices) {
			            node.startIndex = this.parser.startIndex;
			        }
			        if (this.options.withEndIndices) {
			            node.endIndex = this.parser.endIndex;
			        }
			        parent.children.push(node);
			        if (previousSibling) {
			            node.prev = previousSibling;
			            previousSibling.next = node;
			        }
			        node.parent = parent;
			        this.lastNode = null;
			    };
			    return DomHandler;
			}());
			exports.DomHandler = DomHandler;
			exports.default = DomHandler; 
		} (lib$5));
		return lib$5;
	}

	var commonjs = {};

	var Parser = {};

	var Tokenizer = {};

	var decode$1 = {};

	var decodeDataHtml$1 = {};

	var hasRequiredDecodeDataHtml$1;

	function requireDecodeDataHtml$1 () {
		if (hasRequiredDecodeDataHtml$1) return decodeDataHtml$1;
		hasRequiredDecodeDataHtml$1 = 1;
		// Generated using scripts/write-decode-map.ts
		Object.defineProperty(decodeDataHtml$1, "__esModule", { value: true });
		decodeDataHtml$1.htmlDecodeTree = void 0;
		decodeDataHtml$1.htmlDecodeTree = new Uint16Array(
		// prettier-ignore
		/* #__PURE__ */ "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
		    .split("")
		    .map((c) => c.charCodeAt(0)));
		
		return decodeDataHtml$1;
	}

	var decodeDataXml$1 = {};

	var hasRequiredDecodeDataXml$1;

	function requireDecodeDataXml$1 () {
		if (hasRequiredDecodeDataXml$1) return decodeDataXml$1;
		hasRequiredDecodeDataXml$1 = 1;
		// Generated using scripts/write-decode-map.ts
		Object.defineProperty(decodeDataXml$1, "__esModule", { value: true });
		decodeDataXml$1.xmlDecodeTree = void 0;
		decodeDataXml$1.xmlDecodeTree = new Uint16Array(
		// prettier-ignore
		/* #__PURE__ */ "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
		    .split("")
		    .map((c) => c.charCodeAt(0)));
		
		return decodeDataXml$1;
	}

	var decodeCodepoint = {};

	var hasRequiredDecodeCodepoint;

	function requireDecodeCodepoint () {
		if (hasRequiredDecodeCodepoint) return decodeCodepoint;
		hasRequiredDecodeCodepoint = 1;
		(function (exports) {
			// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
			var _a;
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.fromCodePoint = void 0;
			exports.replaceCodePoint = replaceCodePoint;
			exports.decodeCodePoint = decodeCodePoint;
			const decodeMap = new Map([
			    [0, 65533],
			    // C1 Unicode control character reference replacements
			    [128, 8364],
			    [130, 8218],
			    [131, 402],
			    [132, 8222],
			    [133, 8230],
			    [134, 8224],
			    [135, 8225],
			    [136, 710],
			    [137, 8240],
			    [138, 352],
			    [139, 8249],
			    [140, 338],
			    [142, 381],
			    [145, 8216],
			    [146, 8217],
			    [147, 8220],
			    [148, 8221],
			    [149, 8226],
			    [150, 8211],
			    [151, 8212],
			    [152, 732],
			    [153, 8482],
			    [154, 353],
			    [155, 8250],
			    [156, 339],
			    [158, 382],
			    [159, 376],
			]);
			/**
			 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
			 */
			exports.fromCodePoint = 
			// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
			(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
			    let output = "";
			    if (codePoint > 65535) {
			        codePoint -= 65536;
			        output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
			        codePoint = 56320 | (codePoint & 1023);
			    }
			    output += String.fromCharCode(codePoint);
			    return output;
			};
			/**
			 * Replace the given code point with a replacement character if it is a
			 * surrogate or is outside the valid range. Otherwise return the code
			 * point unchanged.
			 */
			function replaceCodePoint(codePoint) {
			    var _a;
			    if ((codePoint >= 55296 && codePoint <= 57343) ||
			        codePoint > 1114111) {
			        return 65533;
			    }
			    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
			}
			/**
			 * Replace the code point if relevant, then convert it to a string.
			 *
			 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
			 * @param codePoint The code point to decode.
			 * @returns The decoded code point.
			 */
			function decodeCodePoint(codePoint) {
			    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
			}
			
		} (decodeCodepoint));
		return decodeCodepoint;
	}

	var hasRequiredDecode$1;

	function requireDecode$1 () {
		if (hasRequiredDecode$1) return decode$1;
		hasRequiredDecode$1 = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = void 0;
			exports.determineBranch = determineBranch;
			exports.decodeHTML = decodeHTML;
			exports.decodeHTMLAttribute = decodeHTMLAttribute;
			exports.decodeHTMLStrict = decodeHTMLStrict;
			exports.decodeXML = decodeXML;
			const decode_data_html_js_1 = requireDecodeDataHtml$1();
			const decode_data_xml_js_1 = requireDecodeDataXml$1();
			const decode_codepoint_js_1 = requireDecodeCodepoint();
			var CharCodes;
			(function (CharCodes) {
			    CharCodes[CharCodes["NUM"] = 35] = "NUM";
			    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
			    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
			    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
			    CharCodes[CharCodes["NINE"] = 57] = "NINE";
			    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
			    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
			    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
			    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
			    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
			    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
			    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
			})(CharCodes || (CharCodes = {}));
			/** Bit that needs to be set to convert an upper case ASCII character to lower case */
			const TO_LOWER_BIT = 32;
			var BinTrieFlags;
			(function (BinTrieFlags) {
			    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
			    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
			    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
			})(BinTrieFlags || (exports.BinTrieFlags = BinTrieFlags = {}));
			function isNumber(code) {
			    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
			}
			function isHexadecimalCharacter(code) {
			    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
			        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
			}
			function isAsciiAlphaNumeric(code) {
			    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
			        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
			        isNumber(code));
			}
			/**
			 * Checks if the given character is a valid end character for an entity in an attribute.
			 *
			 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
			 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
			 */
			function isEntityInAttributeInvalidEnd(code) {
			    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
			}
			var EntityDecoderState;
			(function (EntityDecoderState) {
			    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
			    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
			    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
			    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
			    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
			})(EntityDecoderState || (EntityDecoderState = {}));
			var DecodingMode;
			(function (DecodingMode) {
			    /** Entities in text nodes that can end with any character. */
			    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
			    /** Only allow entities terminated with a semicolon. */
			    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
			    /** Entities in attributes have limitations on ending characters. */
			    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
			})(DecodingMode || (exports.DecodingMode = DecodingMode = {}));
			/**
			 * Token decoder with support of writing partial entities.
			 */
			class EntityDecoder {
			    constructor(
			    /** The tree used to decode entities. */
			    decodeTree, 
			    /**
			     * The function that is called when a codepoint is decoded.
			     *
			     * For multi-byte named entities, this will be called multiple times,
			     * with the second codepoint, and the same `consumed` value.
			     *
			     * @param codepoint The decoded codepoint.
			     * @param consumed The number of bytes consumed by the decoder.
			     */
			    emitCodePoint, 
			    /** An object that is used to produce errors. */
			    errors) {
			        this.decodeTree = decodeTree;
			        this.emitCodePoint = emitCodePoint;
			        this.errors = errors;
			        /** The current state of the decoder. */
			        this.state = EntityDecoderState.EntityStart;
			        /** Characters that were consumed while parsing an entity. */
			        this.consumed = 1;
			        /**
			         * The result of the entity.
			         *
			         * Either the result index of a numeric entity, or the codepoint of a
			         * numeric entity.
			         */
			        this.result = 0;
			        /** The current index in the decode tree. */
			        this.treeIndex = 0;
			        /** The number of characters that were consumed in excess. */
			        this.excess = 1;
			        /** The mode in which the decoder is operating. */
			        this.decodeMode = DecodingMode.Strict;
			    }
			    /** Resets the instance to make it reusable. */
			    startEntity(decodeMode) {
			        this.decodeMode = decodeMode;
			        this.state = EntityDecoderState.EntityStart;
			        this.result = 0;
			        this.treeIndex = 0;
			        this.excess = 1;
			        this.consumed = 1;
			    }
			    /**
			     * Write an entity to the decoder. This can be called multiple times with partial entities.
			     * If the entity is incomplete, the decoder will return -1.
			     *
			     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
			     * entity is incomplete, and resume when the next string is written.
			     *
			     * @param input The string containing the entity (or a continuation of the entity).
			     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    write(input, offset) {
			        switch (this.state) {
			            case EntityDecoderState.EntityStart: {
			                if (input.charCodeAt(offset) === CharCodes.NUM) {
			                    this.state = EntityDecoderState.NumericStart;
			                    this.consumed += 1;
			                    return this.stateNumericStart(input, offset + 1);
			                }
			                this.state = EntityDecoderState.NamedEntity;
			                return this.stateNamedEntity(input, offset);
			            }
			            case EntityDecoderState.NumericStart: {
			                return this.stateNumericStart(input, offset);
			            }
			            case EntityDecoderState.NumericDecimal: {
			                return this.stateNumericDecimal(input, offset);
			            }
			            case EntityDecoderState.NumericHex: {
			                return this.stateNumericHex(input, offset);
			            }
			            case EntityDecoderState.NamedEntity: {
			                return this.stateNamedEntity(input, offset);
			            }
			        }
			    }
			    /**
			     * Switches between the numeric decimal and hexadecimal states.
			     *
			     * Equivalent to the `Numeric character reference state` in the HTML spec.
			     *
			     * @param input The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    stateNumericStart(input, offset) {
			        if (offset >= input.length) {
			            return -1;
			        }
			        if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
			            this.state = EntityDecoderState.NumericHex;
			            this.consumed += 1;
			            return this.stateNumericHex(input, offset + 1);
			        }
			        this.state = EntityDecoderState.NumericDecimal;
			        return this.stateNumericDecimal(input, offset);
			    }
			    addToNumericResult(input, start, end, base) {
			        if (start !== end) {
			            const digitCount = end - start;
			            this.result =
			                this.result * Math.pow(base, digitCount) +
			                    Number.parseInt(input.substr(start, digitCount), base);
			            this.consumed += digitCount;
			        }
			    }
			    /**
			     * Parses a hexadecimal numeric entity.
			     *
			     * Equivalent to the `Hexademical character reference state` in the HTML spec.
			     *
			     * @param input The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    stateNumericHex(input, offset) {
			        const startIndex = offset;
			        while (offset < input.length) {
			            const char = input.charCodeAt(offset);
			            if (isNumber(char) || isHexadecimalCharacter(char)) {
			                offset += 1;
			            }
			            else {
			                this.addToNumericResult(input, startIndex, offset, 16);
			                return this.emitNumericEntity(char, 3);
			            }
			        }
			        this.addToNumericResult(input, startIndex, offset, 16);
			        return -1;
			    }
			    /**
			     * Parses a decimal numeric entity.
			     *
			     * Equivalent to the `Decimal character reference state` in the HTML spec.
			     *
			     * @param input The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    stateNumericDecimal(input, offset) {
			        const startIndex = offset;
			        while (offset < input.length) {
			            const char = input.charCodeAt(offset);
			            if (isNumber(char)) {
			                offset += 1;
			            }
			            else {
			                this.addToNumericResult(input, startIndex, offset, 10);
			                return this.emitNumericEntity(char, 2);
			            }
			        }
			        this.addToNumericResult(input, startIndex, offset, 10);
			        return -1;
			    }
			    /**
			     * Validate and emit a numeric entity.
			     *
			     * Implements the logic from the `Hexademical character reference start
			     * state` and `Numeric character reference end state` in the HTML spec.
			     *
			     * @param lastCp The last code point of the entity. Used to see if the
			     *               entity was terminated with a semicolon.
			     * @param expectedLength The minimum number of characters that should be
			     *                       consumed. Used to validate that at least one digit
			     *                       was consumed.
			     * @returns The number of characters that were consumed.
			     */
			    emitNumericEntity(lastCp, expectedLength) {
			        var _a;
			        // Ensure we consumed at least one digit.
			        if (this.consumed <= expectedLength) {
			            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
			            return 0;
			        }
			        // Figure out if this is a legit end of the entity
			        if (lastCp === CharCodes.SEMI) {
			            this.consumed += 1;
			        }
			        else if (this.decodeMode === DecodingMode.Strict) {
			            return 0;
			        }
			        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
			        if (this.errors) {
			            if (lastCp !== CharCodes.SEMI) {
			                this.errors.missingSemicolonAfterCharacterReference();
			            }
			            this.errors.validateNumericCharacterReference(this.result);
			        }
			        return this.consumed;
			    }
			    /**
			     * Parses a named entity.
			     *
			     * Equivalent to the `Named character reference state` in the HTML spec.
			     *
			     * @param input The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    stateNamedEntity(input, offset) {
			        const { decodeTree } = this;
			        let current = decodeTree[this.treeIndex];
			        // The mask is the number of bytes of the value, including the current byte.
			        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			        for (; offset < input.length; offset++, this.excess++) {
			            const char = input.charCodeAt(offset);
			            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			            if (this.treeIndex < 0) {
			                return this.result === 0 ||
			                    // If we are parsing an attribute
			                    (this.decodeMode === DecodingMode.Attribute &&
			                        // We shouldn't have consumed any characters after the entity,
			                        (valueLength === 0 ||
			                            // And there should be no invalid characters.
			                            isEntityInAttributeInvalidEnd(char)))
			                    ? 0
			                    : this.emitNotTerminatedNamedEntity();
			            }
			            current = decodeTree[this.treeIndex];
			            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			            // If the branch is a value, store it and continue
			            if (valueLength !== 0) {
			                // If the entity is terminated by a semicolon, we are done.
			                if (char === CharCodes.SEMI) {
			                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
			                }
			                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
			                if (this.decodeMode !== DecodingMode.Strict) {
			                    this.result = this.treeIndex;
			                    this.consumed += this.excess;
			                    this.excess = 0;
			                }
			            }
			        }
			        return -1;
			    }
			    /**
			     * Emit a named entity that was not terminated with a semicolon.
			     *
			     * @returns The number of characters consumed.
			     */
			    emitNotTerminatedNamedEntity() {
			        var _a;
			        const { result, decodeTree } = this;
			        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
			        this.emitNamedEntityData(result, valueLength, this.consumed);
			        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
			        return this.consumed;
			    }
			    /**
			     * Emit a named entity.
			     *
			     * @param result The index of the entity in the decode tree.
			     * @param valueLength The number of bytes in the entity.
			     * @param consumed The number of characters consumed.
			     *
			     * @returns The number of characters consumed.
			     */
			    emitNamedEntityData(result, valueLength, consumed) {
			        const { decodeTree } = this;
			        this.emitCodePoint(valueLength === 1
			            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
			            : decodeTree[result + 1], consumed);
			        if (valueLength === 3) {
			            // For multi-byte values, we need to emit the second byte.
			            this.emitCodePoint(decodeTree[result + 2], consumed);
			        }
			        return consumed;
			    }
			    /**
			     * Signal to the parser that the end of the input was reached.
			     *
			     * Remaining data will be emitted and relevant errors will be produced.
			     *
			     * @returns The number of characters consumed.
			     */
			    end() {
			        var _a;
			        switch (this.state) {
			            case EntityDecoderState.NamedEntity: {
			                // Emit a named entity if we have one.
			                return this.result !== 0 &&
			                    (this.decodeMode !== DecodingMode.Attribute ||
			                        this.result === this.treeIndex)
			                    ? this.emitNotTerminatedNamedEntity()
			                    : 0;
			            }
			            // Otherwise, emit a numeric entity if we have one.
			            case EntityDecoderState.NumericDecimal: {
			                return this.emitNumericEntity(0, 2);
			            }
			            case EntityDecoderState.NumericHex: {
			                return this.emitNumericEntity(0, 3);
			            }
			            case EntityDecoderState.NumericStart: {
			                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
			                return 0;
			            }
			            case EntityDecoderState.EntityStart: {
			                // Return 0 if we have no entity.
			                return 0;
			            }
			        }
			    }
			}
			exports.EntityDecoder = EntityDecoder;
			/**
			 * Creates a function that decodes entities in a string.
			 *
			 * @param decodeTree The decode tree.
			 * @returns A function that decodes entities in a string.
			 */
			function getDecoder(decodeTree) {
			    let returnValue = "";
			    const decoder = new EntityDecoder(decodeTree, (data) => (returnValue += (0, decode_codepoint_js_1.fromCodePoint)(data)));
			    return function decodeWithTrie(input, decodeMode) {
			        let lastIndex = 0;
			        let offset = 0;
			        while ((offset = input.indexOf("&", offset)) >= 0) {
			            returnValue += input.slice(lastIndex, offset);
			            decoder.startEntity(decodeMode);
			            const length = decoder.write(input, 
			            // Skip the "&"
			            offset + 1);
			            if (length < 0) {
			                lastIndex = offset + decoder.end();
			                break;
			            }
			            lastIndex = offset + length;
			            // If `length` is 0, skip the current `&` and continue.
			            offset = length === 0 ? lastIndex + 1 : lastIndex;
			        }
			        const result = returnValue + input.slice(lastIndex);
			        // Make sure we don't keep a reference to the final string.
			        returnValue = "";
			        return result;
			    };
			}
			/**
			 * Determines the branch of the current node that is taken given the current
			 * character. This function is used to traverse the trie.
			 *
			 * @param decodeTree The trie.
			 * @param current The current node.
			 * @param nodeIdx The index right after the current node and its value.
			 * @param char The current character.
			 * @returns The index of the next node, or -1 if no branch is taken.
			 */
			function determineBranch(decodeTree, current, nodeIndex, char) {
			    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
			    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
			    // Case 1: Single branch encoded in jump offset
			    if (branchCount === 0) {
			        return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
			    }
			    // Case 2: Multiple branches encoded in jump table
			    if (jumpOffset) {
			        const value = char - jumpOffset;
			        return value < 0 || value >= branchCount
			            ? -1
			            : decodeTree[nodeIndex + value] - 1;
			    }
			    // Case 3: Multiple branches encoded in dictionary
			    // Binary search for the character.
			    let lo = nodeIndex;
			    let hi = lo + branchCount - 1;
			    while (lo <= hi) {
			        const mid = (lo + hi) >>> 1;
			        const midValue = decodeTree[mid];
			        if (midValue < char) {
			            lo = mid + 1;
			        }
			        else if (midValue > char) {
			            hi = mid - 1;
			        }
			        else {
			            return decodeTree[mid + branchCount];
			        }
			    }
			    return -1;
			}
			const htmlDecoder = /* #__PURE__ */ getDecoder(decode_data_html_js_1.htmlDecodeTree);
			const xmlDecoder = /* #__PURE__ */ getDecoder(decode_data_xml_js_1.xmlDecodeTree);
			/**
			 * Decodes an HTML string.
			 *
			 * @param htmlString The string to decode.
			 * @param mode The decoding mode.
			 * @returns The decoded string.
			 */
			function decodeHTML(htmlString, mode = DecodingMode.Legacy) {
			    return htmlDecoder(htmlString, mode);
			}
			/**
			 * Decodes an HTML string in an attribute.
			 *
			 * @param htmlAttribute The string to decode.
			 * @returns The decoded string.
			 */
			function decodeHTMLAttribute(htmlAttribute) {
			    return htmlDecoder(htmlAttribute, DecodingMode.Attribute);
			}
			/**
			 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
			 *
			 * @param htmlString The string to decode.
			 * @returns The decoded string.
			 */
			function decodeHTMLStrict(htmlString) {
			    return htmlDecoder(htmlString, DecodingMode.Strict);
			}
			/**
			 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
			 *
			 * @param xmlString The string to decode.
			 * @returns The decoded string.
			 */
			function decodeXML(xmlString) {
			    return xmlDecoder(xmlString, DecodingMode.Strict);
			}
			// Re-export for use by eg. htmlparser2
			var decode_data_html_js_2 = requireDecodeDataHtml$1();
			Object.defineProperty(exports, "htmlDecodeTree", { enumerable: true, get: function () { return decode_data_html_js_2.htmlDecodeTree; } });
			var decode_data_xml_js_2 = requireDecodeDataXml$1();
			Object.defineProperty(exports, "xmlDecodeTree", { enumerable: true, get: function () { return decode_data_xml_js_2.xmlDecodeTree; } });
			var decode_codepoint_js_2 = requireDecodeCodepoint();
			Object.defineProperty(exports, "decodeCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.decodeCodePoint; } });
			Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });
			Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });
			
		} (decode$1));
		return decode$1;
	}

	var hasRequiredTokenizer;

	function requireTokenizer () {
		if (hasRequiredTokenizer) return Tokenizer;
		hasRequiredTokenizer = 1;
		Object.defineProperty(Tokenizer, "__esModule", { value: true });
		Tokenizer.QuoteType = void 0;
		const decode_1 = /*@__PURE__*/ requireDecode$1();
		var CharCodes;
		(function (CharCodes) {
		    CharCodes[CharCodes["Tab"] = 9] = "Tab";
		    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
		    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
		    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
		    CharCodes[CharCodes["Space"] = 32] = "Space";
		    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
		    CharCodes[CharCodes["Number"] = 35] = "Number";
		    CharCodes[CharCodes["Amp"] = 38] = "Amp";
		    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
		    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
		    CharCodes[CharCodes["Dash"] = 45] = "Dash";
		    CharCodes[CharCodes["Slash"] = 47] = "Slash";
		    CharCodes[CharCodes["Zero"] = 48] = "Zero";
		    CharCodes[CharCodes["Nine"] = 57] = "Nine";
		    CharCodes[CharCodes["Semi"] = 59] = "Semi";
		    CharCodes[CharCodes["Lt"] = 60] = "Lt";
		    CharCodes[CharCodes["Eq"] = 61] = "Eq";
		    CharCodes[CharCodes["Gt"] = 62] = "Gt";
		    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
		    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
		    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
		    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
		    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
		    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
		    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
		    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
		    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
		})(CharCodes || (CharCodes = {}));
		/** All the states the tokenizer can be in. */
		var State;
		(function (State) {
		    State[State["Text"] = 1] = "Text";
		    State[State["BeforeTagName"] = 2] = "BeforeTagName";
		    State[State["InTagName"] = 3] = "InTagName";
		    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
		    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
		    State[State["InClosingTagName"] = 6] = "InClosingTagName";
		    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
		    // Attributes
		    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
		    State[State["InAttributeName"] = 9] = "InAttributeName";
		    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
		    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
		    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
		    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
		    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
		    // Declarations
		    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
		    State[State["InDeclaration"] = 16] = "InDeclaration";
		    // Processing instructions
		    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
		    // Comments & CDATA
		    State[State["BeforeComment"] = 18] = "BeforeComment";
		    State[State["CDATASequence"] = 19] = "CDATASequence";
		    State[State["InSpecialComment"] = 20] = "InSpecialComment";
		    State[State["InCommentLike"] = 21] = "InCommentLike";
		    // Special tags
		    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
		    State[State["BeforeSpecialT"] = 23] = "BeforeSpecialT";
		    State[State["SpecialStartSequence"] = 24] = "SpecialStartSequence";
		    State[State["InSpecialTag"] = 25] = "InSpecialTag";
		    State[State["InEntity"] = 26] = "InEntity";
		})(State || (State = {}));
		function isWhitespace(c) {
		    return (c === CharCodes.Space ||
		        c === CharCodes.NewLine ||
		        c === CharCodes.Tab ||
		        c === CharCodes.FormFeed ||
		        c === CharCodes.CarriageReturn);
		}
		function isEndOfTagSection(c) {
		    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
		}
		function isASCIIAlpha(c) {
		    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
		        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
		}
		var QuoteType;
		(function (QuoteType) {
		    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
		    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
		    QuoteType[QuoteType["Single"] = 2] = "Single";
		    QuoteType[QuoteType["Double"] = 3] = "Double";
		})(QuoteType || (Tokenizer.QuoteType = QuoteType = {}));
		/**
		 * Sequences used to match longer strings.
		 *
		 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
		 * sequences with an increased offset.
		 */
		const Sequences = {
		    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[
		    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>
		    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`
		    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`
		    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`
		    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
		    TextareaEnd: new Uint8Array([
		        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,
		    ]), // `</textarea`
		    XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`
		};
		let Tokenizer$1 = class Tokenizer {
		    constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
		        this.cbs = cbs;
		        /** The current state the tokenizer is in. */
		        this.state = State.Text;
		        /** The read buffer. */
		        this.buffer = "";
		        /** The beginning of the section that is currently being read. */
		        this.sectionStart = 0;
		        /** The index within the buffer that we are currently looking at. */
		        this.index = 0;
		        /** The start of the last entity. */
		        this.entityStart = 0;
		        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
		        this.baseState = State.Text;
		        /** For special parsing behavior inside of script and style tags. */
		        this.isSpecial = false;
		        /** Indicates whether the tokenizer has been paused. */
		        this.running = true;
		        /** The offset of the current buffer. */
		        this.offset = 0;
		        this.currentSequence = undefined;
		        this.sequenceIndex = 0;
		        this.xmlMode = xmlMode;
		        this.decodeEntities = decodeEntities;
		        this.entityDecoder = new decode_1.EntityDecoder(xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
		    }
		    reset() {
		        this.state = State.Text;
		        this.buffer = "";
		        this.sectionStart = 0;
		        this.index = 0;
		        this.baseState = State.Text;
		        this.currentSequence = undefined;
		        this.running = true;
		        this.offset = 0;
		    }
		    write(chunk) {
		        this.offset += this.buffer.length;
		        this.buffer = chunk;
		        this.parse();
		    }
		    end() {
		        if (this.running)
		            this.finish();
		    }
		    pause() {
		        this.running = false;
		    }
		    resume() {
		        this.running = true;
		        if (this.index < this.buffer.length + this.offset) {
		            this.parse();
		        }
		    }
		    stateText(c) {
		        if (c === CharCodes.Lt ||
		            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
		            if (this.index > this.sectionStart) {
		                this.cbs.ontext(this.sectionStart, this.index);
		            }
		            this.state = State.BeforeTagName;
		            this.sectionStart = this.index;
		        }
		        else if (this.decodeEntities && c === CharCodes.Amp) {
		            this.startEntity();
		        }
		    }
		    stateSpecialStartSequence(c) {
		        const isEnd = this.sequenceIndex === this.currentSequence.length;
		        const isMatch = isEnd
		            ? // If we are at the end of the sequence, make sure the tag name has ended
		                isEndOfTagSection(c)
		            : // Otherwise, do a case-insensitive comparison
		                (c | 0x20) === this.currentSequence[this.sequenceIndex];
		        if (!isMatch) {
		            this.isSpecial = false;
		        }
		        else if (!isEnd) {
		            this.sequenceIndex++;
		            return;
		        }
		        this.sequenceIndex = 0;
		        this.state = State.InTagName;
		        this.stateInTagName(c);
		    }
		    /** Look for an end tag. For <title> tags, also decode entities. */
		    stateInSpecialTag(c) {
		        if (this.sequenceIndex === this.currentSequence.length) {
		            if (c === CharCodes.Gt || isWhitespace(c)) {
		                const endOfText = this.index - this.currentSequence.length;
		                if (this.sectionStart < endOfText) {
		                    // Spoof the index so that reported locations match up.
		                    const actualIndex = this.index;
		                    this.index = endOfText;
		                    this.cbs.ontext(this.sectionStart, endOfText);
		                    this.index = actualIndex;
		                }
		                this.isSpecial = false;
		                this.sectionStart = endOfText + 2; // Skip over the `</`
		                this.stateInClosingTagName(c);
		                return; // We are done; skip the rest of the function.
		            }
		            this.sequenceIndex = 0;
		        }
		        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
		            this.sequenceIndex += 1;
		        }
		        else if (this.sequenceIndex === 0) {
		            if (this.currentSequence === Sequences.TitleEnd) {
		                // We have to parse entities in <title> tags.
		                if (this.decodeEntities && c === CharCodes.Amp) {
		                    this.startEntity();
		                }
		            }
		            else if (this.fastForwardTo(CharCodes.Lt)) {
		                // Outside of <title> tags, we can fast-forward.
		                this.sequenceIndex = 1;
		            }
		        }
		        else {
		            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
		            this.sequenceIndex = Number(c === CharCodes.Lt);
		        }
		    }
		    stateCDATASequence(c) {
		        if (c === Sequences.Cdata[this.sequenceIndex]) {
		            if (++this.sequenceIndex === Sequences.Cdata.length) {
		                this.state = State.InCommentLike;
		                this.currentSequence = Sequences.CdataEnd;
		                this.sequenceIndex = 0;
		                this.sectionStart = this.index + 1;
		            }
		        }
		        else {
		            this.sequenceIndex = 0;
		            this.state = State.InDeclaration;
		            this.stateInDeclaration(c); // Reconsume the character
		        }
		    }
		    /**
		     * When we wait for one specific character, we can speed things up
		     * by skipping through the buffer until we find it.
		     *
		     * @returns Whether the character was found.
		     */
		    fastForwardTo(c) {
		        while (++this.index < this.buffer.length + this.offset) {
		            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
		                return true;
		            }
		        }
		        /*
		         * We increment the index at the end of the `parse` loop,
		         * so set it to `buffer.length - 1` here.
		         *
		         * TODO: Refactor `parse` to increment index before calling states.
		         */
		        this.index = this.buffer.length + this.offset - 1;
		        return false;
		    }
		    /**
		     * Comments and CDATA end with `-->` and `]]>`.
		     *
		     * Their common qualities are:
		     * - Their end sequences have a distinct character they start with.
		     * - That character is then repeated, so we have to check multiple repeats.
		     * - All characters but the start character of the sequence can be skipped.
		     */
		    stateInCommentLike(c) {
		        if (c === this.currentSequence[this.sequenceIndex]) {
		            if (++this.sequenceIndex === this.currentSequence.length) {
		                if (this.currentSequence === Sequences.CdataEnd) {
		                    this.cbs.oncdata(this.sectionStart, this.index, 2);
		                }
		                else {
		                    this.cbs.oncomment(this.sectionStart, this.index, 2);
		                }
		                this.sequenceIndex = 0;
		                this.sectionStart = this.index + 1;
		                this.state = State.Text;
		            }
		        }
		        else if (this.sequenceIndex === 0) {
		            // Fast-forward to the first character of the sequence
		            if (this.fastForwardTo(this.currentSequence[0])) {
		                this.sequenceIndex = 1;
		            }
		        }
		        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
		            // Allow long sequences, eg. --->, ]]]>
		            this.sequenceIndex = 0;
		        }
		    }
		    /**
		     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
		     *
		     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
		     * We allow anything that wouldn't end the tag.
		     */
		    isTagStartChar(c) {
		        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
		    }
		    startSpecial(sequence, offset) {
		        this.isSpecial = true;
		        this.currentSequence = sequence;
		        this.sequenceIndex = offset;
		        this.state = State.SpecialStartSequence;
		    }
		    stateBeforeTagName(c) {
		        if (c === CharCodes.ExclamationMark) {
		            this.state = State.BeforeDeclaration;
		            this.sectionStart = this.index + 1;
		        }
		        else if (c === CharCodes.Questionmark) {
		            this.state = State.InProcessingInstruction;
		            this.sectionStart = this.index + 1;
		        }
		        else if (this.isTagStartChar(c)) {
		            const lower = c | 0x20;
		            this.sectionStart = this.index;
		            if (this.xmlMode) {
		                this.state = State.InTagName;
		            }
		            else if (lower === Sequences.ScriptEnd[2]) {
		                this.state = State.BeforeSpecialS;
		            }
		            else if (lower === Sequences.TitleEnd[2] ||
		                lower === Sequences.XmpEnd[2]) {
		                this.state = State.BeforeSpecialT;
		            }
		            else {
		                this.state = State.InTagName;
		            }
		        }
		        else if (c === CharCodes.Slash) {
		            this.state = State.BeforeClosingTagName;
		        }
		        else {
		            this.state = State.Text;
		            this.stateText(c);
		        }
		    }
		    stateInTagName(c) {
		        if (isEndOfTagSection(c)) {
		            this.cbs.onopentagname(this.sectionStart, this.index);
		            this.sectionStart = -1;
		            this.state = State.BeforeAttributeName;
		            this.stateBeforeAttributeName(c);
		        }
		    }
		    stateBeforeClosingTagName(c) {
		        if (isWhitespace(c)) ;
		        else if (c === CharCodes.Gt) {
		            this.state = State.Text;
		        }
		        else {
		            this.state = this.isTagStartChar(c)
		                ? State.InClosingTagName
		                : State.InSpecialComment;
		            this.sectionStart = this.index;
		        }
		    }
		    stateInClosingTagName(c) {
		        if (c === CharCodes.Gt || isWhitespace(c)) {
		            this.cbs.onclosetag(this.sectionStart, this.index);
		            this.sectionStart = -1;
		            this.state = State.AfterClosingTagName;
		            this.stateAfterClosingTagName(c);
		        }
		    }
		    stateAfterClosingTagName(c) {
		        // Skip everything until ">"
		        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
		            this.state = State.Text;
		            this.sectionStart = this.index + 1;
		        }
		    }
		    stateBeforeAttributeName(c) {
		        if (c === CharCodes.Gt) {
		            this.cbs.onopentagend(this.index);
		            if (this.isSpecial) {
		                this.state = State.InSpecialTag;
		                this.sequenceIndex = 0;
		            }
		            else {
		                this.state = State.Text;
		            }
		            this.sectionStart = this.index + 1;
		        }
		        else if (c === CharCodes.Slash) {
		            this.state = State.InSelfClosingTag;
		        }
		        else if (!isWhitespace(c)) {
		            this.state = State.InAttributeName;
		            this.sectionStart = this.index;
		        }
		    }
		    stateInSelfClosingTag(c) {
		        if (c === CharCodes.Gt) {
		            this.cbs.onselfclosingtag(this.index);
		            this.state = State.Text;
		            this.sectionStart = this.index + 1;
		            this.isSpecial = false; // Reset special state, in case of self-closing special tags
		        }
		        else if (!isWhitespace(c)) {
		            this.state = State.BeforeAttributeName;
		            this.stateBeforeAttributeName(c);
		        }
		    }
		    stateInAttributeName(c) {
		        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
		            this.cbs.onattribname(this.sectionStart, this.index);
		            this.sectionStart = this.index;
		            this.state = State.AfterAttributeName;
		            this.stateAfterAttributeName(c);
		        }
		    }
		    stateAfterAttributeName(c) {
		        if (c === CharCodes.Eq) {
		            this.state = State.BeforeAttributeValue;
		        }
		        else if (c === CharCodes.Slash || c === CharCodes.Gt) {
		            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
		            this.sectionStart = -1;
		            this.state = State.BeforeAttributeName;
		            this.stateBeforeAttributeName(c);
		        }
		        else if (!isWhitespace(c)) {
		            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
		            this.state = State.InAttributeName;
		            this.sectionStart = this.index;
		        }
		    }
		    stateBeforeAttributeValue(c) {
		        if (c === CharCodes.DoubleQuote) {
		            this.state = State.InAttributeValueDq;
		            this.sectionStart = this.index + 1;
		        }
		        else if (c === CharCodes.SingleQuote) {
		            this.state = State.InAttributeValueSq;
		            this.sectionStart = this.index + 1;
		        }
		        else if (!isWhitespace(c)) {
		            this.sectionStart = this.index;
		            this.state = State.InAttributeValueNq;
		            this.stateInAttributeValueNoQuotes(c); // Reconsume token
		        }
		    }
		    handleInAttributeValue(c, quote) {
		        if (c === quote ||
		            (!this.decodeEntities && this.fastForwardTo(quote))) {
		            this.cbs.onattribdata(this.sectionStart, this.index);
		            this.sectionStart = -1;
		            this.cbs.onattribend(quote === CharCodes.DoubleQuote
		                ? QuoteType.Double
		                : QuoteType.Single, this.index + 1);
		            this.state = State.BeforeAttributeName;
		        }
		        else if (this.decodeEntities && c === CharCodes.Amp) {
		            this.startEntity();
		        }
		    }
		    stateInAttributeValueDoubleQuotes(c) {
		        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
		    }
		    stateInAttributeValueSingleQuotes(c) {
		        this.handleInAttributeValue(c, CharCodes.SingleQuote);
		    }
		    stateInAttributeValueNoQuotes(c) {
		        if (isWhitespace(c) || c === CharCodes.Gt) {
		            this.cbs.onattribdata(this.sectionStart, this.index);
		            this.sectionStart = -1;
		            this.cbs.onattribend(QuoteType.Unquoted, this.index);
		            this.state = State.BeforeAttributeName;
		            this.stateBeforeAttributeName(c);
		        }
		        else if (this.decodeEntities && c === CharCodes.Amp) {
		            this.startEntity();
		        }
		    }
		    stateBeforeDeclaration(c) {
		        if (c === CharCodes.OpeningSquareBracket) {
		            this.state = State.CDATASequence;
		            this.sequenceIndex = 0;
		        }
		        else {
		            this.state =
		                c === CharCodes.Dash
		                    ? State.BeforeComment
		                    : State.InDeclaration;
		        }
		    }
		    stateInDeclaration(c) {
		        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
		            this.cbs.ondeclaration(this.sectionStart, this.index);
		            this.state = State.Text;
		            this.sectionStart = this.index + 1;
		        }
		    }
		    stateInProcessingInstruction(c) {
		        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
		            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
		            this.state = State.Text;
		            this.sectionStart = this.index + 1;
		        }
		    }
		    stateBeforeComment(c) {
		        if (c === CharCodes.Dash) {
		            this.state = State.InCommentLike;
		            this.currentSequence = Sequences.CommentEnd;
		            // Allow short comments (eg. <!-->)
		            this.sequenceIndex = 2;
		            this.sectionStart = this.index + 1;
		        }
		        else {
		            this.state = State.InDeclaration;
		        }
		    }
		    stateInSpecialComment(c) {
		        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
		            this.cbs.oncomment(this.sectionStart, this.index, 0);
		            this.state = State.Text;
		            this.sectionStart = this.index + 1;
		        }
		    }
		    stateBeforeSpecialS(c) {
		        const lower = c | 0x20;
		        if (lower === Sequences.ScriptEnd[3]) {
		            this.startSpecial(Sequences.ScriptEnd, 4);
		        }
		        else if (lower === Sequences.StyleEnd[3]) {
		            this.startSpecial(Sequences.StyleEnd, 4);
		        }
		        else {
		            this.state = State.InTagName;
		            this.stateInTagName(c); // Consume the token again
		        }
		    }
		    stateBeforeSpecialT(c) {
		        const lower = c | 0x20;
		        switch (lower) {
		            case Sequences.TitleEnd[3]: {
		                this.startSpecial(Sequences.TitleEnd, 4);
		                break;
		            }
		            case Sequences.TextareaEnd[3]: {
		                this.startSpecial(Sequences.TextareaEnd, 4);
		                break;
		            }
		            case Sequences.XmpEnd[3]: {
		                this.startSpecial(Sequences.XmpEnd, 4);
		                break;
		            }
		            default: {
		                this.state = State.InTagName;
		                this.stateInTagName(c); // Consume the token again
		            }
		        }
		    }
		    startEntity() {
		        this.baseState = this.state;
		        this.state = State.InEntity;
		        this.entityStart = this.index;
		        this.entityDecoder.startEntity(this.xmlMode
		            ? decode_1.DecodingMode.Strict
		            : this.baseState === State.Text ||
		                this.baseState === State.InSpecialTag
		                ? decode_1.DecodingMode.Legacy
		                : decode_1.DecodingMode.Attribute);
		    }
		    stateInEntity() {
		        const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
		        // If `length` is positive, we are done with the entity.
		        if (length >= 0) {
		            this.state = this.baseState;
		            if (length === 0) {
		                this.index = this.entityStart;
		            }
		        }
		        else {
		            // Mark buffer as consumed.
		            this.index = this.offset + this.buffer.length - 1;
		        }
		    }
		    /**
		     * Remove data that has already been consumed from the buffer.
		     */
		    cleanup() {
		        // If we are inside of text or attributes, emit what we already have.
		        if (this.running && this.sectionStart !== this.index) {
		            if (this.state === State.Text ||
		                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
		                this.cbs.ontext(this.sectionStart, this.index);
		                this.sectionStart = this.index;
		            }
		            else if (this.state === State.InAttributeValueDq ||
		                this.state === State.InAttributeValueSq ||
		                this.state === State.InAttributeValueNq) {
		                this.cbs.onattribdata(this.sectionStart, this.index);
		                this.sectionStart = this.index;
		            }
		        }
		    }
		    shouldContinue() {
		        return this.index < this.buffer.length + this.offset && this.running;
		    }
		    /**
		     * Iterates through the buffer, calling the function corresponding to the current state.
		     *
		     * States that are more likely to be hit are higher up, as a performance improvement.
		     */
		    parse() {
		        while (this.shouldContinue()) {
		            const c = this.buffer.charCodeAt(this.index - this.offset);
		            switch (this.state) {
		                case State.Text: {
		                    this.stateText(c);
		                    break;
		                }
		                case State.SpecialStartSequence: {
		                    this.stateSpecialStartSequence(c);
		                    break;
		                }
		                case State.InSpecialTag: {
		                    this.stateInSpecialTag(c);
		                    break;
		                }
		                case State.CDATASequence: {
		                    this.stateCDATASequence(c);
		                    break;
		                }
		                case State.InAttributeValueDq: {
		                    this.stateInAttributeValueDoubleQuotes(c);
		                    break;
		                }
		                case State.InAttributeName: {
		                    this.stateInAttributeName(c);
		                    break;
		                }
		                case State.InCommentLike: {
		                    this.stateInCommentLike(c);
		                    break;
		                }
		                case State.InSpecialComment: {
		                    this.stateInSpecialComment(c);
		                    break;
		                }
		                case State.BeforeAttributeName: {
		                    this.stateBeforeAttributeName(c);
		                    break;
		                }
		                case State.InTagName: {
		                    this.stateInTagName(c);
		                    break;
		                }
		                case State.InClosingTagName: {
		                    this.stateInClosingTagName(c);
		                    break;
		                }
		                case State.BeforeTagName: {
		                    this.stateBeforeTagName(c);
		                    break;
		                }
		                case State.AfterAttributeName: {
		                    this.stateAfterAttributeName(c);
		                    break;
		                }
		                case State.InAttributeValueSq: {
		                    this.stateInAttributeValueSingleQuotes(c);
		                    break;
		                }
		                case State.BeforeAttributeValue: {
		                    this.stateBeforeAttributeValue(c);
		                    break;
		                }
		                case State.BeforeClosingTagName: {
		                    this.stateBeforeClosingTagName(c);
		                    break;
		                }
		                case State.AfterClosingTagName: {
		                    this.stateAfterClosingTagName(c);
		                    break;
		                }
		                case State.BeforeSpecialS: {
		                    this.stateBeforeSpecialS(c);
		                    break;
		                }
		                case State.BeforeSpecialT: {
		                    this.stateBeforeSpecialT(c);
		                    break;
		                }
		                case State.InAttributeValueNq: {
		                    this.stateInAttributeValueNoQuotes(c);
		                    break;
		                }
		                case State.InSelfClosingTag: {
		                    this.stateInSelfClosingTag(c);
		                    break;
		                }
		                case State.InDeclaration: {
		                    this.stateInDeclaration(c);
		                    break;
		                }
		                case State.BeforeDeclaration: {
		                    this.stateBeforeDeclaration(c);
		                    break;
		                }
		                case State.BeforeComment: {
		                    this.stateBeforeComment(c);
		                    break;
		                }
		                case State.InProcessingInstruction: {
		                    this.stateInProcessingInstruction(c);
		                    break;
		                }
		                case State.InEntity: {
		                    this.stateInEntity();
		                    break;
		                }
		            }
		            this.index++;
		        }
		        this.cleanup();
		    }
		    finish() {
		        if (this.state === State.InEntity) {
		            this.entityDecoder.end();
		            this.state = this.baseState;
		        }
		        this.handleTrailingData();
		        this.cbs.onend();
		    }
		    /** Handle any trailing data. */
		    handleTrailingData() {
		        const endIndex = this.buffer.length + this.offset;
		        // If there is no remaining data, we are done.
		        if (this.sectionStart >= endIndex) {
		            return;
		        }
		        if (this.state === State.InCommentLike) {
		            if (this.currentSequence === Sequences.CdataEnd) {
		                this.cbs.oncdata(this.sectionStart, endIndex, 0);
		            }
		            else {
		                this.cbs.oncomment(this.sectionStart, endIndex, 0);
		            }
		        }
		        else if (this.state === State.InTagName ||
		            this.state === State.BeforeAttributeName ||
		            this.state === State.BeforeAttributeValue ||
		            this.state === State.AfterAttributeName ||
		            this.state === State.InAttributeName ||
		            this.state === State.InAttributeValueSq ||
		            this.state === State.InAttributeValueDq ||
		            this.state === State.InAttributeValueNq ||
		            this.state === State.InClosingTagName) ;
		        else {
		            this.cbs.ontext(this.sectionStart, endIndex);
		        }
		    }
		    emitCodePoint(cp, consumed) {
		        if (this.baseState !== State.Text &&
		            this.baseState !== State.InSpecialTag) {
		            if (this.sectionStart < this.entityStart) {
		                this.cbs.onattribdata(this.sectionStart, this.entityStart);
		            }
		            this.sectionStart = this.entityStart + consumed;
		            this.index = this.sectionStart - 1;
		            this.cbs.onattribentity(cp);
		        }
		        else {
		            if (this.sectionStart < this.entityStart) {
		                this.cbs.ontext(this.sectionStart, this.entityStart);
		            }
		            this.sectionStart = this.entityStart + consumed;
		            this.index = this.sectionStart - 1;
		            this.cbs.ontextentity(cp, this.sectionStart);
		        }
		    }
		};
		Tokenizer.default = Tokenizer$1;
		
		return Tokenizer;
	}

	var hasRequiredParser;

	function requireParser () {
		if (hasRequiredParser) return Parser;
		hasRequiredParser = 1;
		var __createBinding = (Parser && Parser.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (Parser && Parser.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (Parser && Parser.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		Object.defineProperty(Parser, "__esModule", { value: true });
		Parser.Parser = void 0;
		const Tokenizer_js_1 = __importStar(requireTokenizer());
		const decode_1 = /*@__PURE__*/ requireDecode$1();
		const formTags = new Set([
		    "input",
		    "option",
		    "optgroup",
		    "select",
		    "button",
		    "datalist",
		    "textarea",
		]);
		const pTag = new Set(["p"]);
		const tableSectionTags = new Set(["thead", "tbody"]);
		const ddtTags = new Set(["dd", "dt"]);
		const rtpTags = new Set(["rt", "rp"]);
		const openImpliesClose = new Map([
		    ["tr", new Set(["tr", "th", "td"])],
		    ["th", new Set(["th"])],
		    ["td", new Set(["thead", "th", "td"])],
		    ["body", new Set(["head", "link", "script"])],
		    ["li", new Set(["li"])],
		    ["p", pTag],
		    ["h1", pTag],
		    ["h2", pTag],
		    ["h3", pTag],
		    ["h4", pTag],
		    ["h5", pTag],
		    ["h6", pTag],
		    ["select", formTags],
		    ["input", formTags],
		    ["output", formTags],
		    ["button", formTags],
		    ["datalist", formTags],
		    ["textarea", formTags],
		    ["option", new Set(["option"])],
		    ["optgroup", new Set(["optgroup", "option"])],
		    ["dd", ddtTags],
		    ["dt", ddtTags],
		    ["address", pTag],
		    ["article", pTag],
		    ["aside", pTag],
		    ["blockquote", pTag],
		    ["details", pTag],
		    ["div", pTag],
		    ["dl", pTag],
		    ["fieldset", pTag],
		    ["figcaption", pTag],
		    ["figure", pTag],
		    ["footer", pTag],
		    ["form", pTag],
		    ["header", pTag],
		    ["hr", pTag],
		    ["main", pTag],
		    ["nav", pTag],
		    ["ol", pTag],
		    ["pre", pTag],
		    ["section", pTag],
		    ["table", pTag],
		    ["ul", pTag],
		    ["rt", rtpTags],
		    ["rp", rtpTags],
		    ["tbody", tableSectionTags],
		    ["tfoot", tableSectionTags],
		]);
		const voidElements = new Set([
		    "area",
		    "base",
		    "basefont",
		    "br",
		    "col",
		    "command",
		    "embed",
		    "frame",
		    "hr",
		    "img",
		    "input",
		    "isindex",
		    "keygen",
		    "link",
		    "meta",
		    "param",
		    "source",
		    "track",
		    "wbr",
		]);
		const foreignContextElements = new Set(["math", "svg"]);
		const htmlIntegrationElements = new Set([
		    "mi",
		    "mo",
		    "mn",
		    "ms",
		    "mtext",
		    "annotation-xml",
		    "foreignobject",
		    "desc",
		    "title",
		]);
		const reNameEnd = /\s|\//;
		let Parser$1 = class Parser {
		    constructor(cbs, options = {}) {
		        var _a, _b, _c, _d, _e, _f;
		        this.options = options;
		        /** The start index of the last event. */
		        this.startIndex = 0;
		        /** The end index of the last event. */
		        this.endIndex = 0;
		        /**
		         * Store the start index of the current open tag,
		         * so we can update the start index for attributes.
		         */
		        this.openTagStart = 0;
		        this.tagname = "";
		        this.attribname = "";
		        this.attribvalue = "";
		        this.attribs = null;
		        this.stack = [];
		        this.buffers = [];
		        this.bufferOffset = 0;
		        /** The index of the last written buffer. Used when resuming after a `pause()`. */
		        this.writeIndex = 0;
		        /** Indicates whether the parser has finished running / `.end` has been called. */
		        this.ended = false;
		        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
		        this.htmlMode = !this.options.xmlMode;
		        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;
		        this.lowerCaseAttributeNames =
		            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
		        this.recognizeSelfClosing =
		            (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
		        this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer_js_1.default)(this.options, this);
		        this.foreignContext = [!this.htmlMode];
		        (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
		    }
		    // Tokenizer event handlers
		    /** @internal */
		    ontext(start, endIndex) {
		        var _a, _b;
		        const data = this.getSlice(start, endIndex);
		        this.endIndex = endIndex - 1;
		        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
		        this.startIndex = endIndex;
		    }
		    /** @internal */
		    ontextentity(cp, endIndex) {
		        var _a, _b;
		        this.endIndex = endIndex - 1;
		        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_1.fromCodePoint)(cp));
		        this.startIndex = endIndex;
		    }
		    /**
		     * Checks if the current tag is a void element. Override this if you want
		     * to specify your own additional void elements.
		     */
		    isVoidElement(name) {
		        return this.htmlMode && voidElements.has(name);
		    }
		    /** @internal */
		    onopentagname(start, endIndex) {
		        this.endIndex = endIndex;
		        let name = this.getSlice(start, endIndex);
		        if (this.lowerCaseTagNames) {
		            name = name.toLowerCase();
		        }
		        this.emitOpenTag(name);
		    }
		    emitOpenTag(name) {
		        var _a, _b, _c, _d;
		        this.openTagStart = this.startIndex;
		        this.tagname = name;
		        const impliesClose = this.htmlMode && openImpliesClose.get(name);
		        if (impliesClose) {
		            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
		                const element = this.stack.shift();
		                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
		            }
		        }
		        if (!this.isVoidElement(name)) {
		            this.stack.unshift(name);
		            if (this.htmlMode) {
		                if (foreignContextElements.has(name)) {
		                    this.foreignContext.unshift(true);
		                }
		                else if (htmlIntegrationElements.has(name)) {
		                    this.foreignContext.unshift(false);
		                }
		            }
		        }
		        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
		        if (this.cbs.onopentag)
		            this.attribs = {};
		    }
		    endOpenTag(isImplied) {
		        var _a, _b;
		        this.startIndex = this.openTagStart;
		        if (this.attribs) {
		            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
		            this.attribs = null;
		        }
		        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
		            this.cbs.onclosetag(this.tagname, true);
		        }
		        this.tagname = "";
		    }
		    /** @internal */
		    onopentagend(endIndex) {
		        this.endIndex = endIndex;
		        this.endOpenTag(false);
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    onclosetag(start, endIndex) {
		        var _a, _b, _c, _d, _e, _f, _g, _h;
		        this.endIndex = endIndex;
		        let name = this.getSlice(start, endIndex);
		        if (this.lowerCaseTagNames) {
		            name = name.toLowerCase();
		        }
		        if (this.htmlMode &&
		            (foreignContextElements.has(name) ||
		                htmlIntegrationElements.has(name))) {
		            this.foreignContext.shift();
		        }
		        if (!this.isVoidElement(name)) {
		            const pos = this.stack.indexOf(name);
		            if (pos !== -1) {
		                for (let index = 0; index <= pos; index++) {
		                    const element = this.stack.shift();
		                    // We know the stack has sufficient elements.
		                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);
		                }
		            }
		            else if (this.htmlMode && name === "p") {
		                // Implicit open before close
		                this.emitOpenTag("p");
		                this.closeCurrentTag(true);
		            }
		        }
		        else if (this.htmlMode && name === "br") {
		            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
		            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
		            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
		            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
		        }
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    onselfclosingtag(endIndex) {
		        this.endIndex = endIndex;
		        if (this.recognizeSelfClosing || this.foreignContext[0]) {
		            this.closeCurrentTag(false);
		            // Set `startIndex` for next node
		            this.startIndex = endIndex + 1;
		        }
		        else {
		            // Ignore the fact that the tag is self-closing.
		            this.onopentagend(endIndex);
		        }
		    }
		    closeCurrentTag(isOpenImplied) {
		        var _a, _b;
		        const name = this.tagname;
		        this.endOpenTag(isOpenImplied);
		        // Self-closing tags will be on the top of the stack
		        if (this.stack[0] === name) {
		            // If the opening tag isn't implied, the closing tag has to be implied.
		            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
		            this.stack.shift();
		        }
		    }
		    /** @internal */
		    onattribname(start, endIndex) {
		        this.startIndex = start;
		        const name = this.getSlice(start, endIndex);
		        this.attribname = this.lowerCaseAttributeNames
		            ? name.toLowerCase()
		            : name;
		    }
		    /** @internal */
		    onattribdata(start, endIndex) {
		        this.attribvalue += this.getSlice(start, endIndex);
		    }
		    /** @internal */
		    onattribentity(cp) {
		        this.attribvalue += (0, decode_1.fromCodePoint)(cp);
		    }
		    /** @internal */
		    onattribend(quote, endIndex) {
		        var _a, _b;
		        this.endIndex = endIndex;
		        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double
		            ? '"'
		            : quote === Tokenizer_js_1.QuoteType.Single
		                ? "'"
		                : quote === Tokenizer_js_1.QuoteType.NoValue
		                    ? undefined
		                    : null);
		        if (this.attribs &&
		            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
		            this.attribs[this.attribname] = this.attribvalue;
		        }
		        this.attribvalue = "";
		    }
		    getInstructionName(value) {
		        const index = value.search(reNameEnd);
		        let name = index < 0 ? value : value.substr(0, index);
		        if (this.lowerCaseTagNames) {
		            name = name.toLowerCase();
		        }
		        return name;
		    }
		    /** @internal */
		    ondeclaration(start, endIndex) {
		        this.endIndex = endIndex;
		        const value = this.getSlice(start, endIndex);
		        if (this.cbs.onprocessinginstruction) {
		            const name = this.getInstructionName(value);
		            this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
		        }
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    onprocessinginstruction(start, endIndex) {
		        this.endIndex = endIndex;
		        const value = this.getSlice(start, endIndex);
		        if (this.cbs.onprocessinginstruction) {
		            const name = this.getInstructionName(value);
		            this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
		        }
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    oncomment(start, endIndex, offset) {
		        var _a, _b, _c, _d;
		        this.endIndex = endIndex;
		        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
		        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    oncdata(start, endIndex, offset) {
		        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
		        this.endIndex = endIndex;
		        const value = this.getSlice(start, endIndex - offset);
		        if (!this.htmlMode || this.options.recognizeCDATA) {
		            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
		            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
		            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
		        }
		        else {
		            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
		            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
		        }
		        // Set `startIndex` for next node
		        this.startIndex = endIndex + 1;
		    }
		    /** @internal */
		    onend() {
		        var _a, _b;
		        if (this.cbs.onclosetag) {
		            // Set the end index for all remaining tags
		            this.endIndex = this.startIndex;
		            for (let index = 0; index < this.stack.length; index++) {
		                this.cbs.onclosetag(this.stack[index], true);
		            }
		        }
		        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
		    }
		    /**
		     * Resets the parser to a blank state, ready to parse a new HTML document
		     */
		    reset() {
		        var _a, _b, _c, _d;
		        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
		        this.tokenizer.reset();
		        this.tagname = "";
		        this.attribname = "";
		        this.attribs = null;
		        this.stack.length = 0;
		        this.startIndex = 0;
		        this.endIndex = 0;
		        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
		        this.buffers.length = 0;
		        this.foreignContext.length = 0;
		        this.foreignContext.unshift(!this.htmlMode);
		        this.bufferOffset = 0;
		        this.writeIndex = 0;
		        this.ended = false;
		    }
		    /**
		     * Resets the parser, then parses a complete document and
		     * pushes it to the handler.
		     *
		     * @param data Document to parse.
		     */
		    parseComplete(data) {
		        this.reset();
		        this.end(data);
		    }
		    getSlice(start, end) {
		        while (start - this.bufferOffset >= this.buffers[0].length) {
		            this.shiftBuffer();
		        }
		        let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
		        while (end - this.bufferOffset > this.buffers[0].length) {
		            this.shiftBuffer();
		            slice += this.buffers[0].slice(0, end - this.bufferOffset);
		        }
		        return slice;
		    }
		    shiftBuffer() {
		        this.bufferOffset += this.buffers[0].length;
		        this.writeIndex--;
		        this.buffers.shift();
		    }
		    /**
		     * Parses a chunk of data and calls the corresponding callbacks.
		     *
		     * @param chunk Chunk to parse.
		     */
		    write(chunk) {
		        var _a, _b;
		        if (this.ended) {
		            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
		            return;
		        }
		        this.buffers.push(chunk);
		        if (this.tokenizer.running) {
		            this.tokenizer.write(chunk);
		            this.writeIndex++;
		        }
		    }
		    /**
		     * Parses the end of the buffer and clears the stack, calls onend.
		     *
		     * @param chunk Optional final chunk to parse.
		     */
		    end(chunk) {
		        var _a, _b;
		        if (this.ended) {
		            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
		            return;
		        }
		        if (chunk)
		            this.write(chunk);
		        this.ended = true;
		        this.tokenizer.end();
		    }
		    /**
		     * Pauses parsing. The parser won't emit events until `resume` is called.
		     */
		    pause() {
		        this.tokenizer.pause();
		    }
		    /**
		     * Resumes parsing after `pause` was called.
		     */
		    resume() {
		        this.tokenizer.resume();
		        while (this.tokenizer.running &&
		            this.writeIndex < this.buffers.length) {
		            this.tokenizer.write(this.buffers[this.writeIndex++]);
		        }
		        if (this.ended)
		            this.tokenizer.end();
		    }
		    /**
		     * Alias of `write`, for backwards compatibility.
		     *
		     * @param chunk Chunk to parse.
		     * @deprecated
		     */
		    parseChunk(chunk) {
		        this.write(chunk);
		    }
		    /**
		     * Alias of `end`, for backwards compatibility.
		     *
		     * @param chunk Optional final chunk to parse.
		     * @deprecated
		     */
		    done(chunk) {
		        this.end(chunk);
		    }
		};
		Parser.Parser = Parser$1;
		
		return Parser;
	}

	var lib$3 = {};

	var stringify = {};

	var lib$2 = {};

	var lib$1 = {};

	var decode = {};

	var decodeDataHtml = {};

	var hasRequiredDecodeDataHtml;

	function requireDecodeDataHtml () {
		if (hasRequiredDecodeDataHtml) return decodeDataHtml;
		hasRequiredDecodeDataHtml = 1;
		// Generated using scripts/write-decode-map.ts
		Object.defineProperty(decodeDataHtml, "__esModule", { value: true });
		decodeDataHtml.default = new Uint16Array(
		// prettier-ignore
		"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
		    .split("")
		    .map(function (c) { return c.charCodeAt(0); }));
		
		return decodeDataHtml;
	}

	var decodeDataXml = {};

	var hasRequiredDecodeDataXml;

	function requireDecodeDataXml () {
		if (hasRequiredDecodeDataXml) return decodeDataXml;
		hasRequiredDecodeDataXml = 1;
		// Generated using scripts/write-decode-map.ts
		Object.defineProperty(decodeDataXml, "__esModule", { value: true });
		decodeDataXml.default = new Uint16Array(
		// prettier-ignore
		"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
		    .split("")
		    .map(function (c) { return c.charCodeAt(0); }));
		
		return decodeDataXml;
	}

	var decode_codepoint = {};

	var hasRequiredDecode_codepoint;

	function requireDecode_codepoint () {
		if (hasRequiredDecode_codepoint) return decode_codepoint;
		hasRequiredDecode_codepoint = 1;
		(function (exports) {
			// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
			var _a;
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.replaceCodePoint = exports.fromCodePoint = void 0;
			var decodeMap = new Map([
			    [0, 65533],
			    // C1 Unicode control character reference replacements
			    [128, 8364],
			    [130, 8218],
			    [131, 402],
			    [132, 8222],
			    [133, 8230],
			    [134, 8224],
			    [135, 8225],
			    [136, 710],
			    [137, 8240],
			    [138, 352],
			    [139, 8249],
			    [140, 338],
			    [142, 381],
			    [145, 8216],
			    [146, 8217],
			    [147, 8220],
			    [148, 8221],
			    [149, 8226],
			    [150, 8211],
			    [151, 8212],
			    [152, 732],
			    [153, 8482],
			    [154, 353],
			    [155, 8250],
			    [156, 339],
			    [158, 382],
			    [159, 376],
			]);
			/**
			 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
			 */
			exports.fromCodePoint = 
			// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
			(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
			    var output = "";
			    if (codePoint > 0xffff) {
			        codePoint -= 0x10000;
			        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
			        codePoint = 0xdc00 | (codePoint & 0x3ff);
			    }
			    output += String.fromCharCode(codePoint);
			    return output;
			};
			/**
			 * Replace the given code point with a replacement character if it is a
			 * surrogate or is outside the valid range. Otherwise return the code
			 * point unchanged.
			 */
			function replaceCodePoint(codePoint) {
			    var _a;
			    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
			        return 0xfffd;
			    }
			    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
			}
			exports.replaceCodePoint = replaceCodePoint;
			/**
			 * Replace the code point if relevant, then convert it to a string.
			 *
			 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
			 * @param codePoint The code point to decode.
			 * @returns The decoded code point.
			 */
			function decodeCodePoint(codePoint) {
			    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
			}
			exports.default = decodeCodePoint;
			
		} (decode_codepoint));
		return decode_codepoint;
	}

	var hasRequiredDecode;

	function requireDecode () {
		if (hasRequiredDecode) return decode;
		hasRequiredDecode = 1;
		(function (exports) {
			var __createBinding = (decode && decode.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __setModuleDefault = (decode && decode.__setModuleDefault) || (Object.create ? (function(o, v) {
			    Object.defineProperty(o, "default", { enumerable: true, value: v });
			}) : function(o, v) {
			    o["default"] = v;
			});
			var __importStar = (decode && decode.__importStar) || function (mod) {
			    if (mod && mod.__esModule) return mod;
			    var result = {};
			    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
			    __setModuleDefault(result, mod);
			    return result;
			};
			var __importDefault = (decode && decode.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
			var decode_data_html_js_1 = __importDefault(/*@__PURE__*/ requireDecodeDataHtml());
			exports.htmlDecodeTree = decode_data_html_js_1.default;
			var decode_data_xml_js_1 = __importDefault(/*@__PURE__*/ requireDecodeDataXml());
			exports.xmlDecodeTree = decode_data_xml_js_1.default;
			var decode_codepoint_js_1 = __importStar(/*@__PURE__*/ requireDecode_codepoint());
			exports.decodeCodePoint = decode_codepoint_js_1.default;
			var decode_codepoint_js_2 = /*@__PURE__*/ requireDecode_codepoint();
			Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });
			Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });
			var CharCodes;
			(function (CharCodes) {
			    CharCodes[CharCodes["NUM"] = 35] = "NUM";
			    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
			    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
			    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
			    CharCodes[CharCodes["NINE"] = 57] = "NINE";
			    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
			    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
			    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
			    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
			    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
			    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
			    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
			})(CharCodes || (CharCodes = {}));
			/** Bit that needs to be set to convert an upper case ASCII character to lower case */
			var TO_LOWER_BIT = 32;
			var BinTrieFlags;
			(function (BinTrieFlags) {
			    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
			    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
			    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
			})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
			function isNumber(code) {
			    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
			}
			function isHexadecimalCharacter(code) {
			    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
			        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
			}
			function isAsciiAlphaNumeric(code) {
			    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
			        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
			        isNumber(code));
			}
			/**
			 * Checks if the given character is a valid end character for an entity in an attribute.
			 *
			 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
			 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
			 */
			function isEntityInAttributeInvalidEnd(code) {
			    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
			}
			var EntityDecoderState;
			(function (EntityDecoderState) {
			    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
			    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
			    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
			    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
			    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
			})(EntityDecoderState || (EntityDecoderState = {}));
			var DecodingMode;
			(function (DecodingMode) {
			    /** Entities in text nodes that can end with any character. */
			    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
			    /** Only allow entities terminated with a semicolon. */
			    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
			    /** Entities in attributes have limitations on ending characters. */
			    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
			})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
			/**
			 * Token decoder with support of writing partial entities.
			 */
			var EntityDecoder = /** @class */ (function () {
			    function EntityDecoder(
			    /** The tree used to decode entities. */
			    decodeTree, 
			    /**
			     * The function that is called when a codepoint is decoded.
			     *
			     * For multi-byte named entities, this will be called multiple times,
			     * with the second codepoint, and the same `consumed` value.
			     *
			     * @param codepoint The decoded codepoint.
			     * @param consumed The number of bytes consumed by the decoder.
			     */
			    emitCodePoint, 
			    /** An object that is used to produce errors. */
			    errors) {
			        this.decodeTree = decodeTree;
			        this.emitCodePoint = emitCodePoint;
			        this.errors = errors;
			        /** The current state of the decoder. */
			        this.state = EntityDecoderState.EntityStart;
			        /** Characters that were consumed while parsing an entity. */
			        this.consumed = 1;
			        /**
			         * The result of the entity.
			         *
			         * Either the result index of a numeric entity, or the codepoint of a
			         * numeric entity.
			         */
			        this.result = 0;
			        /** The current index in the decode tree. */
			        this.treeIndex = 0;
			        /** The number of characters that were consumed in excess. */
			        this.excess = 1;
			        /** The mode in which the decoder is operating. */
			        this.decodeMode = DecodingMode.Strict;
			    }
			    /** Resets the instance to make it reusable. */
			    EntityDecoder.prototype.startEntity = function (decodeMode) {
			        this.decodeMode = decodeMode;
			        this.state = EntityDecoderState.EntityStart;
			        this.result = 0;
			        this.treeIndex = 0;
			        this.excess = 1;
			        this.consumed = 1;
			    };
			    /**
			     * Write an entity to the decoder. This can be called multiple times with partial entities.
			     * If the entity is incomplete, the decoder will return -1.
			     *
			     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
			     * entity is incomplete, and resume when the next string is written.
			     *
			     * @param string The string containing the entity (or a continuation of the entity).
			     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    EntityDecoder.prototype.write = function (str, offset) {
			        switch (this.state) {
			            case EntityDecoderState.EntityStart: {
			                if (str.charCodeAt(offset) === CharCodes.NUM) {
			                    this.state = EntityDecoderState.NumericStart;
			                    this.consumed += 1;
			                    return this.stateNumericStart(str, offset + 1);
			                }
			                this.state = EntityDecoderState.NamedEntity;
			                return this.stateNamedEntity(str, offset);
			            }
			            case EntityDecoderState.NumericStart: {
			                return this.stateNumericStart(str, offset);
			            }
			            case EntityDecoderState.NumericDecimal: {
			                return this.stateNumericDecimal(str, offset);
			            }
			            case EntityDecoderState.NumericHex: {
			                return this.stateNumericHex(str, offset);
			            }
			            case EntityDecoderState.NamedEntity: {
			                return this.stateNamedEntity(str, offset);
			            }
			        }
			    };
			    /**
			     * Switches between the numeric decimal and hexadecimal states.
			     *
			     * Equivalent to the `Numeric character reference state` in the HTML spec.
			     *
			     * @param str The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    EntityDecoder.prototype.stateNumericStart = function (str, offset) {
			        if (offset >= str.length) {
			            return -1;
			        }
			        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
			            this.state = EntityDecoderState.NumericHex;
			            this.consumed += 1;
			            return this.stateNumericHex(str, offset + 1);
			        }
			        this.state = EntityDecoderState.NumericDecimal;
			        return this.stateNumericDecimal(str, offset);
			    };
			    EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {
			        if (start !== end) {
			            var digitCount = end - start;
			            this.result =
			                this.result * Math.pow(base, digitCount) +
			                    parseInt(str.substr(start, digitCount), base);
			            this.consumed += digitCount;
			        }
			    };
			    /**
			     * Parses a hexadecimal numeric entity.
			     *
			     * Equivalent to the `Hexademical character reference state` in the HTML spec.
			     *
			     * @param str The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    EntityDecoder.prototype.stateNumericHex = function (str, offset) {
			        var startIdx = offset;
			        while (offset < str.length) {
			            var char = str.charCodeAt(offset);
			            if (isNumber(char) || isHexadecimalCharacter(char)) {
			                offset += 1;
			            }
			            else {
			                this.addToNumericResult(str, startIdx, offset, 16);
			                return this.emitNumericEntity(char, 3);
			            }
			        }
			        this.addToNumericResult(str, startIdx, offset, 16);
			        return -1;
			    };
			    /**
			     * Parses a decimal numeric entity.
			     *
			     * Equivalent to the `Decimal character reference state` in the HTML spec.
			     *
			     * @param str The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {
			        var startIdx = offset;
			        while (offset < str.length) {
			            var char = str.charCodeAt(offset);
			            if (isNumber(char)) {
			                offset += 1;
			            }
			            else {
			                this.addToNumericResult(str, startIdx, offset, 10);
			                return this.emitNumericEntity(char, 2);
			            }
			        }
			        this.addToNumericResult(str, startIdx, offset, 10);
			        return -1;
			    };
			    /**
			     * Validate and emit a numeric entity.
			     *
			     * Implements the logic from the `Hexademical character reference start
			     * state` and `Numeric character reference end state` in the HTML spec.
			     *
			     * @param lastCp The last code point of the entity. Used to see if the
			     *               entity was terminated with a semicolon.
			     * @param expectedLength The minimum number of characters that should be
			     *                       consumed. Used to validate that at least one digit
			     *                       was consumed.
			     * @returns The number of characters that were consumed.
			     */
			    EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {
			        var _a;
			        // Ensure we consumed at least one digit.
			        if (this.consumed <= expectedLength) {
			            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
			            return 0;
			        }
			        // Figure out if this is a legit end of the entity
			        if (lastCp === CharCodes.SEMI) {
			            this.consumed += 1;
			        }
			        else if (this.decodeMode === DecodingMode.Strict) {
			            return 0;
			        }
			        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
			        if (this.errors) {
			            if (lastCp !== CharCodes.SEMI) {
			                this.errors.missingSemicolonAfterCharacterReference();
			            }
			            this.errors.validateNumericCharacterReference(this.result);
			        }
			        return this.consumed;
			    };
			    /**
			     * Parses a named entity.
			     *
			     * Equivalent to the `Named character reference state` in the HTML spec.
			     *
			     * @param str The string containing the entity (or a continuation of the entity).
			     * @param offset The current offset.
			     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
			     */
			    EntityDecoder.prototype.stateNamedEntity = function (str, offset) {
			        var decodeTree = this.decodeTree;
			        var current = decodeTree[this.treeIndex];
			        // The mask is the number of bytes of the value, including the current byte.
			        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			        for (; offset < str.length; offset++, this.excess++) {
			            var char = str.charCodeAt(offset);
			            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			            if (this.treeIndex < 0) {
			                return this.result === 0 ||
			                    // If we are parsing an attribute
			                    (this.decodeMode === DecodingMode.Attribute &&
			                        // We shouldn't have consumed any characters after the entity,
			                        (valueLength === 0 ||
			                            // And there should be no invalid characters.
			                            isEntityInAttributeInvalidEnd(char)))
			                    ? 0
			                    : this.emitNotTerminatedNamedEntity();
			            }
			            current = decodeTree[this.treeIndex];
			            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			            // If the branch is a value, store it and continue
			            if (valueLength !== 0) {
			                // If the entity is terminated by a semicolon, we are done.
			                if (char === CharCodes.SEMI) {
			                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
			                }
			                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
			                if (this.decodeMode !== DecodingMode.Strict) {
			                    this.result = this.treeIndex;
			                    this.consumed += this.excess;
			                    this.excess = 0;
			                }
			            }
			        }
			        return -1;
			    };
			    /**
			     * Emit a named entity that was not terminated with a semicolon.
			     *
			     * @returns The number of characters consumed.
			     */
			    EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {
			        var _a;
			        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
			        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
			        this.emitNamedEntityData(result, valueLength, this.consumed);
			        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
			        return this.consumed;
			    };
			    /**
			     * Emit a named entity.
			     *
			     * @param result The index of the entity in the decode tree.
			     * @param valueLength The number of bytes in the entity.
			     * @param consumed The number of characters consumed.
			     *
			     * @returns The number of characters consumed.
			     */
			    EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {
			        var decodeTree = this.decodeTree;
			        this.emitCodePoint(valueLength === 1
			            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
			            : decodeTree[result + 1], consumed);
			        if (valueLength === 3) {
			            // For multi-byte values, we need to emit the second byte.
			            this.emitCodePoint(decodeTree[result + 2], consumed);
			        }
			        return consumed;
			    };
			    /**
			     * Signal to the parser that the end of the input was reached.
			     *
			     * Remaining data will be emitted and relevant errors will be produced.
			     *
			     * @returns The number of characters consumed.
			     */
			    EntityDecoder.prototype.end = function () {
			        var _a;
			        switch (this.state) {
			            case EntityDecoderState.NamedEntity: {
			                // Emit a named entity if we have one.
			                return this.result !== 0 &&
			                    (this.decodeMode !== DecodingMode.Attribute ||
			                        this.result === this.treeIndex)
			                    ? this.emitNotTerminatedNamedEntity()
			                    : 0;
			            }
			            // Otherwise, emit a numeric entity if we have one.
			            case EntityDecoderState.NumericDecimal: {
			                return this.emitNumericEntity(0, 2);
			            }
			            case EntityDecoderState.NumericHex: {
			                return this.emitNumericEntity(0, 3);
			            }
			            case EntityDecoderState.NumericStart: {
			                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
			                return 0;
			            }
			            case EntityDecoderState.EntityStart: {
			                // Return 0 if we have no entity.
			                return 0;
			            }
			        }
			    };
			    return EntityDecoder;
			}());
			exports.EntityDecoder = EntityDecoder;
			/**
			 * Creates a function that decodes entities in a string.
			 *
			 * @param decodeTree The decode tree.
			 * @returns A function that decodes entities in a string.
			 */
			function getDecoder(decodeTree) {
			    var ret = "";
			    var decoder = new EntityDecoder(decodeTree, function (str) { return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str)); });
			    return function decodeWithTrie(str, decodeMode) {
			        var lastIndex = 0;
			        var offset = 0;
			        while ((offset = str.indexOf("&", offset)) >= 0) {
			            ret += str.slice(lastIndex, offset);
			            decoder.startEntity(decodeMode);
			            var len = decoder.write(str, 
			            // Skip the "&"
			            offset + 1);
			            if (len < 0) {
			                lastIndex = offset + decoder.end();
			                break;
			            }
			            lastIndex = offset + len;
			            // If `len` is 0, skip the current `&` and continue.
			            offset = len === 0 ? lastIndex + 1 : lastIndex;
			        }
			        var result = ret + str.slice(lastIndex);
			        // Make sure we don't keep a reference to the final string.
			        ret = "";
			        return result;
			    };
			}
			/**
			 * Determines the branch of the current node that is taken given the current
			 * character. This function is used to traverse the trie.
			 *
			 * @param decodeTree The trie.
			 * @param current The current node.
			 * @param nodeIdx The index right after the current node and its value.
			 * @param char The current character.
			 * @returns The index of the next node, or -1 if no branch is taken.
			 */
			function determineBranch(decodeTree, current, nodeIdx, char) {
			    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
			    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
			    // Case 1: Single branch encoded in jump offset
			    if (branchCount === 0) {
			        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
			    }
			    // Case 2: Multiple branches encoded in jump table
			    if (jumpOffset) {
			        var value = char - jumpOffset;
			        return value < 0 || value >= branchCount
			            ? -1
			            : decodeTree[nodeIdx + value] - 1;
			    }
			    // Case 3: Multiple branches encoded in dictionary
			    // Binary search for the character.
			    var lo = nodeIdx;
			    var hi = lo + branchCount - 1;
			    while (lo <= hi) {
			        var mid = (lo + hi) >>> 1;
			        var midVal = decodeTree[mid];
			        if (midVal < char) {
			            lo = mid + 1;
			        }
			        else if (midVal > char) {
			            hi = mid - 1;
			        }
			        else {
			            return decodeTree[mid + branchCount];
			        }
			    }
			    return -1;
			}
			exports.determineBranch = determineBranch;
			var htmlDecoder = getDecoder(decode_data_html_js_1.default);
			var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
			/**
			 * Decodes an HTML string.
			 *
			 * @param str The string to decode.
			 * @param mode The decoding mode.
			 * @returns The decoded string.
			 */
			function decodeHTML(str, mode) {
			    if (mode === void 0) { mode = DecodingMode.Legacy; }
			    return htmlDecoder(str, mode);
			}
			exports.decodeHTML = decodeHTML;
			/**
			 * Decodes an HTML string in an attribute.
			 *
			 * @param str The string to decode.
			 * @returns The decoded string.
			 */
			function decodeHTMLAttribute(str) {
			    return htmlDecoder(str, DecodingMode.Attribute);
			}
			exports.decodeHTMLAttribute = decodeHTMLAttribute;
			/**
			 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
			 *
			 * @param str The string to decode.
			 * @returns The decoded string.
			 */
			function decodeHTMLStrict(str) {
			    return htmlDecoder(str, DecodingMode.Strict);
			}
			exports.decodeHTMLStrict = decodeHTMLStrict;
			/**
			 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
			 *
			 * @param str The string to decode.
			 * @returns The decoded string.
			 */
			function decodeXML(str) {
			    return xmlDecoder(str, DecodingMode.Strict);
			}
			exports.decodeXML = decodeXML;
			
		} (decode));
		return decode;
	}

	var encode = {};

	var encodeHtml = {};

	var hasRequiredEncodeHtml;

	function requireEncodeHtml () {
		if (hasRequiredEncodeHtml) return encodeHtml;
		hasRequiredEncodeHtml = 1;
		// Generated using scripts/write-encode-map.ts
		Object.defineProperty(encodeHtml, "__esModule", { value: true });
		function restoreDiff(arr) {
		    for (var i = 1; i < arr.length; i++) {
		        arr[i][0] += arr[i - 1][0] + 1;
		    }
		    return arr;
		}
		// prettier-ignore
		encodeHtml.default = new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
		
		return encodeHtml;
	}

	var _escape = {};

	var hasRequired_escape;

	function require_escape () {
		if (hasRequired_escape) return _escape;
		hasRequired_escape = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
			exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
			var xmlCodeMap = new Map([
			    [34, "&quot;"],
			    [38, "&amp;"],
			    [39, "&apos;"],
			    [60, "&lt;"],
			    [62, "&gt;"],
			]);
			// For compatibility with node < 4, we wrap `codePointAt`
			exports.getCodePoint = 
			// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
			String.prototype.codePointAt != null
			    ? function (str, index) { return str.codePointAt(index); }
			    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
			        function (c, index) {
			            return (c.charCodeAt(index) & 0xfc00) === 0xd800
			                ? (c.charCodeAt(index) - 0xd800) * 0x400 +
			                    c.charCodeAt(index + 1) -
			                    0xdc00 +
			                    0x10000
			                : c.charCodeAt(index);
			        };
			/**
			 * Encodes all non-ASCII characters, as well as characters not valid in XML
			 * documents using XML entities.
			 *
			 * If a character has no equivalent entity, a
			 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
			 */
			function encodeXML(str) {
			    var ret = "";
			    var lastIdx = 0;
			    var match;
			    while ((match = exports.xmlReplacer.exec(str)) !== null) {
			        var i = match.index;
			        var char = str.charCodeAt(i);
			        var next = xmlCodeMap.get(char);
			        if (next !== undefined) {
			            ret += str.substring(lastIdx, i) + next;
			            lastIdx = i + 1;
			        }
			        else {
			            ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
			            // Increase by 1 if we have a surrogate pair
			            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
			        }
			    }
			    return ret + str.substr(lastIdx);
			}
			exports.encodeXML = encodeXML;
			/**
			 * Encodes all non-ASCII characters, as well as characters not valid in XML
			 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
			 *
			 * Have a look at `escapeUTF8` if you want a more concise output at the expense
			 * of reduced transportability.
			 *
			 * @param data String to escape.
			 */
			exports.escape = encodeXML;
			/**
			 * Creates a function that escapes all characters matched by the given regular
			 * expression using the given map of characters to escape to their entities.
			 *
			 * @param regex Regular expression to match characters to escape.
			 * @param map Map of characters to escape to their entities.
			 *
			 * @returns Function that escapes all characters matched by the given regular
			 * expression using the given map of characters to escape to their entities.
			 */
			function getEscaper(regex, map) {
			    return function escape(data) {
			        var match;
			        var lastIdx = 0;
			        var result = "";
			        while ((match = regex.exec(data))) {
			            if (lastIdx !== match.index) {
			                result += data.substring(lastIdx, match.index);
			            }
			            // We know that this character will be in the map.
			            result += map.get(match[0].charCodeAt(0));
			            // Every match will be of length 1
			            lastIdx = match.index + 1;
			        }
			        return result + data.substring(lastIdx);
			    };
			}
			/**
			 * Encodes all characters not valid in XML documents using XML entities.
			 *
			 * Note that the output will be character-set dependent.
			 *
			 * @param data String to escape.
			 */
			exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
			/**
			 * Encodes all characters that have to be escaped in HTML attributes,
			 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
			 *
			 * @param data String to escape.
			 */
			exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
			    [34, "&quot;"],
			    [38, "&amp;"],
			    [160, "&nbsp;"],
			]));
			/**
			 * Encodes all characters that have to be escaped in HTML text,
			 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
			 *
			 * @param data String to escape.
			 */
			exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
			    [38, "&amp;"],
			    [60, "&lt;"],
			    [62, "&gt;"],
			    [160, "&nbsp;"],
			]));
			
		} (_escape));
		return _escape;
	}

	var hasRequiredEncode;

	function requireEncode () {
		if (hasRequiredEncode) return encode;
		hasRequiredEncode = 1;
		var __importDefault = (encode && encode.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(encode, "__esModule", { value: true });
		encode.encodeNonAsciiHTML = encode.encodeHTML = void 0;
		var encode_html_js_1 = __importDefault(/*@__PURE__*/ requireEncodeHtml());
		var escape_js_1 = /*@__PURE__*/ require_escape();
		var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
		/**
		 * Encodes all characters in the input using HTML entities. This includes
		 * characters that are valid ASCII characters in HTML documents, such as `#`.
		 *
		 * To get a more compact output, consider using the `encodeNonAsciiHTML`
		 * function, which will only encode characters that are not valid in HTML
		 * documents, as well as non-ASCII characters.
		 *
		 * If a character has no equivalent entity, a numeric hexadecimal reference
		 * (eg. `&#xfc;`) will be used.
		 */
		function encodeHTML(data) {
		    return encodeHTMLTrieRe(htmlReplacer, data);
		}
		encode.encodeHTML = encodeHTML;
		/**
		 * Encodes all non-ASCII characters, as well as characters not valid in HTML
		 * documents using HTML entities. This function will not encode characters that
		 * are valid in HTML documents, such as `#`.
		 *
		 * If a character has no equivalent entity, a numeric hexadecimal reference
		 * (eg. `&#xfc;`) will be used.
		 */
		function encodeNonAsciiHTML(data) {
		    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
		}
		encode.encodeNonAsciiHTML = encodeNonAsciiHTML;
		function encodeHTMLTrieRe(regExp, str) {
		    var ret = "";
		    var lastIdx = 0;
		    var match;
		    while ((match = regExp.exec(str)) !== null) {
		        var i = match.index;
		        ret += str.substring(lastIdx, i);
		        var char = str.charCodeAt(i);
		        var next = encode_html_js_1.default.get(char);
		        if (typeof next === "object") {
		            // We are in a branch. Try to match the next char.
		            if (i + 1 < str.length) {
		                var nextChar = str.charCodeAt(i + 1);
		                var value = typeof next.n === "number"
		                    ? next.n === nextChar
		                        ? next.o
		                        : undefined
		                    : next.n.get(nextChar);
		                if (value !== undefined) {
		                    ret += value;
		                    lastIdx = regExp.lastIndex += 1;
		                    continue;
		                }
		            }
		            next = next.v;
		        }
		        // We might have a tree node without a value; skip and use a numeric entity.
		        if (next !== undefined) {
		            ret += next;
		            lastIdx = i + 1;
		        }
		        else {
		            var cp = (0, escape_js_1.getCodePoint)(str, i);
		            ret += "&#x".concat(cp.toString(16), ";");
		            // Increase by 1 if we have a surrogate pair
		            lastIdx = regExp.lastIndex += Number(cp !== char);
		        }
		    }
		    return ret + str.substr(lastIdx);
		}
		
		return encode;
	}

	var hasRequiredLib$5;

	function requireLib$5 () {
		if (hasRequiredLib$5) return lib$1;
		hasRequiredLib$5 = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
			var decode_js_1 = /*@__PURE__*/ requireDecode();
			var encode_js_1 = /*@__PURE__*/ requireEncode();
			var escape_js_1 = /*@__PURE__*/ require_escape();
			/** The level of entities to support. */
			var EntityLevel;
			(function (EntityLevel) {
			    /** Support only XML entities. */
			    EntityLevel[EntityLevel["XML"] = 0] = "XML";
			    /** Support HTML entities, which are a superset of XML entities. */
			    EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
			})(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
			var EncodingMode;
			(function (EncodingMode) {
			    /**
			     * The output is UTF-8 encoded. Only characters that need escaping within
			     * XML will be escaped.
			     */
			    EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
			    /**
			     * The output consists only of ASCII characters. Characters that need
			     * escaping within HTML, and characters that aren't ASCII characters will
			     * be escaped.
			     */
			    EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
			    /**
			     * Encode all characters that have an equivalent entity, as well as all
			     * characters that are not ASCII characters.
			     */
			    EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
			    /**
			     * Encode all characters that have to be escaped in HTML attributes,
			     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
			     */
			    EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
			    /**
			     * Encode all characters that have to be escaped in HTML text,
			     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
			     */
			    EncodingMode[EncodingMode["Text"] = 4] = "Text";
			})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
			/**
			 * Decodes a string with entities.
			 *
			 * @param data String to decode.
			 * @param options Decoding options.
			 */
			function decode(data, options) {
			    if (options === void 0) { options = EntityLevel.XML; }
			    var level = typeof options === "number" ? options : options.level;
			    if (level === EntityLevel.HTML) {
			        var mode = typeof options === "object" ? options.mode : undefined;
			        return (0, decode_js_1.decodeHTML)(data, mode);
			    }
			    return (0, decode_js_1.decodeXML)(data);
			}
			exports.decode = decode;
			/**
			 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
			 *
			 * @param data String to decode.
			 * @param options Decoding options.
			 * @deprecated Use `decode` with the `mode` set to `Strict`.
			 */
			function decodeStrict(data, options) {
			    var _a;
			    if (options === void 0) { options = EntityLevel.XML; }
			    var opts = typeof options === "number" ? { level: options } : options;
			    (_a = opts.mode) !== null && _a !== void 0 ? _a : (opts.mode = decode_js_1.DecodingMode.Strict);
			    return decode(data, opts);
			}
			exports.decodeStrict = decodeStrict;
			/**
			 * Encodes a string with entities.
			 *
			 * @param data String to encode.
			 * @param options Encoding options.
			 */
			function encode(data, options) {
			    if (options === void 0) { options = EntityLevel.XML; }
			    var opts = typeof options === "number" ? { level: options } : options;
			    // Mode `UTF8` just escapes XML entities
			    if (opts.mode === EncodingMode.UTF8)
			        return (0, escape_js_1.escapeUTF8)(data);
			    if (opts.mode === EncodingMode.Attribute)
			        return (0, escape_js_1.escapeAttribute)(data);
			    if (opts.mode === EncodingMode.Text)
			        return (0, escape_js_1.escapeText)(data);
			    if (opts.level === EntityLevel.HTML) {
			        if (opts.mode === EncodingMode.ASCII) {
			            return (0, encode_js_1.encodeNonAsciiHTML)(data);
			        }
			        return (0, encode_js_1.encodeHTML)(data);
			    }
			    // ASCII and Extensive are equivalent
			    return (0, escape_js_1.encodeXML)(data);
			}
			exports.encode = encode;
			var escape_js_2 = /*@__PURE__*/ require_escape();
			Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return escape_js_2.encodeXML; } });
			Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
			Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return escape_js_2.escapeUTF8; } });
			Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function () { return escape_js_2.escapeAttribute; } });
			Object.defineProperty(exports, "escapeText", { enumerable: true, get: function () { return escape_js_2.escapeText; } });
			var encode_js_2 = /*@__PURE__*/ requireEncode();
			Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
			Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_js_2.encodeNonAsciiHTML; } });
			// Legacy aliases (deprecated)
			Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
			Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });
			var decode_js_2 = /*@__PURE__*/ requireDecode();
			Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function () { return decode_js_2.EntityDecoder; } });
			Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function () { return decode_js_2.DecodingMode; } });
			Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });
			Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
			Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
			Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function () { return decode_js_2.decodeHTMLAttribute; } });
			// Legacy aliases (deprecated)
			Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
			Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });
			Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
			Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });
			Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });
			
		} (lib$1));
		return lib$1;
	}

	var foreignNames = {};

	var hasRequiredForeignNames;

	function requireForeignNames () {
		if (hasRequiredForeignNames) return foreignNames;
		hasRequiredForeignNames = 1;
		Object.defineProperty(foreignNames, "__esModule", { value: true });
		foreignNames.attributeNames = foreignNames.elementNames = void 0;
		foreignNames.elementNames = new Map([
		    "altGlyph",
		    "altGlyphDef",
		    "altGlyphItem",
		    "animateColor",
		    "animateMotion",
		    "animateTransform",
		    "clipPath",
		    "feBlend",
		    "feColorMatrix",
		    "feComponentTransfer",
		    "feComposite",
		    "feConvolveMatrix",
		    "feDiffuseLighting",
		    "feDisplacementMap",
		    "feDistantLight",
		    "feDropShadow",
		    "feFlood",
		    "feFuncA",
		    "feFuncB",
		    "feFuncG",
		    "feFuncR",
		    "feGaussianBlur",
		    "feImage",
		    "feMerge",
		    "feMergeNode",
		    "feMorphology",
		    "feOffset",
		    "fePointLight",
		    "feSpecularLighting",
		    "feSpotLight",
		    "feTile",
		    "feTurbulence",
		    "foreignObject",
		    "glyphRef",
		    "linearGradient",
		    "radialGradient",
		    "textPath",
		].map(function (val) { return [val.toLowerCase(), val]; }));
		foreignNames.attributeNames = new Map([
		    "definitionURL",
		    "attributeName",
		    "attributeType",
		    "baseFrequency",
		    "baseProfile",
		    "calcMode",
		    "clipPathUnits",
		    "diffuseConstant",
		    "edgeMode",
		    "filterUnits",
		    "glyphRef",
		    "gradientTransform",
		    "gradientUnits",
		    "kernelMatrix",
		    "kernelUnitLength",
		    "keyPoints",
		    "keySplines",
		    "keyTimes",
		    "lengthAdjust",
		    "limitingConeAngle",
		    "markerHeight",
		    "markerUnits",
		    "markerWidth",
		    "maskContentUnits",
		    "maskUnits",
		    "numOctaves",
		    "pathLength",
		    "patternContentUnits",
		    "patternTransform",
		    "patternUnits",
		    "pointsAtX",
		    "pointsAtY",
		    "pointsAtZ",
		    "preserveAlpha",
		    "preserveAspectRatio",
		    "primitiveUnits",
		    "refX",
		    "refY",
		    "repeatCount",
		    "repeatDur",
		    "requiredExtensions",
		    "requiredFeatures",
		    "specularConstant",
		    "specularExponent",
		    "spreadMethod",
		    "startOffset",
		    "stdDeviation",
		    "stitchTiles",
		    "surfaceScale",
		    "systemLanguage",
		    "tableValues",
		    "targetX",
		    "targetY",
		    "textLength",
		    "viewBox",
		    "viewTarget",
		    "xChannelSelector",
		    "yChannelSelector",
		    "zoomAndPan",
		].map(function (val) { return [val.toLowerCase(), val]; }));
		return foreignNames;
	}

	var hasRequiredLib$4;

	function requireLib$4 () {
		if (hasRequiredLib$4) return lib$2;
		hasRequiredLib$4 = 1;
		var __assign = (lib$2 && lib$2.__assign) || function () {
		    __assign = Object.assign || function(t) {
		        for (var s, i = 1, n = arguments.length; i < n; i++) {
		            s = arguments[i];
		            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
		                t[p] = s[p];
		        }
		        return t;
		    };
		    return __assign.apply(this, arguments);
		};
		var __createBinding = (lib$2 && lib$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$2 && lib$2.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$2 && lib$2.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(lib$2, "__esModule", { value: true });
		lib$2.render = void 0;
		/*
		 * Module dependencies
		 */
		var ElementType = __importStar(/*@__PURE__*/ requireLib$7());
		var entities_1 = /*@__PURE__*/ requireLib$5();
		/**
		 * Mixed-case SVG and MathML tags & attributes
		 * recognized by the HTML parser.
		 *
		 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
		 */
		var foreignNames_js_1 = /*@__PURE__*/ requireForeignNames();
		var unencodedElements = new Set([
		    "style",
		    "script",
		    "xmp",
		    "iframe",
		    "noembed",
		    "noframes",
		    "plaintext",
		    "noscript",
		]);
		function replaceQuotes(value) {
		    return value.replace(/"/g, "&quot;");
		}
		/**
		 * Format attributes
		 */
		function formatAttributes(attributes, opts) {
		    var _a;
		    if (!attributes)
		        return;
		    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
		        ? replaceQuotes
		        : opts.xmlMode || opts.encodeEntities !== "utf8"
		            ? entities_1.encodeXML
		            : entities_1.escapeAttribute;
		    return Object.keys(attributes)
		        .map(function (key) {
		        var _a, _b;
		        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
		        if (opts.xmlMode === "foreign") {
		            /* Fix up mixed-case attribute names */
		            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
		        }
		        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
		            return key;
		        }
		        return "".concat(key, "=\"").concat(encode(value), "\"");
		    })
		        .join(" ");
		}
		/**
		 * Self-enclosing tags
		 */
		var singleTag = new Set([
		    "area",
		    "base",
		    "basefont",
		    "br",
		    "col",
		    "command",
		    "embed",
		    "frame",
		    "hr",
		    "img",
		    "input",
		    "isindex",
		    "keygen",
		    "link",
		    "meta",
		    "param",
		    "source",
		    "track",
		    "wbr",
		]);
		/**
		 * Renders a DOM node or an array of DOM nodes to a string.
		 *
		 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
		 *
		 * @param node Node to be rendered.
		 * @param options Changes serialization behavior
		 */
		function render(node, options) {
		    if (options === void 0) { options = {}; }
		    var nodes = "length" in node ? node : [node];
		    var output = "";
		    for (var i = 0; i < nodes.length; i++) {
		        output += renderNode(nodes[i], options);
		    }
		    return output;
		}
		lib$2.render = render;
		lib$2.default = render;
		function renderNode(node, options) {
		    switch (node.type) {
		        case ElementType.Root:
		            return render(node.children, options);
		        // @ts-expect-error We don't use `Doctype` yet
		        case ElementType.Doctype:
		        case ElementType.Directive:
		            return renderDirective(node);
		        case ElementType.Comment:
		            return renderComment(node);
		        case ElementType.CDATA:
		            return renderCdata(node);
		        case ElementType.Script:
		        case ElementType.Style:
		        case ElementType.Tag:
		            return renderTag(node, options);
		        case ElementType.Text:
		            return renderText(node, options);
		    }
		}
		var foreignModeIntegrationPoints = new Set([
		    "mi",
		    "mo",
		    "mn",
		    "ms",
		    "mtext",
		    "annotation-xml",
		    "foreignObject",
		    "desc",
		    "title",
		]);
		var foreignElements = new Set(["svg", "math"]);
		function renderTag(elem, opts) {
		    var _a;
		    // Handle SVG / MathML in HTML
		    if (opts.xmlMode === "foreign") {
		        /* Fix up mixed-case element names */
		        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
		        /* Exit foreign mode at integration points */
		        if (elem.parent &&
		            foreignModeIntegrationPoints.has(elem.parent.name)) {
		            opts = __assign(__assign({}, opts), { xmlMode: false });
		        }
		    }
		    if (!opts.xmlMode && foreignElements.has(elem.name)) {
		        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
		    }
		    var tag = "<".concat(elem.name);
		    var attribs = formatAttributes(elem.attribs, opts);
		    if (attribs) {
		        tag += " ".concat(attribs);
		    }
		    if (elem.children.length === 0 &&
		        (opts.xmlMode
		            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
		                opts.selfClosingTags !== false
		            : // User explicitly asked for self-closing tags, even in HTML mode
		                opts.selfClosingTags && singleTag.has(elem.name))) {
		        if (!opts.xmlMode)
		            tag += " ";
		        tag += "/>";
		    }
		    else {
		        tag += ">";
		        if (elem.children.length > 0) {
		            tag += render(elem.children, opts);
		        }
		        if (opts.xmlMode || !singleTag.has(elem.name)) {
		            tag += "</".concat(elem.name, ">");
		        }
		    }
		    return tag;
		}
		function renderDirective(elem) {
		    return "<".concat(elem.data, ">");
		}
		function renderText(elem, opts) {
		    var _a;
		    var data = elem.data || "";
		    // If entities weren't decoded, no need to encode them back
		    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
		        !(!opts.xmlMode &&
		            elem.parent &&
		            unencodedElements.has(elem.parent.name))) {
		        data =
		            opts.xmlMode || opts.encodeEntities !== "utf8"
		                ? (0, entities_1.encodeXML)(data)
		                : (0, entities_1.escapeText)(data);
		    }
		    return data;
		}
		function renderCdata(elem) {
		    return "<![CDATA[".concat(elem.children[0].data, "]]>");
		}
		function renderComment(elem) {
		    return "<!--".concat(elem.data, "-->");
		}
		return lib$2;
	}

	var hasRequiredStringify;

	function requireStringify () {
		if (hasRequiredStringify) return stringify;
		hasRequiredStringify = 1;
		var __importDefault = (stringify && stringify.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(stringify, "__esModule", { value: true });
		stringify.getOuterHTML = getOuterHTML;
		stringify.getInnerHTML = getInnerHTML;
		stringify.getText = getText;
		stringify.textContent = textContent;
		stringify.innerText = innerText;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		var dom_serializer_1 = __importDefault(/*@__PURE__*/ requireLib$4());
		var domelementtype_1 = /*@__PURE__*/ requireLib$7();
		/**
		 * @category Stringify
		 * @deprecated Use the `dom-serializer` module directly.
		 * @param node Node to get the outer HTML of.
		 * @param options Options for serialization.
		 * @returns `node`'s outer HTML.
		 */
		function getOuterHTML(node, options) {
		    return (0, dom_serializer_1.default)(node, options);
		}
		/**
		 * @category Stringify
		 * @deprecated Use the `dom-serializer` module directly.
		 * @param node Node to get the inner HTML of.
		 * @param options Options for serialization.
		 * @returns `node`'s inner HTML.
		 */
		function getInnerHTML(node, options) {
		    return (0, domhandler_1.hasChildren)(node)
		        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
		        : "";
		}
		/**
		 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
		 *
		 * @category Stringify
		 * @deprecated Use `textContent` instead.
		 * @param node Node to get the inner text of.
		 * @returns `node`'s inner text.
		 */
		function getText(node) {
		    if (Array.isArray(node))
		        return node.map(getText).join("");
		    if ((0, domhandler_1.isTag)(node))
		        return node.name === "br" ? "\n" : getText(node.children);
		    if ((0, domhandler_1.isCDATA)(node))
		        return getText(node.children);
		    if ((0, domhandler_1.isText)(node))
		        return node.data;
		    return "";
		}
		/**
		 * Get a node's text content. Ignores comments.
		 *
		 * @category Stringify
		 * @param node Node to get the text content of.
		 * @returns `node`'s text content.
		 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
		 */
		function textContent(node) {
		    if (Array.isArray(node))
		        return node.map(textContent).join("");
		    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
		        return textContent(node.children);
		    }
		    if ((0, domhandler_1.isText)(node))
		        return node.data;
		    return "";
		}
		/**
		 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
		 *
		 * @category Stringify
		 * @param node Node to get the inner text of.
		 * @returns `node`'s inner text.
		 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
		 */
		function innerText(node) {
		    if (Array.isArray(node))
		        return node.map(innerText).join("");
		    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
		        return innerText(node.children);
		    }
		    if ((0, domhandler_1.isText)(node))
		        return node.data;
		    return "";
		}
		
		return stringify;
	}

	var traversal = {};

	var hasRequiredTraversal;

	function requireTraversal () {
		if (hasRequiredTraversal) return traversal;
		hasRequiredTraversal = 1;
		Object.defineProperty(traversal, "__esModule", { value: true });
		traversal.getChildren = getChildren;
		traversal.getParent = getParent;
		traversal.getSiblings = getSiblings;
		traversal.getAttributeValue = getAttributeValue;
		traversal.hasAttrib = hasAttrib;
		traversal.getName = getName;
		traversal.nextElementSibling = nextElementSibling;
		traversal.prevElementSibling = prevElementSibling;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		/**
		 * Get a node's children.
		 *
		 * @category Traversal
		 * @param elem Node to get the children of.
		 * @returns `elem`'s children, or an empty array.
		 */
		function getChildren(elem) {
		    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
		}
		/**
		 * Get a node's parent.
		 *
		 * @category Traversal
		 * @param elem Node to get the parent of.
		 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
		 */
		function getParent(elem) {
		    return elem.parent || null;
		}
		/**
		 * Gets an elements siblings, including the element itself.
		 *
		 * Attempts to get the children through the element's parent first. If we don't
		 * have a parent (the element is a root node), we walk the element's `prev` &
		 * `next` to get all remaining nodes.
		 *
		 * @category Traversal
		 * @param elem Element to get the siblings of.
		 * @returns `elem`'s siblings, including `elem`.
		 */
		function getSiblings(elem) {
		    var _a, _b;
		    var parent = getParent(elem);
		    if (parent != null)
		        return getChildren(parent);
		    var siblings = [elem];
		    var prev = elem.prev, next = elem.next;
		    while (prev != null) {
		        siblings.unshift(prev);
		        (_a = prev, prev = _a.prev);
		    }
		    while (next != null) {
		        siblings.push(next);
		        (_b = next, next = _b.next);
		    }
		    return siblings;
		}
		/**
		 * Gets an attribute from an element.
		 *
		 * @category Traversal
		 * @param elem Element to check.
		 * @param name Attribute name to retrieve.
		 * @returns The element's attribute value, or `undefined`.
		 */
		function getAttributeValue(elem, name) {
		    var _a;
		    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
		}
		/**
		 * Checks whether an element has an attribute.
		 *
		 * @category Traversal
		 * @param elem Element to check.
		 * @param name Attribute name to look for.
		 * @returns Returns whether `elem` has the attribute `name`.
		 */
		function hasAttrib(elem, name) {
		    return (elem.attribs != null &&
		        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
		        elem.attribs[name] != null);
		}
		/**
		 * Get the tag name of an element.
		 *
		 * @category Traversal
		 * @param elem The element to get the name for.
		 * @returns The tag name of `elem`.
		 */
		function getName(elem) {
		    return elem.name;
		}
		/**
		 * Returns the next element sibling of a node.
		 *
		 * @category Traversal
		 * @param elem The element to get the next sibling of.
		 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
		 * sibling.
		 */
		function nextElementSibling(elem) {
		    var _a;
		    var next = elem.next;
		    while (next !== null && !(0, domhandler_1.isTag)(next))
		        (_a = next, next = _a.next);
		    return next;
		}
		/**
		 * Returns the previous element sibling of a node.
		 *
		 * @category Traversal
		 * @param elem The element to get the previous sibling of.
		 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
		 * previous sibling.
		 */
		function prevElementSibling(elem) {
		    var _a;
		    var prev = elem.prev;
		    while (prev !== null && !(0, domhandler_1.isTag)(prev))
		        (_a = prev, prev = _a.prev);
		    return prev;
		}
		
		return traversal;
	}

	var manipulation = {};

	var hasRequiredManipulation;

	function requireManipulation () {
		if (hasRequiredManipulation) return manipulation;
		hasRequiredManipulation = 1;
		Object.defineProperty(manipulation, "__esModule", { value: true });
		manipulation.removeElement = removeElement;
		manipulation.replaceElement = replaceElement;
		manipulation.appendChild = appendChild;
		manipulation.append = append;
		manipulation.prependChild = prependChild;
		manipulation.prepend = prepend;
		/**
		 * Remove an element from the dom
		 *
		 * @category Manipulation
		 * @param elem The element to be removed
		 */
		function removeElement(elem) {
		    if (elem.prev)
		        elem.prev.next = elem.next;
		    if (elem.next)
		        elem.next.prev = elem.prev;
		    if (elem.parent) {
		        var childs = elem.parent.children;
		        var childsIndex = childs.lastIndexOf(elem);
		        if (childsIndex >= 0) {
		            childs.splice(childsIndex, 1);
		        }
		    }
		    elem.next = null;
		    elem.prev = null;
		    elem.parent = null;
		}
		/**
		 * Replace an element in the dom
		 *
		 * @category Manipulation
		 * @param elem The element to be replaced
		 * @param replacement The element to be added
		 */
		function replaceElement(elem, replacement) {
		    var prev = (replacement.prev = elem.prev);
		    if (prev) {
		        prev.next = replacement;
		    }
		    var next = (replacement.next = elem.next);
		    if (next) {
		        next.prev = replacement;
		    }
		    var parent = (replacement.parent = elem.parent);
		    if (parent) {
		        var childs = parent.children;
		        childs[childs.lastIndexOf(elem)] = replacement;
		        elem.parent = null;
		    }
		}
		/**
		 * Append a child to an element.
		 *
		 * @category Manipulation
		 * @param parent The element to append to.
		 * @param child The element to be added as a child.
		 */
		function appendChild(parent, child) {
		    removeElement(child);
		    child.next = null;
		    child.parent = parent;
		    if (parent.children.push(child) > 1) {
		        var sibling = parent.children[parent.children.length - 2];
		        sibling.next = child;
		        child.prev = sibling;
		    }
		    else {
		        child.prev = null;
		    }
		}
		/**
		 * Append an element after another.
		 *
		 * @category Manipulation
		 * @param elem The element to append after.
		 * @param next The element be added.
		 */
		function append(elem, next) {
		    removeElement(next);
		    var parent = elem.parent;
		    var currNext = elem.next;
		    next.next = currNext;
		    next.prev = elem;
		    elem.next = next;
		    next.parent = parent;
		    if (currNext) {
		        currNext.prev = next;
		        if (parent) {
		            var childs = parent.children;
		            childs.splice(childs.lastIndexOf(currNext), 0, next);
		        }
		    }
		    else if (parent) {
		        parent.children.push(next);
		    }
		}
		/**
		 * Prepend a child to an element.
		 *
		 * @category Manipulation
		 * @param parent The element to prepend before.
		 * @param child The element to be added as a child.
		 */
		function prependChild(parent, child) {
		    removeElement(child);
		    child.parent = parent;
		    child.prev = null;
		    if (parent.children.unshift(child) !== 1) {
		        var sibling = parent.children[1];
		        sibling.prev = child;
		        child.next = sibling;
		    }
		    else {
		        child.next = null;
		    }
		}
		/**
		 * Prepend an element before another.
		 *
		 * @category Manipulation
		 * @param elem The element to prepend before.
		 * @param prev The element be added.
		 */
		function prepend(elem, prev) {
		    removeElement(prev);
		    var parent = elem.parent;
		    if (parent) {
		        var childs = parent.children;
		        childs.splice(childs.indexOf(elem), 0, prev);
		    }
		    if (elem.prev) {
		        elem.prev.next = prev;
		    }
		    prev.parent = parent;
		    prev.prev = elem.prev;
		    prev.next = elem;
		    elem.prev = prev;
		}
		
		return manipulation;
	}

	var querying = {};

	var hasRequiredQuerying;

	function requireQuerying () {
		if (hasRequiredQuerying) return querying;
		hasRequiredQuerying = 1;
		Object.defineProperty(querying, "__esModule", { value: true });
		querying.filter = filter;
		querying.find = find;
		querying.findOneChild = findOneChild;
		querying.findOne = findOne;
		querying.existsOne = existsOne;
		querying.findAll = findAll;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		/**
		 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param node Node to search. Will be included in the result set if it matches.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes passing `test`.
		 */
		function filter(test, node, recurse, limit) {
		    if (recurse === void 0) { recurse = true; }
		    if (limit === void 0) { limit = Infinity; }
		    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
		}
		/**
		 * Search an array of nodes and their children for nodes passing a test function.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param nodes Array of nodes to search.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes passing `test`.
		 */
		function find(test, nodes, recurse, limit) {
		    var result = [];
		    /** Stack of the arrays we are looking at. */
		    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
		    /** Stack of the indices within the arrays. */
		    var indexStack = [0];
		    for (;;) {
		        // First, check if the current array has any more elements to look at.
		        if (indexStack[0] >= nodeStack[0].length) {
		            // If we have no more arrays to look at, we are done.
		            if (indexStack.length === 1) {
		                return result;
		            }
		            // Otherwise, remove the current array from the stack.
		            nodeStack.shift();
		            indexStack.shift();
		            // Loop back to the start to continue with the next array.
		            continue;
		        }
		        var elem = nodeStack[0][indexStack[0]++];
		        if (test(elem)) {
		            result.push(elem);
		            if (--limit <= 0)
		                return result;
		        }
		        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
		            /*
		             * Add the children to the stack. We are depth-first, so this is
		             * the next array we look at.
		             */
		            indexStack.unshift(0);
		            nodeStack.unshift(elem.children);
		        }
		    }
		}
		/**
		 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param nodes Array of nodes to search.
		 * @returns The first node in the array that passes `test`.
		 * @deprecated Use `Array.prototype.find` directly.
		 */
		function findOneChild(test, nodes) {
		    return nodes.find(test);
		}
		/**
		 * Finds one element in a tree that passes a test.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param nodes Node or array of nodes to search.
		 * @param recurse Also consider child nodes.
		 * @returns The first node that passes `test`.
		 */
		function findOne(test, nodes, recurse) {
		    if (recurse === void 0) { recurse = true; }
		    var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
		    for (var i = 0; i < searchedNodes.length; i++) {
		        var node = searchedNodes[i];
		        if ((0, domhandler_1.isTag)(node) && test(node)) {
		            return node;
		        }
		        if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {
		            var found = findOne(test, node.children, true);
		            if (found)
		                return found;
		        }
		    }
		    return null;
		}
		/**
		 * Checks if a tree of nodes contains at least one node passing a test.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param nodes Array of nodes to search.
		 * @returns Whether a tree of nodes contains at least one node passing the test.
		 */
		function existsOne(test, nodes) {
		    return (Array.isArray(nodes) ? nodes : [nodes]).some(function (node) {
		        return ((0, domhandler_1.isTag)(node) && test(node)) ||
		            ((0, domhandler_1.hasChildren)(node) && existsOne(test, node.children));
		    });
		}
		/**
		 * Search an array of nodes and their children for elements passing a test function.
		 *
		 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
		 *
		 * @category Querying
		 * @param test Function to test nodes on.
		 * @param nodes Array of nodes to search.
		 * @returns All nodes passing `test`.
		 */
		function findAll(test, nodes) {
		    var result = [];
		    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
		    var indexStack = [0];
		    for (;;) {
		        if (indexStack[0] >= nodeStack[0].length) {
		            if (nodeStack.length === 1) {
		                return result;
		            }
		            // Otherwise, remove the current array from the stack.
		            nodeStack.shift();
		            indexStack.shift();
		            // Loop back to the start to continue with the next array.
		            continue;
		        }
		        var elem = nodeStack[0][indexStack[0]++];
		        if ((0, domhandler_1.isTag)(elem) && test(elem))
		            result.push(elem);
		        if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
		            indexStack.unshift(0);
		            nodeStack.unshift(elem.children);
		        }
		    }
		}
		
		return querying;
	}

	var legacy = {};

	var hasRequiredLegacy;

	function requireLegacy () {
		if (hasRequiredLegacy) return legacy;
		hasRequiredLegacy = 1;
		Object.defineProperty(legacy, "__esModule", { value: true });
		legacy.testElement = testElement;
		legacy.getElements = getElements;
		legacy.getElementById = getElementById;
		legacy.getElementsByTagName = getElementsByTagName;
		legacy.getElementsByClassName = getElementsByClassName;
		legacy.getElementsByTagType = getElementsByTagType;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		var querying_js_1 = /*@__PURE__*/ requireQuerying();
		/**
		 * A map of functions to check nodes against.
		 */
		var Checks = {
		    tag_name: function (name) {
		        if (typeof name === "function") {
		            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
		        }
		        else if (name === "*") {
		            return domhandler_1.isTag;
		        }
		        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
		    },
		    tag_type: function (type) {
		        if (typeof type === "function") {
		            return function (elem) { return type(elem.type); };
		        }
		        return function (elem) { return elem.type === type; };
		    },
		    tag_contains: function (data) {
		        if (typeof data === "function") {
		            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
		        }
		        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
		    },
		};
		/**
		 * Returns a function to check whether a node has an attribute with a particular
		 * value.
		 *
		 * @param attrib Attribute to check.
		 * @param value Attribute value to look for.
		 * @returns A function to check whether the a node has an attribute with a
		 *   particular value.
		 */
		function getAttribCheck(attrib, value) {
		    if (typeof value === "function") {
		        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
		    }
		    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
		}
		/**
		 * Returns a function that returns `true` if either of the input functions
		 * returns `true` for a node.
		 *
		 * @param a First function to combine.
		 * @param b Second function to combine.
		 * @returns A function taking a node and returning `true` if either of the input
		 *   functions returns `true` for the node.
		 */
		function combineFuncs(a, b) {
		    return function (elem) { return a(elem) || b(elem); };
		}
		/**
		 * Returns a function that executes all checks in `options` and returns `true`
		 * if any of them match a node.
		 *
		 * @param options An object describing nodes to look for.
		 * @returns A function that executes all checks in `options` and returns `true`
		 *   if any of them match a node.
		 */
		function compileTest(options) {
		    var funcs = Object.keys(options).map(function (key) {
		        var value = options[key];
		        return Object.prototype.hasOwnProperty.call(Checks, key)
		            ? Checks[key](value)
		            : getAttribCheck(key, value);
		    });
		    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
		}
		/**
		 * Checks whether a node matches the description in `options`.
		 *
		 * @category Legacy Query Functions
		 * @param options An object describing nodes to look for.
		 * @param node The element to test.
		 * @returns Whether the element matches the description in `options`.
		 */
		function testElement(options, node) {
		    var test = compileTest(options);
		    return test ? test(node) : true;
		}
		/**
		 * Returns all nodes that match `options`.
		 *
		 * @category Legacy Query Functions
		 * @param options An object describing nodes to look for.
		 * @param nodes Nodes to search through.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes that match `options`.
		 */
		function getElements(options, nodes, recurse, limit) {
		    if (limit === void 0) { limit = Infinity; }
		    var test = compileTest(options);
		    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
		}
		/**
		 * Returns the node with the supplied ID.
		 *
		 * @category Legacy Query Functions
		 * @param id The unique ID attribute value to look for.
		 * @param nodes Nodes to search through.
		 * @param recurse Also consider child nodes.
		 * @returns The node with the supplied ID.
		 */
		function getElementById(id, nodes, recurse) {
		    if (recurse === void 0) { recurse = true; }
		    if (!Array.isArray(nodes))
		        nodes = [nodes];
		    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
		}
		/**
		 * Returns all nodes with the supplied `tagName`.
		 *
		 * @category Legacy Query Functions
		 * @param tagName Tag name to search for.
		 * @param nodes Nodes to search through.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes with the supplied `tagName`.
		 */
		function getElementsByTagName(tagName, nodes, recurse, limit) {
		    if (recurse === void 0) { recurse = true; }
		    if (limit === void 0) { limit = Infinity; }
		    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
		}
		/**
		 * Returns all nodes with the supplied `className`.
		 *
		 * @category Legacy Query Functions
		 * @param className Class name to search for.
		 * @param nodes Nodes to search through.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes with the supplied `className`.
		 */
		function getElementsByClassName(className, nodes, recurse, limit) {
		    if (recurse === void 0) { recurse = true; }
		    if (limit === void 0) { limit = Infinity; }
		    return (0, querying_js_1.filter)(getAttribCheck("class", className), nodes, recurse, limit);
		}
		/**
		 * Returns all nodes with the supplied `type`.
		 *
		 * @category Legacy Query Functions
		 * @param type Element type to look for.
		 * @param nodes Nodes to search through.
		 * @param recurse Also consider child nodes.
		 * @param limit Maximum number of nodes to return.
		 * @returns All nodes with the supplied `type`.
		 */
		function getElementsByTagType(type, nodes, recurse, limit) {
		    if (recurse === void 0) { recurse = true; }
		    if (limit === void 0) { limit = Infinity; }
		    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
		}
		
		return legacy;
	}

	var helpers = {};

	var hasRequiredHelpers;

	function requireHelpers () {
		if (hasRequiredHelpers) return helpers;
		hasRequiredHelpers = 1;
		Object.defineProperty(helpers, "__esModule", { value: true });
		helpers.DocumentPosition = void 0;
		helpers.removeSubsets = removeSubsets;
		helpers.compareDocumentPosition = compareDocumentPosition;
		helpers.uniqueSort = uniqueSort;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		/**
		 * Given an array of nodes, remove any member that is contained by another
		 * member.
		 *
		 * @category Helpers
		 * @param nodes Nodes to filter.
		 * @returns Remaining nodes that aren't contained by other nodes.
		 */
		function removeSubsets(nodes) {
		    var idx = nodes.length;
		    /*
		     * Check if each node (or one of its ancestors) is already contained in the
		     * array.
		     */
		    while (--idx >= 0) {
		        var node = nodes[idx];
		        /*
		         * Remove the node if it is not unique.
		         * We are going through the array from the end, so we only
		         * have to check nodes that preceed the node under consideration in the array.
		         */
		        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
		            nodes.splice(idx, 1);
		            continue;
		        }
		        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
		            if (nodes.includes(ancestor)) {
		                nodes.splice(idx, 1);
		                break;
		            }
		        }
		    }
		    return nodes;
		}
		/**
		 * @category Helpers
		 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
		 */
		var DocumentPosition;
		(function (DocumentPosition) {
		    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
		    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
		    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
		    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
		    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
		})(DocumentPosition || (helpers.DocumentPosition = DocumentPosition = {}));
		/**
		 * Compare the position of one node against another node in any other document,
		 * returning a bitmask with the values from {@link DocumentPosition}.
		 *
		 * Document order:
		 * > There is an ordering, document order, defined on all the nodes in the
		 * > document corresponding to the order in which the first character of the
		 * > XML representation of each node occurs in the XML representation of the
		 * > document after expansion of general entities. Thus, the document element
		 * > node will be the first node. Element nodes occur before their children.
		 * > Thus, document order orders element nodes in order of the occurrence of
		 * > their start-tag in the XML (after expansion of entities). The attribute
		 * > nodes of an element occur after the element and before its children. The
		 * > relative order of attribute nodes is implementation-dependent.
		 *
		 * Source:
		 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
		 *
		 * @category Helpers
		 * @param nodeA The first node to use in the comparison
		 * @param nodeB The second node to use in the comparison
		 * @returns A bitmask describing the input nodes' relative position.
		 *
		 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
		 * a description of these values.
		 */
		function compareDocumentPosition(nodeA, nodeB) {
		    var aParents = [];
		    var bParents = [];
		    if (nodeA === nodeB) {
		        return 0;
		    }
		    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
		    while (current) {
		        aParents.unshift(current);
		        current = current.parent;
		    }
		    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
		    while (current) {
		        bParents.unshift(current);
		        current = current.parent;
		    }
		    var maxIdx = Math.min(aParents.length, bParents.length);
		    var idx = 0;
		    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
		        idx++;
		    }
		    if (idx === 0) {
		        return DocumentPosition.DISCONNECTED;
		    }
		    var sharedParent = aParents[idx - 1];
		    var siblings = sharedParent.children;
		    var aSibling = aParents[idx];
		    var bSibling = bParents[idx];
		    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		        if (sharedParent === nodeB) {
		            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
		        }
		        return DocumentPosition.FOLLOWING;
		    }
		    if (sharedParent === nodeA) {
		        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
		    }
		    return DocumentPosition.PRECEDING;
		}
		/**
		 * Sort an array of nodes based on their relative position in the document,
		 * removing any duplicate nodes. If the array contains nodes that do not belong
		 * to the same document, sort order is unspecified.
		 *
		 * @category Helpers
		 * @param nodes Array of DOM nodes.
		 * @returns Collection of unique nodes, sorted in document order.
		 */
		function uniqueSort(nodes) {
		    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
		    nodes.sort(function (a, b) {
		        var relative = compareDocumentPosition(a, b);
		        if (relative & DocumentPosition.PRECEDING) {
		            return -1;
		        }
		        else if (relative & DocumentPosition.FOLLOWING) {
		            return 1;
		        }
		        return 0;
		    });
		    return nodes;
		}
		
		return helpers;
	}

	var feeds = {};

	var hasRequiredFeeds;

	function requireFeeds () {
		if (hasRequiredFeeds) return feeds;
		hasRequiredFeeds = 1;
		Object.defineProperty(feeds, "__esModule", { value: true });
		feeds.getFeed = getFeed;
		var stringify_js_1 = /*@__PURE__*/ requireStringify();
		var legacy_js_1 = /*@__PURE__*/ requireLegacy();
		/**
		 * Get the feed object from the root of a DOM tree.
		 *
		 * @category Feeds
		 * @param doc - The DOM to to extract the feed from.
		 * @returns The feed.
		 */
		function getFeed(doc) {
		    var feedRoot = getOneElement(isValidFeed, doc);
		    return !feedRoot
		        ? null
		        : feedRoot.name === "feed"
		            ? getAtomFeed(feedRoot)
		            : getRssFeed(feedRoot);
		}
		/**
		 * Parse an Atom feed.
		 *
		 * @param feedRoot The root of the feed.
		 * @returns The parsed feed.
		 */
		function getAtomFeed(feedRoot) {
		    var _a;
		    var childs = feedRoot.children;
		    var feed = {
		        type: "atom",
		        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function (item) {
		            var _a;
		            var children = item.children;
		            var entry = { media: getMediaElements(children) };
		            addConditionally(entry, "id", "id", children);
		            addConditionally(entry, "title", "title", children);
		            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
		            if (href) {
		                entry.link = href;
		            }
		            var description = fetch("summary", children) || fetch("content", children);
		            if (description) {
		                entry.description = description;
		            }
		            var pubDate = fetch("updated", children);
		            if (pubDate) {
		                entry.pubDate = new Date(pubDate);
		            }
		            return entry;
		        }),
		    };
		    addConditionally(feed, "id", "id", childs);
		    addConditionally(feed, "title", "title", childs);
		    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
		    if (href) {
		        feed.link = href;
		    }
		    addConditionally(feed, "description", "subtitle", childs);
		    var updated = fetch("updated", childs);
		    if (updated) {
		        feed.updated = new Date(updated);
		    }
		    addConditionally(feed, "author", "email", childs, true);
		    return feed;
		}
		/**
		 * Parse a RSS feed.
		 *
		 * @param feedRoot The root of the feed.
		 * @returns The parsed feed.
		 */
		function getRssFeed(feedRoot) {
		    var _a, _b;
		    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
		    var feed = {
		        type: feedRoot.name.substr(0, 3),
		        id: "",
		        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
		            var children = item.children;
		            var entry = { media: getMediaElements(children) };
		            addConditionally(entry, "id", "guid", children);
		            addConditionally(entry, "title", "title", children);
		            addConditionally(entry, "link", "link", children);
		            addConditionally(entry, "description", "description", children);
		            var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
		            if (pubDate)
		                entry.pubDate = new Date(pubDate);
		            return entry;
		        }),
		    };
		    addConditionally(feed, "title", "title", childs);
		    addConditionally(feed, "link", "link", childs);
		    addConditionally(feed, "description", "description", childs);
		    var updated = fetch("lastBuildDate", childs);
		    if (updated) {
		        feed.updated = new Date(updated);
		    }
		    addConditionally(feed, "author", "managingEditor", childs, true);
		    return feed;
		}
		var MEDIA_KEYS_STRING = ["url", "type", "lang"];
		var MEDIA_KEYS_INT = [
		    "fileSize",
		    "bitrate",
		    "framerate",
		    "samplingrate",
		    "channels",
		    "duration",
		    "height",
		    "width",
		];
		/**
		 * Get all media elements of a feed item.
		 *
		 * @param where Nodes to search in.
		 * @returns Media elements.
		 */
		function getMediaElements(where) {
		    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function (elem) {
		        var attribs = elem.attribs;
		        var media = {
		            medium: attribs["medium"],
		            isDefault: !!attribs["isDefault"],
		        };
		        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
		            var attrib = MEDIA_KEYS_STRING_1[_i];
		            if (attribs[attrib]) {
		                media[attrib] = attribs[attrib];
		            }
		        }
		        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
		            var attrib = MEDIA_KEYS_INT_1[_a];
		            if (attribs[attrib]) {
		                media[attrib] = parseInt(attribs[attrib], 10);
		            }
		        }
		        if (attribs["expression"]) {
		            media.expression = attribs["expression"];
		        }
		        return media;
		    });
		}
		/**
		 * Get one element by tag name.
		 *
		 * @param tagName Tag name to look for
		 * @param node Node to search in
		 * @returns The element or null
		 */
		function getOneElement(tagName, node) {
		    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
		}
		/**
		 * Get the text content of an element with a certain tag name.
		 *
		 * @param tagName Tag name to look for.
		 * @param where Node to search in.
		 * @param recurse Whether to recurse into child nodes.
		 * @returns The text content of the element.
		 */
		function fetch(tagName, where, recurse) {
		    if (recurse === void 0) { recurse = false; }
		    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
		}
		/**
		 * Adds a property to an object if it has a value.
		 *
		 * @param obj Object to be extended
		 * @param prop Property name
		 * @param tagName Tag name that contains the conditionally added property
		 * @param where Element to search for the property
		 * @param recurse Whether to recurse into child nodes.
		 */
		function addConditionally(obj, prop, tagName, where, recurse) {
		    if (recurse === void 0) { recurse = false; }
		    var val = fetch(tagName, where, recurse);
		    if (val)
		        obj[prop] = val;
		}
		/**
		 * Checks if an element is a feed root node.
		 *
		 * @param value The name of the element to check.
		 * @returns Whether an element is a feed root node.
		 */
		function isValidFeed(value) {
		    return value === "rss" || value === "feed" || value === "rdf:RDF";
		}
		
		return feeds;
	}

	var hasRequiredLib$3;

	function requireLib$3 () {
		if (hasRequiredLib$3) return lib$3;
		hasRequiredLib$3 = 1;
		(function (exports) {
			var __createBinding = (lib$3 && lib$3.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (lib$3 && lib$3.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
			__exportStar(/*@__PURE__*/ requireStringify(), exports);
			__exportStar(/*@__PURE__*/ requireTraversal(), exports);
			__exportStar(/*@__PURE__*/ requireManipulation(), exports);
			__exportStar(/*@__PURE__*/ requireQuerying(), exports);
			__exportStar(/*@__PURE__*/ requireLegacy(), exports);
			__exportStar(/*@__PURE__*/ requireHelpers(), exports);
			__exportStar(/*@__PURE__*/ requireFeeds(), exports);
			/** @deprecated Use these methods from `domhandler` directly. */
			var domhandler_1 = /*@__PURE__*/ requireLib$6();
			Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
			Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
			Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
			Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
			Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
			Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
			
		} (lib$3));
		return lib$3;
	}

	var hasRequiredCommonjs;

	function requireCommonjs () {
		if (hasRequiredCommonjs) return commonjs;
		hasRequiredCommonjs = 1;
		(function (exports) {
			var __createBinding = (commonjs && commonjs.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __setModuleDefault = (commonjs && commonjs.__setModuleDefault) || (Object.create ? (function(o, v) {
			    Object.defineProperty(o, "default", { enumerable: true, value: v });
			}) : function(o, v) {
			    o["default"] = v;
			});
			var __importStar = (commonjs && commonjs.__importStar) || (function () {
			    var ownKeys = function(o) {
			        ownKeys = Object.getOwnPropertyNames || function (o) {
			            var ar = [];
			            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
			            return ar;
			        };
			        return ownKeys(o);
			    };
			    return function (mod) {
			        if (mod && mod.__esModule) return mod;
			        var result = {};
			        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			        __setModuleDefault(result, mod);
			        return result;
			    };
			})();
			var __importDefault = (commonjs && commonjs.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.DomUtils = exports.getFeed = exports.ElementType = exports.QuoteType = exports.Tokenizer = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
			exports.parseDocument = parseDocument;
			exports.parseDOM = parseDOM;
			exports.createDocumentStream = createDocumentStream;
			exports.createDomStream = createDomStream;
			exports.parseFeed = parseFeed;
			const Parser_js_1 = requireParser();
			var Parser_js_2 = requireParser();
			Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_js_2.Parser; } });
			const domhandler_1 = /*@__PURE__*/ requireLib$6();
			var domhandler_2 = /*@__PURE__*/ requireLib$6();
			Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });
			// Old name for DomHandler
			Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });
			// Helper methods
			/**
			 * Parses the data, returns the resulting document.
			 *
			 * @param data The data that should be parsed.
			 * @param options Optional options for the parser and DOM handler.
			 */
			function parseDocument(data, options) {
			    const handler = new domhandler_1.DomHandler(undefined, options);
			    new Parser_js_1.Parser(handler, options).end(data);
			    return handler.root;
			}
			/**
			 * Parses data, returns an array of the root nodes.
			 *
			 * Note that the root nodes still have a `Document` node as their parent.
			 * Use `parseDocument` to get the `Document` node instead.
			 *
			 * @param data The data that should be parsed.
			 * @param options Optional options for the parser and DOM handler.
			 * @deprecated Use `parseDocument` instead.
			 */
			function parseDOM(data, options) {
			    return parseDocument(data, options).children;
			}
			/**
			 * Creates a parser instance, with an attached DOM handler.
			 *
			 * @param callback A callback that will be called once parsing has been completed, with the resulting document.
			 * @param options Optional options for the parser and DOM handler.
			 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
			 */
			function createDocumentStream(callback, options, elementCallback) {
			    const handler = new domhandler_1.DomHandler((error) => callback(error, handler.root), options, elementCallback);
			    return new Parser_js_1.Parser(handler, options);
			}
			/**
			 * Creates a parser instance, with an attached DOM handler.
			 *
			 * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.
			 * @param options Optional options for the parser and DOM handler.
			 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
			 * @deprecated Use `createDocumentStream` instead.
			 */
			function createDomStream(callback, options, elementCallback) {
			    const handler = new domhandler_1.DomHandler(callback, options, elementCallback);
			    return new Parser_js_1.Parser(handler, options);
			}
			var Tokenizer_js_1 = requireTokenizer();
			Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } });
			Object.defineProperty(exports, "QuoteType", { enumerable: true, get: function () { return Tokenizer_js_1.QuoteType; } });
			/*
			 * All of the following exports exist for backwards-compatibility.
			 * They should probably be removed eventually.
			 */
			exports.ElementType = __importStar(/*@__PURE__*/ requireLib$7());
			const domutils_1 = /*@__PURE__*/ requireLib$3();
			var domutils_2 = /*@__PURE__*/ requireLib$3();
			Object.defineProperty(exports, "getFeed", { enumerable: true, get: function () { return domutils_2.getFeed; } });
			const parseFeedDefaultOptions = { xmlMode: true };
			/**
			 * Parse a feed.
			 *
			 * @param feed The feed that should be parsed, as a string.
			 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
			 */
			function parseFeed(feed, options = parseFeedDefaultOptions) {
			    return (0, domutils_1.getFeed)(parseDOM(feed, options));
			}
			exports.DomUtils = __importStar(/*@__PURE__*/ requireLib$3());
			
		} (commonjs));
		return commonjs;
	}

	var utilities$2 = {};

	var hasRequiredUtilities$2;

	function requireUtilities$2 () {
		if (hasRequiredUtilities$2) return utilities$2;
		hasRequiredUtilities$2 = 1;
		Object.defineProperty(utilities$2, "__esModule", { value: true });
		utilities$2.unsetRootParent = unsetRootParent;
		/**
		 * Sets root parent to null.
		 *
		 * @param nodes - Nodes.
		 * @returns - Nodes.
		 */
		function unsetRootParent(nodes) {
		    var index = 0;
		    var nodesLength = nodes.length;
		    for (; index < nodesLength; index++) {
		        var node = nodes[index];
		        node.parent = null;
		    }
		    return nodes;
		}
		
		return utilities$2;
	}

	var hasRequiredHtmlToDom;

	function requireHtmlToDom () {
		if (hasRequiredHtmlToDom) return htmlToDom;
		hasRequiredHtmlToDom = 1;
		Object.defineProperty(htmlToDom, "__esModule", { value: true });
		htmlToDom.default = HTMLDOMParser;
		var domhandler_1 = /*@__PURE__*/ requireLib$6();
		var htmlparser2_1 = /*@__PURE__*/ requireCommonjs();
		var utilities_1 = requireUtilities$2();
		/**
		 * Parses HTML string to DOM nodes in Node.js.
		 *
		 * This is the same method as `require('htmlparser2').parseDOM`
		 *
		 * @see https://github.com/fb55/htmlparser2/blob/v9.0.0/src/index.ts#L44-L46
		 * @see https://github.com/fb55/domhandler/tree/v5.0.3#readme
		 *
		 * @param html - HTML markup.
		 * @param options - Parser options.
		 * @returns - DOM nodes.
		 */
		function HTMLDOMParser(html, options) {
		    if (typeof html !== 'string') {
		        throw new TypeError('First argument must be a string.');
		    }
		    if (!html) {
		        return [];
		    }
		    var handler = new domhandler_1.DomHandler(undefined, options);
		    new htmlparser2_1.Parser(handler, options).end(html);
		    return (0, utilities_1.unsetRootParent)(handler.dom);
		}
		
		return htmlToDom;
	}

	var types = {};

	var hasRequiredTypes;

	function requireTypes () {
		if (hasRequiredTypes) return types;
		hasRequiredTypes = 1;
		Object.defineProperty(types, "__esModule", { value: true });
		
		return types;
	}

	var hasRequiredLib$2;

	function requireLib$2 () {
		if (hasRequiredLib$2) return lib$6;
		hasRequiredLib$2 = 1;
		(function (exports) {
			var __createBinding = (lib$6 && lib$6.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (lib$6 && lib$6.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			var __importDefault = (lib$6 && lib$6.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.default = void 0;
			/**
			 * When running on Node.js, use the server parser.
			 * When bundling for the browser, use the client parser.
			 *
			 * @see https://github.com/substack/node-browserify#browser-field
			 */
			var html_to_dom_1 = requireHtmlToDom();
			Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(html_to_dom_1).default; } });
			__exportStar(requireTypes(), exports);
			
		} (lib$6));
		return lib$6;
	}

	var attributesToProps = {};

	var lib = {};

	var possibleStandardNamesOptimized = {};

	var hasRequiredPossibleStandardNamesOptimized;

	function requirePossibleStandardNamesOptimized () {
		if (hasRequiredPossibleStandardNamesOptimized) return possibleStandardNamesOptimized;
		hasRequiredPossibleStandardNamesOptimized = 1;
		// An attribute in which the DOM/SVG standard name is the same as the React prop name (e.g., 'accept').
		var SAME = 0;
		possibleStandardNamesOptimized.SAME = SAME;

		// An attribute in which the React prop name is the camelcased version of the DOM/SVG standard name (e.g., 'acceptCharset').
		var CAMELCASE = 1;
		possibleStandardNamesOptimized.CAMELCASE = CAMELCASE;

		possibleStandardNamesOptimized.possibleStandardNames = {
		  accept: 0,
		  acceptCharset: 1,
		  'accept-charset': 'acceptCharset',
		  accessKey: 1,
		  action: 0,
		  allowFullScreen: 1,
		  alt: 0,
		  as: 0,
		  async: 0,
		  autoCapitalize: 1,
		  autoComplete: 1,
		  autoCorrect: 1,
		  autoFocus: 1,
		  autoPlay: 1,
		  autoSave: 1,
		  capture: 0,
		  cellPadding: 1,
		  cellSpacing: 1,
		  challenge: 0,
		  charSet: 1,
		  checked: 0,
		  children: 0,
		  cite: 0,
		  class: 'className',
		  classID: 1,
		  className: 1,
		  cols: 0,
		  colSpan: 1,
		  content: 0,
		  contentEditable: 1,
		  contextMenu: 1,
		  controls: 0,
		  controlsList: 1,
		  coords: 0,
		  crossOrigin: 1,
		  dangerouslySetInnerHTML: 1,
		  data: 0,
		  dateTime: 1,
		  default: 0,
		  defaultChecked: 1,
		  defaultValue: 1,
		  defer: 0,
		  dir: 0,
		  disabled: 0,
		  disablePictureInPicture: 1,
		  disableRemotePlayback: 1,
		  download: 0,
		  draggable: 0,
		  encType: 1,
		  enterKeyHint: 1,
		  for: 'htmlFor',
		  form: 0,
		  formMethod: 1,
		  formAction: 1,
		  formEncType: 1,
		  formNoValidate: 1,
		  formTarget: 1,
		  frameBorder: 1,
		  headers: 0,
		  height: 0,
		  hidden: 0,
		  high: 0,
		  href: 0,
		  hrefLang: 1,
		  htmlFor: 1,
		  httpEquiv: 1,
		  'http-equiv': 'httpEquiv',
		  icon: 0,
		  id: 0,
		  innerHTML: 1,
		  inputMode: 1,
		  integrity: 0,
		  is: 0,
		  itemID: 1,
		  itemProp: 1,
		  itemRef: 1,
		  itemScope: 1,
		  itemType: 1,
		  keyParams: 1,
		  keyType: 1,
		  kind: 0,
		  label: 0,
		  lang: 0,
		  list: 0,
		  loop: 0,
		  low: 0,
		  manifest: 0,
		  marginWidth: 1,
		  marginHeight: 1,
		  max: 0,
		  maxLength: 1,
		  media: 0,
		  mediaGroup: 1,
		  method: 0,
		  min: 0,
		  minLength: 1,
		  multiple: 0,
		  muted: 0,
		  name: 0,
		  noModule: 1,
		  nonce: 0,
		  noValidate: 1,
		  open: 0,
		  optimum: 0,
		  pattern: 0,
		  placeholder: 0,
		  playsInline: 1,
		  poster: 0,
		  preload: 0,
		  profile: 0,
		  radioGroup: 1,
		  readOnly: 1,
		  referrerPolicy: 1,
		  rel: 0,
		  required: 0,
		  reversed: 0,
		  role: 0,
		  rows: 0,
		  rowSpan: 1,
		  sandbox: 0,
		  scope: 0,
		  scoped: 0,
		  scrolling: 0,
		  seamless: 0,
		  selected: 0,
		  shape: 0,
		  size: 0,
		  sizes: 0,
		  span: 0,
		  spellCheck: 1,
		  src: 0,
		  srcDoc: 1,
		  srcLang: 1,
		  srcSet: 1,
		  start: 0,
		  step: 0,
		  style: 0,
		  summary: 0,
		  tabIndex: 1,
		  target: 0,
		  title: 0,
		  type: 0,
		  useMap: 1,
		  value: 0,
		  width: 0,
		  wmode: 0,
		  wrap: 0,
		  about: 0,
		  accentHeight: 1,
		  'accent-height': 'accentHeight',
		  accumulate: 0,
		  additive: 0,
		  alignmentBaseline: 1,
		  'alignment-baseline': 'alignmentBaseline',
		  allowReorder: 1,
		  alphabetic: 0,
		  amplitude: 0,
		  arabicForm: 1,
		  'arabic-form': 'arabicForm',
		  ascent: 0,
		  attributeName: 1,
		  attributeType: 1,
		  autoReverse: 1,
		  azimuth: 0,
		  baseFrequency: 1,
		  baselineShift: 1,
		  'baseline-shift': 'baselineShift',
		  baseProfile: 1,
		  bbox: 0,
		  begin: 0,
		  bias: 0,
		  by: 0,
		  calcMode: 1,
		  capHeight: 1,
		  'cap-height': 'capHeight',
		  clip: 0,
		  clipPath: 1,
		  'clip-path': 'clipPath',
		  clipPathUnits: 1,
		  clipRule: 1,
		  'clip-rule': 'clipRule',
		  color: 0,
		  colorInterpolation: 1,
		  'color-interpolation': 'colorInterpolation',
		  colorInterpolationFilters: 1,
		  'color-interpolation-filters': 'colorInterpolationFilters',
		  colorProfile: 1,
		  'color-profile': 'colorProfile',
		  colorRendering: 1,
		  'color-rendering': 'colorRendering',
		  contentScriptType: 1,
		  contentStyleType: 1,
		  cursor: 0,
		  cx: 0,
		  cy: 0,
		  d: 0,
		  datatype: 0,
		  decelerate: 0,
		  descent: 0,
		  diffuseConstant: 1,
		  direction: 0,
		  display: 0,
		  divisor: 0,
		  dominantBaseline: 1,
		  'dominant-baseline': 'dominantBaseline',
		  dur: 0,
		  dx: 0,
		  dy: 0,
		  edgeMode: 1,
		  elevation: 0,
		  enableBackground: 1,
		  'enable-background': 'enableBackground',
		  end: 0,
		  exponent: 0,
		  externalResourcesRequired: 1,
		  fill: 0,
		  fillOpacity: 1,
		  'fill-opacity': 'fillOpacity',
		  fillRule: 1,
		  'fill-rule': 'fillRule',
		  filter: 0,
		  filterRes: 1,
		  filterUnits: 1,
		  floodOpacity: 1,
		  'flood-opacity': 'floodOpacity',
		  floodColor: 1,
		  'flood-color': 'floodColor',
		  focusable: 0,
		  fontFamily: 1,
		  'font-family': 'fontFamily',
		  fontSize: 1,
		  'font-size': 'fontSize',
		  fontSizeAdjust: 1,
		  'font-size-adjust': 'fontSizeAdjust',
		  fontStretch: 1,
		  'font-stretch': 'fontStretch',
		  fontStyle: 1,
		  'font-style': 'fontStyle',
		  fontVariant: 1,
		  'font-variant': 'fontVariant',
		  fontWeight: 1,
		  'font-weight': 'fontWeight',
		  format: 0,
		  from: 0,
		  fx: 0,
		  fy: 0,
		  g1: 0,
		  g2: 0,
		  glyphName: 1,
		  'glyph-name': 'glyphName',
		  glyphOrientationHorizontal: 1,
		  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
		  glyphOrientationVertical: 1,
		  'glyph-orientation-vertical': 'glyphOrientationVertical',
		  glyphRef: 1,
		  gradientTransform: 1,
		  gradientUnits: 1,
		  hanging: 0,
		  horizAdvX: 1,
		  'horiz-adv-x': 'horizAdvX',
		  horizOriginX: 1,
		  'horiz-origin-x': 'horizOriginX',
		  ideographic: 0,
		  imageRendering: 1,
		  'image-rendering': 'imageRendering',
		  in2: 0,
		  in: 0,
		  inlist: 0,
		  intercept: 0,
		  k1: 0,
		  k2: 0,
		  k3: 0,
		  k4: 0,
		  k: 0,
		  kernelMatrix: 1,
		  kernelUnitLength: 1,
		  kerning: 0,
		  keyPoints: 1,
		  keySplines: 1,
		  keyTimes: 1,
		  lengthAdjust: 1,
		  letterSpacing: 1,
		  'letter-spacing': 'letterSpacing',
		  lightingColor: 1,
		  'lighting-color': 'lightingColor',
		  limitingConeAngle: 1,
		  local: 0,
		  markerEnd: 1,
		  'marker-end': 'markerEnd',
		  markerHeight: 1,
		  markerMid: 1,
		  'marker-mid': 'markerMid',
		  markerStart: 1,
		  'marker-start': 'markerStart',
		  markerUnits: 1,
		  markerWidth: 1,
		  mask: 0,
		  maskContentUnits: 1,
		  maskUnits: 1,
		  mathematical: 0,
		  mode: 0,
		  numOctaves: 1,
		  offset: 0,
		  opacity: 0,
		  operator: 0,
		  order: 0,
		  orient: 0,
		  orientation: 0,
		  origin: 0,
		  overflow: 0,
		  overlinePosition: 1,
		  'overline-position': 'overlinePosition',
		  overlineThickness: 1,
		  'overline-thickness': 'overlineThickness',
		  paintOrder: 1,
		  'paint-order': 'paintOrder',
		  panose1: 0,
		  'panose-1': 'panose1',
		  pathLength: 1,
		  patternContentUnits: 1,
		  patternTransform: 1,
		  patternUnits: 1,
		  pointerEvents: 1,
		  'pointer-events': 'pointerEvents',
		  points: 0,
		  pointsAtX: 1,
		  pointsAtY: 1,
		  pointsAtZ: 1,
		  prefix: 0,
		  preserveAlpha: 1,
		  preserveAspectRatio: 1,
		  primitiveUnits: 1,
		  property: 0,
		  r: 0,
		  radius: 0,
		  refX: 1,
		  refY: 1,
		  renderingIntent: 1,
		  'rendering-intent': 'renderingIntent',
		  repeatCount: 1,
		  repeatDur: 1,
		  requiredExtensions: 1,
		  requiredFeatures: 1,
		  resource: 0,
		  restart: 0,
		  result: 0,
		  results: 0,
		  rotate: 0,
		  rx: 0,
		  ry: 0,
		  scale: 0,
		  security: 0,
		  seed: 0,
		  shapeRendering: 1,
		  'shape-rendering': 'shapeRendering',
		  slope: 0,
		  spacing: 0,
		  specularConstant: 1,
		  specularExponent: 1,
		  speed: 0,
		  spreadMethod: 1,
		  startOffset: 1,
		  stdDeviation: 1,
		  stemh: 0,
		  stemv: 0,
		  stitchTiles: 1,
		  stopColor: 1,
		  'stop-color': 'stopColor',
		  stopOpacity: 1,
		  'stop-opacity': 'stopOpacity',
		  strikethroughPosition: 1,
		  'strikethrough-position': 'strikethroughPosition',
		  strikethroughThickness: 1,
		  'strikethrough-thickness': 'strikethroughThickness',
		  string: 0,
		  stroke: 0,
		  strokeDasharray: 1,
		  'stroke-dasharray': 'strokeDasharray',
		  strokeDashoffset: 1,
		  'stroke-dashoffset': 'strokeDashoffset',
		  strokeLinecap: 1,
		  'stroke-linecap': 'strokeLinecap',
		  strokeLinejoin: 1,
		  'stroke-linejoin': 'strokeLinejoin',
		  strokeMiterlimit: 1,
		  'stroke-miterlimit': 'strokeMiterlimit',
		  strokeWidth: 1,
		  'stroke-width': 'strokeWidth',
		  strokeOpacity: 1,
		  'stroke-opacity': 'strokeOpacity',
		  suppressContentEditableWarning: 1,
		  suppressHydrationWarning: 1,
		  surfaceScale: 1,
		  systemLanguage: 1,
		  tableValues: 1,
		  targetX: 1,
		  targetY: 1,
		  textAnchor: 1,
		  'text-anchor': 'textAnchor',
		  textDecoration: 1,
		  'text-decoration': 'textDecoration',
		  textLength: 1,
		  textRendering: 1,
		  'text-rendering': 'textRendering',
		  to: 0,
		  transform: 0,
		  typeof: 0,
		  u1: 0,
		  u2: 0,
		  underlinePosition: 1,
		  'underline-position': 'underlinePosition',
		  underlineThickness: 1,
		  'underline-thickness': 'underlineThickness',
		  unicode: 0,
		  unicodeBidi: 1,
		  'unicode-bidi': 'unicodeBidi',
		  unicodeRange: 1,
		  'unicode-range': 'unicodeRange',
		  unitsPerEm: 1,
		  'units-per-em': 'unitsPerEm',
		  unselectable: 0,
		  vAlphabetic: 1,
		  'v-alphabetic': 'vAlphabetic',
		  values: 0,
		  vectorEffect: 1,
		  'vector-effect': 'vectorEffect',
		  version: 0,
		  vertAdvY: 1,
		  'vert-adv-y': 'vertAdvY',
		  vertOriginX: 1,
		  'vert-origin-x': 'vertOriginX',
		  vertOriginY: 1,
		  'vert-origin-y': 'vertOriginY',
		  vHanging: 1,
		  'v-hanging': 'vHanging',
		  vIdeographic: 1,
		  'v-ideographic': 'vIdeographic',
		  viewBox: 1,
		  viewTarget: 1,
		  visibility: 0,
		  vMathematical: 1,
		  'v-mathematical': 'vMathematical',
		  vocab: 0,
		  widths: 0,
		  wordSpacing: 1,
		  'word-spacing': 'wordSpacing',
		  writingMode: 1,
		  'writing-mode': 'writingMode',
		  x1: 0,
		  x2: 0,
		  x: 0,
		  xChannelSelector: 1,
		  xHeight: 1,
		  'x-height': 'xHeight',
		  xlinkActuate: 1,
		  'xlink:actuate': 'xlinkActuate',
		  xlinkArcrole: 1,
		  'xlink:arcrole': 'xlinkArcrole',
		  xlinkHref: 1,
		  'xlink:href': 'xlinkHref',
		  xlinkRole: 1,
		  'xlink:role': 'xlinkRole',
		  xlinkShow: 1,
		  'xlink:show': 'xlinkShow',
		  xlinkTitle: 1,
		  'xlink:title': 'xlinkTitle',
		  xlinkType: 1,
		  'xlink:type': 'xlinkType',
		  xmlBase: 1,
		  'xml:base': 'xmlBase',
		  xmlLang: 1,
		  'xml:lang': 'xmlLang',
		  xmlns: 0,
		  'xml:space': 'xmlSpace',
		  xmlnsXlink: 1,
		  'xmlns:xlink': 'xmlnsXlink',
		  xmlSpace: 1,
		  y1: 0,
		  y2: 0,
		  y: 0,
		  yChannelSelector: 1,
		  z: 0,
		  zoomAndPan: 1
		};
		return possibleStandardNamesOptimized;
	}

	var hasRequiredLib$1;

	function requireLib$1 () {
		if (hasRequiredLib$1) return lib;
		hasRequiredLib$1 = 1;

		/**
		 * Copyright (c) Facebook, Inc. and its affiliates.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 * 
		 */




		// A reserved attribute.
		// It is handled by React separately and shouldn't be written to the DOM.
		const RESERVED = 0;

		// A simple string attribute.
		// Attributes that aren't in the filter are presumed to have this type.
		const STRING = 1;

		// A string attribute that accepts booleans in React. In HTML, these are called
		// "enumerated" attributes with "true" and "false" as possible values.
		// When true, it should be set to a "true" string.
		// When false, it should be set to a "false" string.
		const BOOLEANISH_STRING = 2;

		// A real boolean attribute.
		// When true, it should be present (set either to an empty string or its name).
		// When false, it should be omitted.
		const BOOLEAN = 3;

		// An attribute that can be used as a flag as well as with a value.
		// When true, it should be present (set either to an empty string or its name).
		// When false, it should be omitted.
		// For any other value, should be present with that value.
		const OVERLOADED_BOOLEAN = 4;

		// An attribute that must be numeric or parse as a numeric.
		// When falsy, it should be removed.
		const NUMERIC = 5;

		// An attribute that must be positive numeric or parse as a positive numeric.
		// When falsy, it should be removed.
		const POSITIVE_NUMERIC = 6;

		function getPropertyInfo(name) {
		  return properties.hasOwnProperty(name) ? properties[name] : null;
		}

		function PropertyInfoRecord(
		  name,
		  type,
		  mustUseProperty,
		  attributeName,
		  attributeNamespace,
		  sanitizeURL,
		  removeEmptyString,
		) {
		  this.acceptsBooleans =
		    type === BOOLEANISH_STRING ||
		    type === BOOLEAN ||
		    type === OVERLOADED_BOOLEAN;
		  this.attributeName = attributeName;
		  this.attributeNamespace = attributeNamespace;
		  this.mustUseProperty = mustUseProperty;
		  this.propertyName = name;
		  this.type = type;
		  this.sanitizeURL = sanitizeURL;
		  this.removeEmptyString = removeEmptyString;
		}

		// When adding attributes to this list, be sure to also add them to
		// the `possibleStandardNames` module to ensure casing and incorrect
		// name warnings.
		const properties = {};

		// These props are reserved by React. They shouldn't be written to the DOM.
		const reservedProps = [
		  'children',
		  'dangerouslySetInnerHTML',
		  // TODO: This prevents the assignment of defaultValue to regular
		  // elements (not just inputs). Now that ReactDOMInput assigns to the
		  // defaultValue property -- do we need this?
		  'defaultValue',
		  'defaultChecked',
		  'innerHTML',
		  'suppressContentEditableWarning',
		  'suppressHydrationWarning',
		  'style',
		];

		reservedProps.forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    RESERVED,
		    false, // mustUseProperty
		    name, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// A few React string attributes have a different name.
		// This is a mapping from React prop names to the attribute names.
		[
		  ['acceptCharset', 'accept-charset'],
		  ['className', 'class'],
		  ['htmlFor', 'for'],
		  ['httpEquiv', 'http-equiv'],
		].forEach(([name, attributeName]) => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    STRING,
		    false, // mustUseProperty
		    attributeName, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are "enumerated" HTML attributes that accept "true" and "false".
		// In React, we let users pass `true` and `false` even though technically
		// these aren't boolean attributes (they are coerced to strings).
		['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    BOOLEANISH_STRING,
		    false, // mustUseProperty
		    name.toLowerCase(), // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are "enumerated" SVG attributes that accept "true" and "false".
		// In React, we let users pass `true` and `false` even though technically
		// these aren't boolean attributes (they are coerced to strings).
		// Since these are SVG attributes, their attribute names are case-sensitive.
		[
		  'autoReverse',
		  'externalResourcesRequired',
		  'focusable',
		  'preserveAlpha',
		].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    BOOLEANISH_STRING,
		    false, // mustUseProperty
		    name, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are HTML boolean attributes.
		[
		  'allowFullScreen',
		  'async',
		  // Note: there is a special case that prevents it from being written to the DOM
		  // on the client side because the browsers are inconsistent. Instead we call focus().
		  'autoFocus',
		  'autoPlay',
		  'controls',
		  'default',
		  'defer',
		  'disabled',
		  'disablePictureInPicture',
		  'disableRemotePlayback',
		  'formNoValidate',
		  'hidden',
		  'loop',
		  'noModule',
		  'noValidate',
		  'open',
		  'playsInline',
		  'readOnly',
		  'required',
		  'reversed',
		  'scoped',
		  'seamless',
		  // Microdata
		  'itemScope',
		].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    BOOLEAN,
		    false, // mustUseProperty
		    name.toLowerCase(), // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are the few React props that we set as DOM properties
		// rather than attributes. These are all booleans.
		[
		  'checked',
		  // Note: `option.selected` is not updated if `select.multiple` is
		  // disabled with `removeAttribute`. We have special logic for handling this.
		  'multiple',
		  'muted',
		  'selected',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    BOOLEAN,
		    true, // mustUseProperty
		    name, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are HTML attributes that are "overloaded booleans": they behave like
		// booleans, but can also accept a string value.
		[
		  'capture',
		  'download',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    OVERLOADED_BOOLEAN,
		    false, // mustUseProperty
		    name, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are HTML attributes that must be positive numbers.
		[
		  'cols',
		  'rows',
		  'size',
		  'span',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    POSITIVE_NUMERIC,
		    false, // mustUseProperty
		    name, // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These are HTML attributes that must be numbers.
		['rowSpan', 'start'].forEach(name => {
		  properties[name] = new PropertyInfoRecord(
		    name,
		    NUMERIC,
		    false, // mustUseProperty
		    name.toLowerCase(), // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		const CAMELIZE = /[\-\:]([a-z])/g;
		const capitalize = token => token[1].toUpperCase();

		// This is a list of all SVG attributes that need special casing, namespacing,
		// or boolean value assignment. Regular attributes that just accept strings
		// and have the same names are omitted, just like in the HTML attribute filter.
		// Some of these attributes can be hard to find. This list was created by
		// scraping the MDN documentation.
		[
		  'accent-height',
		  'alignment-baseline',
		  'arabic-form',
		  'baseline-shift',
		  'cap-height',
		  'clip-path',
		  'clip-rule',
		  'color-interpolation',
		  'color-interpolation-filters',
		  'color-profile',
		  'color-rendering',
		  'dominant-baseline',
		  'enable-background',
		  'fill-opacity',
		  'fill-rule',
		  'flood-color',
		  'flood-opacity',
		  'font-family',
		  'font-size',
		  'font-size-adjust',
		  'font-stretch',
		  'font-style',
		  'font-variant',
		  'font-weight',
		  'glyph-name',
		  'glyph-orientation-horizontal',
		  'glyph-orientation-vertical',
		  'horiz-adv-x',
		  'horiz-origin-x',
		  'image-rendering',
		  'letter-spacing',
		  'lighting-color',
		  'marker-end',
		  'marker-mid',
		  'marker-start',
		  'overline-position',
		  'overline-thickness',
		  'paint-order',
		  'panose-1',
		  'pointer-events',
		  'rendering-intent',
		  'shape-rendering',
		  'stop-color',
		  'stop-opacity',
		  'strikethrough-position',
		  'strikethrough-thickness',
		  'stroke-dasharray',
		  'stroke-dashoffset',
		  'stroke-linecap',
		  'stroke-linejoin',
		  'stroke-miterlimit',
		  'stroke-opacity',
		  'stroke-width',
		  'text-anchor',
		  'text-decoration',
		  'text-rendering',
		  'underline-position',
		  'underline-thickness',
		  'unicode-bidi',
		  'unicode-range',
		  'units-per-em',
		  'v-alphabetic',
		  'v-hanging',
		  'v-ideographic',
		  'v-mathematical',
		  'vector-effect',
		  'vert-adv-y',
		  'vert-origin-x',
		  'vert-origin-y',
		  'word-spacing',
		  'writing-mode',
		  'xmlns:xlink',
		  'x-height',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(attributeName => {
		  const name = attributeName.replace(CAMELIZE, capitalize);
		  properties[name] = new PropertyInfoRecord(
		    name,
		    STRING,
		    false, // mustUseProperty
		    attributeName,
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// String SVG attributes with the xlink namespace.
		[
		  'xlink:actuate',
		  'xlink:arcrole',
		  'xlink:role',
		  'xlink:show',
		  'xlink:title',
		  'xlink:type',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(attributeName => {
		  const name = attributeName.replace(CAMELIZE, capitalize);
		  properties[name] = new PropertyInfoRecord(
		    name,
		    STRING,
		    false, // mustUseProperty
		    attributeName,
		    'http://www.w3.org/1999/xlink',
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// String SVG attributes with the xml namespace.
		[
		  'xml:base',
		  'xml:lang',
		  'xml:space',

		  // NOTE: if you add a camelCased prop to this list,
		  // you'll need to set attributeName to name.toLowerCase()
		  // instead in the assignment below.
		].forEach(attributeName => {
		  const name = attributeName.replace(CAMELIZE, capitalize);
		  properties[name] = new PropertyInfoRecord(
		    name,
		    STRING,
		    false, // mustUseProperty
		    attributeName,
		    'http://www.w3.org/XML/1998/namespace',
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These attribute exists both in HTML and SVG.
		// The attribute name is case-sensitive in SVG so we can't just use
		// the React name like we do for attributes that exist only in HTML.
		['tabIndex', 'crossOrigin'].forEach(attributeName => {
		  properties[attributeName] = new PropertyInfoRecord(
		    attributeName,
		    STRING,
		    false, // mustUseProperty
		    attributeName.toLowerCase(), // attributeName
		    null, // attributeNamespace
		    false, // sanitizeURL
		    false, // removeEmptyString
		  );
		});

		// These attributes accept URLs. These must not allow javascript: URLS.
		// These will also need to accept Trusted Types object in the future.
		const xlinkHref = 'xlinkHref';
		properties[xlinkHref] = new PropertyInfoRecord(
		  'xlinkHref',
		  STRING,
		  false, // mustUseProperty
		  'xlink:href',
		  'http://www.w3.org/1999/xlink',
		  true, // sanitizeURL
		  false, // removeEmptyString
		);

		['src', 'href', 'action', 'formAction'].forEach(attributeName => {
		  properties[attributeName] = new PropertyInfoRecord(
		    attributeName,
		    STRING,
		    false, // mustUseProperty
		    attributeName.toLowerCase(), // attributeName
		    null, // attributeNamespace
		    true, // sanitizeURL
		    true, // removeEmptyString
		  );
		});

		// 
		const {
		  CAMELCASE,
		  SAME,
		  possibleStandardNames: possibleStandardNamesOptimized
		} = requirePossibleStandardNamesOptimized();

		const ATTRIBUTE_NAME_START_CHAR =
		  ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';

		const ATTRIBUTE_NAME_CHAR =
		  ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';

		/**
		 * Checks whether a property name is a custom attribute.
		 *
		 * @see https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/HTMLDOMPropertyConfig.js#L23-L25
		 *
		 * @type {(attribute: string) => boolean}
		 */
		const isCustomAttribute =
		  RegExp.prototype.test.bind(
		    // eslint-disable-next-line no-misleading-character-class
		    new RegExp('^(data|aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
		  );

		/**
		 * @type {Record<string, string>}
		 */
		const possibleStandardNames = Object.keys(
		  possibleStandardNamesOptimized
		).reduce((accumulator, standardName) => {
		  const propName = possibleStandardNamesOptimized[standardName];
		  if (propName === SAME) {
		    accumulator[standardName] = standardName;
		  } else if (propName === CAMELCASE) {
		    accumulator[standardName.toLowerCase()] = standardName;
		  } else {
		    accumulator[standardName] = propName;
		  }
		  return accumulator;
		}, {});

		lib.BOOLEAN = BOOLEAN;
		lib.BOOLEANISH_STRING = BOOLEANISH_STRING;
		lib.NUMERIC = NUMERIC;
		lib.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
		lib.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
		lib.RESERVED = RESERVED;
		lib.STRING = STRING;
		lib.getPropertyInfo = getPropertyInfo;
		lib.isCustomAttribute = isCustomAttribute;
		lib.possibleStandardNames = possibleStandardNames;
		return lib;
	}

	var utilities$1 = {};

	var cjs$1 = {};

	var inlineStyleParser;
	var hasRequiredInlineStyleParser;

	function requireInlineStyleParser () {
		if (hasRequiredInlineStyleParser) return inlineStyleParser;
		hasRequiredInlineStyleParser = 1;
		// http://www.w3.org/TR/CSS21/grammar.html
		// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
		var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

		var NEWLINE_REGEX = /\n/g;
		var WHITESPACE_REGEX = /^\s*/;

		// declaration
		var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
		var COLON_REGEX = /^:\s*/;
		var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
		var SEMICOLON_REGEX = /^[;\s]*/;

		// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
		var TRIM_REGEX = /^\s+|\s+$/g;

		// strings
		var NEWLINE = '\n';
		var FORWARD_SLASH = '/';
		var ASTERISK = '*';
		var EMPTY_STRING = '';

		// types
		var TYPE_COMMENT = 'comment';
		var TYPE_DECLARATION = 'declaration';

		/**
		 * @param {String} style
		 * @param {Object} [options]
		 * @return {Object[]}
		 * @throws {TypeError}
		 * @throws {Error}
		 */
		inlineStyleParser = function (style, options) {
		  if (typeof style !== 'string') {
		    throw new TypeError('First argument must be a string');
		  }

		  if (!style) return [];

		  options = options || {};

		  /**
		   * Positional.
		   */
		  var lineno = 1;
		  var column = 1;

		  /**
		   * Update lineno and column based on `str`.
		   *
		   * @param {String} str
		   */
		  function updatePosition(str) {
		    var lines = str.match(NEWLINE_REGEX);
		    if (lines) lineno += lines.length;
		    var i = str.lastIndexOf(NEWLINE);
		    column = ~i ? str.length - i : column + str.length;
		  }

		  /**
		   * Mark position and patch `node.position`.
		   *
		   * @return {Function}
		   */
		  function position() {
		    var start = { line: lineno, column: column };
		    return function (node) {
		      node.position = new Position(start);
		      whitespace();
		      return node;
		    };
		  }

		  /**
		   * Store position information for a node.
		   *
		   * @constructor
		   * @property {Object} start
		   * @property {Object} end
		   * @property {undefined|String} source
		   */
		  function Position(start) {
		    this.start = start;
		    this.end = { line: lineno, column: column };
		    this.source = options.source;
		  }

		  /**
		   * Non-enumerable source string.
		   */
		  Position.prototype.content = style;

		  /**
		   * Error `msg`.
		   *
		   * @param {String} msg
		   * @throws {Error}
		   */
		  function error(msg) {
		    var err = new Error(
		      options.source + ':' + lineno + ':' + column + ': ' + msg
		    );
		    err.reason = msg;
		    err.filename = options.source;
		    err.line = lineno;
		    err.column = column;
		    err.source = style;

		    if (options.silent) ; else {
		      throw err;
		    }
		  }

		  /**
		   * Match `re` and return captures.
		   *
		   * @param {RegExp} re
		   * @return {undefined|Array}
		   */
		  function match(re) {
		    var m = re.exec(style);
		    if (!m) return;
		    var str = m[0];
		    updatePosition(str);
		    style = style.slice(str.length);
		    return m;
		  }

		  /**
		   * Parse whitespace.
		   */
		  function whitespace() {
		    match(WHITESPACE_REGEX);
		  }

		  /**
		   * Parse comments.
		   *
		   * @param {Object[]} [rules]
		   * @return {Object[]}
		   */
		  function comments(rules) {
		    var c;
		    rules = rules || [];
		    while ((c = comment())) {
		      if (c !== false) {
		        rules.push(c);
		      }
		    }
		    return rules;
		  }

		  /**
		   * Parse comment.
		   *
		   * @return {Object}
		   * @throws {Error}
		   */
		  function comment() {
		    var pos = position();
		    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

		    var i = 2;
		    while (
		      EMPTY_STRING != style.charAt(i) &&
		      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
		    ) {
		      ++i;
		    }
		    i += 2;

		    if (EMPTY_STRING === style.charAt(i - 1)) {
		      return error('End of comment missing');
		    }

		    var str = style.slice(2, i - 2);
		    column += 2;
		    updatePosition(str);
		    style = style.slice(i);
		    column += 2;

		    return pos({
		      type: TYPE_COMMENT,
		      comment: str
		    });
		  }

		  /**
		   * Parse declaration.
		   *
		   * @return {Object}
		   * @throws {Error}
		   */
		  function declaration() {
		    var pos = position();

		    // prop
		    var prop = match(PROPERTY_REGEX);
		    if (!prop) return;
		    comment();

		    // :
		    if (!match(COLON_REGEX)) return error("property missing ':'");

		    // val
		    var val = match(VALUE_REGEX);

		    var ret = pos({
		      type: TYPE_DECLARATION,
		      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
		      value: val
		        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
		        : EMPTY_STRING
		    });

		    // ;
		    match(SEMICOLON_REGEX);

		    return ret;
		  }

		  /**
		   * Parse declarations.
		   *
		   * @return {Object[]}
		   */
		  function declarations() {
		    var decls = [];

		    comments(decls);

		    // declarations
		    var decl;
		    while ((decl = declaration())) {
		      if (decl !== false) {
		        decls.push(decl);
		        comments(decls);
		      }
		    }

		    return decls;
		  }

		  whitespace();
		  return declarations();
		};

		/**
		 * Trim `str`.
		 *
		 * @param {String} str
		 * @return {String}
		 */
		function trim(str) {
		  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
		}
		return inlineStyleParser;
	}

	var hasRequiredCjs$1;

	function requireCjs$1 () {
		if (hasRequiredCjs$1) return cjs$1;
		hasRequiredCjs$1 = 1;
		var __importDefault = (cjs$1 && cjs$1.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(cjs$1, "__esModule", { value: true });
		cjs$1.default = StyleToObject;
		var inline_style_parser_1 = __importDefault(requireInlineStyleParser());
		/**
		 * Parses inline style to object.
		 *
		 * @param style - Inline style.
		 * @param iterator - Iterator.
		 * @returns - Style object or null.
		 *
		 * @example Parsing inline style to object:
		 *
		 * ```js
		 * import parse from 'style-to-object';
		 * parse('line-height: 42;'); // { 'line-height': '42' }
		 * ```
		 */
		function StyleToObject(style, iterator) {
		    var styleObject = null;
		    if (!style || typeof style !== 'string') {
		        return styleObject;
		    }
		    var declarations = (0, inline_style_parser_1.default)(style);
		    var hasIterator = typeof iterator === 'function';
		    declarations.forEach(function (declaration) {
		        if (declaration.type !== 'declaration') {
		            return;
		        }
		        var property = declaration.property, value = declaration.value;
		        if (hasIterator) {
		            iterator(property, value, declaration);
		        }
		        else if (value) {
		            styleObject = styleObject || {};
		            styleObject[property] = value;
		        }
		    });
		    return styleObject;
		}
		
		return cjs$1;
	}

	var utilities = {};

	var hasRequiredUtilities$1;

	function requireUtilities$1 () {
		if (hasRequiredUtilities$1) return utilities;
		hasRequiredUtilities$1 = 1;
		Object.defineProperty(utilities, "__esModule", { value: true });
		utilities.camelCase = void 0;
		var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
		var HYPHEN_REGEX = /-([a-z])/g;
		var NO_HYPHEN_REGEX = /^[^-]+$/;
		var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
		var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
		/**
		 * Checks whether to skip camelCase.
		 */
		var skipCamelCase = function (property) {
		    return !property ||
		        NO_HYPHEN_REGEX.test(property) ||
		        CUSTOM_PROPERTY_REGEX.test(property);
		};
		/**
		 * Replacer that capitalizes first character.
		 */
		var capitalize = function (match, character) {
		    return character.toUpperCase();
		};
		/**
		 * Replacer that removes beginning hyphen of vendor prefix property.
		 */
		var trimHyphen = function (match, prefix) { return "".concat(prefix, "-"); };
		/**
		 * CamelCases a CSS property.
		 */
		var camelCase = function (property, options) {
		    if (options === void 0) { options = {}; }
		    if (skipCamelCase(property)) {
		        return property;
		    }
		    property = property.toLowerCase();
		    if (options.reactCompat) {
		        // `-ms` vendor prefix should not be capitalized
		        property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
		    }
		    else {
		        // for non-React, remove first hyphen so vendor prefix is not capitalized
		        property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
		    }
		    return property.replace(HYPHEN_REGEX, capitalize);
		};
		utilities.camelCase = camelCase;
		
		return utilities;
	}

	var cjs;
	var hasRequiredCjs;

	function requireCjs () {
		if (hasRequiredCjs) return cjs;
		hasRequiredCjs = 1;
		var __importDefault = (cjs && cjs.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		var style_to_object_1 = __importDefault(requireCjs$1());
		var utilities_1 = requireUtilities$1();
		/**
		 * Parses CSS inline style to JavaScript object (camelCased).
		 */
		function StyleToJS(style, options) {
		    var output = {};
		    if (!style || typeof style !== 'string') {
		        return output;
		    }
		    (0, style_to_object_1.default)(style, function (property, value) {
		        // skip CSS comment
		        if (property && value) {
		            output[(0, utilities_1.camelCase)(property, options)] = value;
		        }
		    });
		    return output;
		}
		StyleToJS.default = StyleToJS;
		cjs = StyleToJS;
		
		return cjs;
	}

	var hasRequiredUtilities;

	function requireUtilities () {
		if (hasRequiredUtilities) return utilities$1;
		hasRequiredUtilities = 1;
		(function (exports) {
			var __importDefault = (utilities$1 && utilities$1.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.returnFirstArg = exports.canTextBeChildOfNode = exports.ELEMENTS_WITH_NO_TEXT_CHILDREN = exports.PRESERVE_CUSTOM_ATTRIBUTES = void 0;
			exports.isCustomComponent = isCustomComponent;
			exports.setStyleProp = setStyleProp;
			var react_1 = requireReact();
			var style_to_js_1 = __importDefault(requireCjs());
			var RESERVED_SVG_MATHML_ELEMENTS = new Set([
			    'annotation-xml',
			    'color-profile',
			    'font-face',
			    'font-face-src',
			    'font-face-uri',
			    'font-face-format',
			    'font-face-name',
			    'missing-glyph',
			]);
			/**
			 * Check if a tag is a custom component.
			 *
			 * @see {@link https://github.com/facebook/react/blob/v16.6.3/packages/react-dom/src/shared/isCustomComponent.js}
			 *
			 * @param tagName - Tag name.
			 * @param props - Props passed to the element.
			 * @returns - Whether the tag is custom component.
			 */
			function isCustomComponent(tagName, props) {
			    if (!tagName.includes('-')) {
			        return Boolean(props && typeof props.is === 'string');
			    }
			    // These are reserved SVG and MathML elements.
			    // We don't mind this whitelist too much because we expect it to never grow.
			    // The alternative is to track the namespace in a few places which is convoluted.
			    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
			    if (RESERVED_SVG_MATHML_ELEMENTS.has(tagName)) {
			        return false;
			    }
			    return true;
			}
			var styleOptions = {
			    reactCompat: true,
			};
			/**
			 * Sets style prop.
			 *
			 * @param style - Inline style.
			 * @param props - Props object.
			 */
			function setStyleProp(style, props) {
			    if (typeof style !== 'string') {
			        return;
			    }
			    if (!style.trim()) {
			        props.style = {};
			        return;
			    }
			    try {
			        props.style = (0, style_to_js_1.default)(style, styleOptions);
			        // eslint-disable-next-line @typescript-eslint/no-unused-vars
			    }
			    catch (error) {
			        props.style = {};
			    }
			}
			/**
			 * @see https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html
			 */
			exports.PRESERVE_CUSTOM_ATTRIBUTES = Number(react_1.version.split('.')[0]) >= 16;
			/**
			 * @see https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-dom/src/client/validateDOMNesting.js#L213
			 */
			exports.ELEMENTS_WITH_NO_TEXT_CHILDREN = new Set([
			    'tr',
			    'tbody',
			    'thead',
			    'tfoot',
			    'colgroup',
			    'table',
			    'head',
			    'html',
			    'frameset',
			]);
			/**
			 * Checks if the given node can contain text nodes
			 *
			 * @param node - Element node.
			 * @returns - Whether the node can contain text nodes.
			 */
			var canTextBeChildOfNode = function (node) {
			    return !exports.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(node.name);
			};
			exports.canTextBeChildOfNode = canTextBeChildOfNode;
			/**
			 * Returns the first argument as is.
			 *
			 * @param arg - The argument to be returned.
			 * @returns - The input argument `arg`.
			 */
			var returnFirstArg = function (arg) { return arg; };
			exports.returnFirstArg = returnFirstArg;
			
		} (utilities$1));
		return utilities$1;
	}

	var hasRequiredAttributesToProps;

	function requireAttributesToProps () {
		if (hasRequiredAttributesToProps) return attributesToProps;
		hasRequiredAttributesToProps = 1;
		Object.defineProperty(attributesToProps, "__esModule", { value: true });
		attributesToProps.default = attributesToProps$1;
		var react_property_1 = requireLib$1();
		var utilities_1 = requireUtilities();
		// https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components
		// https://developer.mozilla.org/docs/Web/HTML/Attributes
		var UNCONTROLLED_COMPONENT_ATTRIBUTES = ['checked', 'value'];
		var UNCONTROLLED_COMPONENT_NAMES = ['input', 'select', 'textarea'];
		var valueOnlyInputs = {
		    reset: true,
		    submit: true,
		};
		/**
		 * Converts HTML/SVG DOM attributes to React props.
		 *
		 * @param attributes - HTML/SVG DOM attributes.
		 * @param nodeName - DOM node name.
		 * @returns - React props.
		 */
		function attributesToProps$1(attributes, nodeName) {
		    if (attributes === void 0) { attributes = {}; }
		    var props = {};
		    var isInputValueOnly = Boolean(attributes.type && valueOnlyInputs[attributes.type]);
		    for (var attributeName in attributes) {
		        var attributeValue = attributes[attributeName];
		        // ARIA (aria-*) or custom data (data-*) attribute
		        if ((0, react_property_1.isCustomAttribute)(attributeName)) {
		            props[attributeName] = attributeValue;
		            continue;
		        }
		        // convert HTML/SVG attribute to React prop
		        var attributeNameLowerCased = attributeName.toLowerCase();
		        var propName = getPropName(attributeNameLowerCased);
		        if (propName) {
		            var propertyInfo = (0, react_property_1.getPropertyInfo)(propName);
		            // convert attribute to uncontrolled component prop (e.g., `value` to `defaultValue`)
		            if (UNCONTROLLED_COMPONENT_ATTRIBUTES.includes(propName) &&
		                UNCONTROLLED_COMPONENT_NAMES.includes(nodeName) &&
		                !isInputValueOnly) {
		                propName = getPropName('default' + attributeNameLowerCased);
		            }
		            props[propName] = attributeValue;
		            switch (propertyInfo && propertyInfo.type) {
		                case react_property_1.BOOLEAN:
		                    props[propName] = true;
		                    break;
		                case react_property_1.OVERLOADED_BOOLEAN:
		                    if (attributeValue === '') {
		                        props[propName] = true;
		                    }
		                    break;
		            }
		            continue;
		        }
		        // preserve custom attribute if React >=16
		        if (utilities_1.PRESERVE_CUSTOM_ATTRIBUTES) {
		            props[attributeName] = attributeValue;
		        }
		    }
		    // transform inline style to object
		    (0, utilities_1.setStyleProp)(attributes.style, props);
		    return props;
		}
		/**
		 * Gets prop name from lowercased attribute name.
		 *
		 * @param attributeName - Lowercased attribute name.
		 * @returns - Prop name.
		 */
		function getPropName(attributeName) {
		    return react_property_1.possibleStandardNames[attributeName];
		}
		
		return attributesToProps;
	}

	var domToReact = {};

	var hasRequiredDomToReact;

	function requireDomToReact () {
		if (hasRequiredDomToReact) return domToReact;
		hasRequiredDomToReact = 1;
		var __importDefault = (domToReact && domToReact.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(domToReact, "__esModule", { value: true });
		domToReact.default = domToReact$1;
		var react_1 = requireReact();
		var attributes_to_props_1 = __importDefault(requireAttributesToProps());
		var utilities_1 = requireUtilities();
		var React = {
		    cloneElement: react_1.cloneElement,
		    createElement: react_1.createElement,
		    isValidElement: react_1.isValidElement,
		};
		/**
		 * Converts DOM nodes to JSX element(s).
		 *
		 * @param nodes - DOM nodes.
		 * @param options - Options.
		 * @returns - String or JSX element(s).
		 */
		function domToReact$1(nodes, options) {
		    if (options === void 0) { options = {}; }
		    var reactElements = [];
		    var hasReplace = typeof options.replace === 'function';
		    var transform = options.transform || utilities_1.returnFirstArg;
		    var _a = options.library || React, cloneElement = _a.cloneElement, createElement = _a.createElement, isValidElement = _a.isValidElement;
		    var nodesLength = nodes.length;
		    for (var index = 0; index < nodesLength; index++) {
		        var node = nodes[index];
		        // replace with custom React element (if present)
		        if (hasReplace) {
		            var replaceElement = options.replace(node, index);
		            if (isValidElement(replaceElement)) {
		                // set "key" prop for sibling elements
		                // https://react.dev/learn/rendering-lists#rules-of-keys
		                if (nodesLength > 1) {
		                    replaceElement = cloneElement(replaceElement, {
		                        key: replaceElement.key || index,
		                    });
		                }
		                reactElements.push(transform(replaceElement, node, index));
		                continue;
		            }
		        }
		        if (node.type === 'text') {
		            var isWhitespace = !node.data.trim().length;
		            // We have a whitespace node that can't be nested in its parent
		            // so skip it
		            if (isWhitespace &&
		                node.parent &&
		                !(0, utilities_1.canTextBeChildOfNode)(node.parent)) {
		                continue;
		            }
		            // Trim is enabled and we have a whitespace node
		            // so skip it
		            if (options.trim && isWhitespace) {
		                continue;
		            }
		            // We have a text node that's not whitespace and it can be nested
		            // in its parent so add it to the results
		            reactElements.push(transform(node.data, node, index));
		            continue;
		        }
		        var element = node;
		        var props = {};
		        if (skipAttributesToProps(element)) {
		            (0, utilities_1.setStyleProp)(element.attribs.style, element.attribs);
		            props = element.attribs;
		        }
		        else if (element.attribs) {
		            props = (0, attributes_to_props_1.default)(element.attribs, element.name);
		        }
		        var children = void 0;
		        switch (node.type) {
		            case 'script':
		            case 'style':
		                // prevent text in <script> or <style> from being escaped
		                // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html
		                if (node.children[0]) {
		                    props.dangerouslySetInnerHTML = {
		                        __html: node.children[0].data,
		                    };
		                }
		                break;
		            case 'tag':
		                // setting textarea value in children is an antipattern in React
		                // https://react.dev/reference/react-dom/components/textarea#caveats
		                if (node.name === 'textarea' && node.children[0]) {
		                    props.defaultValue = node.children[0].data;
		                }
		                else if (node.children && node.children.length) {
		                    // continue recursion of creating React elements (if applicable)
		                    children = domToReact$1(node.children, options);
		                }
		                break;
		            // skip all other cases (e.g., comment)
		            default:
		                continue;
		        }
		        // set "key" prop for sibling elements
		        // https://react.dev/learn/rendering-lists#rules-of-keys
		        if (nodesLength > 1) {
		            props.key = index;
		        }
		        reactElements.push(transform(createElement(node.name, props, children), node, index));
		    }
		    return reactElements.length === 1 ? reactElements[0] : reactElements;
		}
		/**
		 * Determines whether DOM element attributes should be transformed to props.
		 * Web Components should not have their attributes transformed except for `style`.
		 *
		 * @param node - Element node.
		 * @returns - Whether the node attributes should be converted to props.
		 */
		function skipAttributesToProps(node) {
		    return (utilities_1.PRESERVE_CUSTOM_ATTRIBUTES &&
		        node.type === 'tag' &&
		        (0, utilities_1.isCustomComponent)(node.name, node.attribs));
		}
		
		return domToReact;
	}

	var hasRequiredLib;

	function requireLib () {
		if (hasRequiredLib) return lib$7;
		hasRequiredLib = 1;
		(function (exports) {
			var __importDefault = (lib$7 && lib$7.__importDefault) || function (mod) {
			    return (mod && mod.__esModule) ? mod : { "default": mod };
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.htmlToDOM = exports.domToReact = exports.attributesToProps = exports.Text = exports.ProcessingInstruction = exports.Element = exports.Comment = void 0;
			exports.default = HTMLReactParser;
			var html_dom_parser_1 = __importDefault(requireLib$2());
			exports.htmlToDOM = html_dom_parser_1.default;
			var attributes_to_props_1 = __importDefault(requireAttributesToProps());
			exports.attributesToProps = attributes_to_props_1.default;
			var dom_to_react_1 = __importDefault(requireDomToReact());
			exports.domToReact = dom_to_react_1.default;
			var domhandler_1 = /*@__PURE__*/ requireLib$6();
			Object.defineProperty(exports, "Comment", { enumerable: true, get: function () { return domhandler_1.Comment; } });
			Object.defineProperty(exports, "Element", { enumerable: true, get: function () { return domhandler_1.Element; } });
			Object.defineProperty(exports, "ProcessingInstruction", { enumerable: true, get: function () { return domhandler_1.ProcessingInstruction; } });
			Object.defineProperty(exports, "Text", { enumerable: true, get: function () { return domhandler_1.Text; } });
			var domParserOptions = { lowerCaseAttributeNames: false };
			/**
			 * Converts HTML string to React elements.
			 *
			 * @param html - HTML string.
			 * @param options - Parser options.
			 * @returns - React element(s), empty array, or string.
			 */
			function HTMLReactParser(html, options) {
			    if (typeof html !== 'string') {
			        throw new TypeError('First argument must be a string');
			    }
			    if (!html) {
			        return [];
			    }
			    return (0, dom_to_react_1.default)((0, html_dom_parser_1.default)(html, (options === null || options === void 0 ? void 0 : options.htmlparser2) || domParserOptions), options);
			}
			
		} (lib$7));
		return lib$7;
	}

	var libExports = requireLib();
	var HTMLReactParser = /*@__PURE__*/getDefaultExportFromCjs(libExports);

	var parse = HTMLReactParser.default || HTMLReactParser;

	const style$5 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '95%'
	};
	async function callAPI$1() {
	  let response = await fetch(`http://localhost:8080/tools2/api/intelligent.php`);
	  const responseText = await response.json();
	  return parse(responseText);
	}
	function StatsDisplay(_ref) {
	  let {
	    stats
	  } = _ref;
	  return /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	    id: `span-intelligent`
	  }, stats)));
	}
	function IntelligentWeapon(props) {
	  const {
	    label
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getStats();
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setStats(null);
	  };
	  const [stats, setStats] = reactExports.useState(null);
	  const getStats = async () => {
	    const statsData = await callAPI$1();
	    setStats(statsData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Intelligent Weapon Stats"), stats && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$5
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, label, " ", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getStats()
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(StatsDisplay, {
	    stats: stats
	  })))));
	}

	const style$4 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenMagicItems1(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getItems(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setItems(null);
	  };
	  const [items, setItems] = reactExports.useState(null);
	  const getItems = async source => {
	    const itemData = await callAPI(source);
	    setItems(itemData);
	    setOpen(true);
	  };
	  const updateItem = async (indexToUpdate, newValue) => {
	    setItems(items.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
	    let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    let args = '';
	    if (type === 'all') {
	      const Any = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-Any`).value || 0)));
	      const WeaponOrArmor = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-WeaponOrArmor`).value || 0)));
	      const Potion = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-Potion`).value || 0)));
	      const Scroll = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-Scroll`).value || 0)));
	      const AnyExceptWeapon = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-AnyExceptWeapon`).value || 0)));
	      const AllExceptPotionScroll = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-AllExceptPotionScroll`).value || 0)));
	      const MiscMagic = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-MiscMagic`).value || 0)));
	      let SpecificType = '';
	      let Specific = 0;
	      if (source === 'magicitem1') {
	        SpecificType = document.getElementById(`${source}-specificType`).value;
	        Specific = Math.max(0, Math.min(50, parseInt(document.getElementById(`${source}-Specific`).value || 0)));
	      }
	      args = `Any=${Any}&WeaponOrArmor=${WeaponOrArmor}&Potion=${Potion}&Scroll=${Scroll}&AnyExceptWeapon=${AnyExceptWeapon}&AllExceptPotionScroll=${AllExceptPotionScroll}&MiscMagic=${MiscMagic}&specificType=${SpecificType}&Specific=${Specific}`;
	    } else {
	      const amountInput = document.getElementById(`${source}-${type}`);
	      let newAmount = 0;
	      if (amountInput) {
	        newAmount = parseInt(amountInput.value);
	      }
	      if (amount === 0) {
	        amount = newAmount;
	      }
	      args = `${type}=${amount}`;
	      if (type === 'Specific') {
	        const SpecificType = document.getElementById(`${source}-specificType`).value;
	        args += `&specificType=${SpecificType}`;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/1st_mi.php?${args}`);
	    return await response.json();
	  }
	  async function replaceItem(_ref) {
	    let {
	      source,
	      idx,
	      item
	    } = _ref;
	    let newItem = await callAPI(source, item.type, 1);
	    updateItem(idx, newItem[0]);
	  }
	  function ItemList(_ref2) {
	    let {
	      source,
	      items
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, items.map(function (item, idx) {
	      let volumePage = '';
	      let intelligentButton = '';
	      if (item.page !== 0) {
	        volumePage = ` (Volume: ${item.volume} / Page: ${item.page})`;
	      }
	      if (item.intelligent) {
	        intelligentButton = /*#__PURE__*/reactExports.createElement(IntelligentWeapon, {
	          label: item.text
	        });
	      }
	      const contents = /*#__PURE__*/reactExports.createElement(Typography, null, item.text, volumePage, intelligentButton, /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	        sx: {
	          paddingLeft: "5px",
	          fontSize: "9pt"
	        },
	        onClick: () => replaceItem({
	          source,
	          idx,
	          item
	        })
	      }));
	      return /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", null, contents));
	    }));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Magic Items"), items && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$4
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Magic Items", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getItems(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(ItemList, {
	    items: items,
	    source: source
	  })))));
	}

	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, _typeof(o);
	}

	function toPrimitive(t, r) {
	  if ("object" != _typeof(t) || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != _typeof(i)) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}

	function toPropertyKey(t) {
	  var i = toPrimitive(t, "string");
	  return "symbol" == _typeof(i) ? i : i + "";
	}

	function _defineProperty(e, r, t) {
	  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: true,
	    configurable: true,
	    writable: true
	  }) : e[r] = t, e;
	}

	function ownKeys(e, r) {
	  var t = Object.keys(e);
	  if (Object.getOwnPropertySymbols) {
	    var o = Object.getOwnPropertySymbols(e);
	    r && (o = o.filter(function (r) {
	      return Object.getOwnPropertyDescriptor(e, r).enumerable;
	    })), t.push.apply(t, o);
	  }
	  return t;
	}
	function _objectSpread2(e) {
	  for (var r = 1; r < arguments.length; r++) {
	    var t = null != arguments[r] ? arguments[r] : {};
	    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
	      _defineProperty(e, r, t[r]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	    });
	  }
	  return e;
	}

	function _arrayWithHoles(r) {
	  if (Array.isArray(r)) return r;
	}

	function _iterableToArrayLimit(r, l) {
	  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	  if (null != t) {
	    var e,
	      n,
	      i,
	      u,
	      a = [],
	      f = true,
	      o = false;
	    try {
	      if (i = (t = t.call(r)).next, 0 === l) {
	        if (Object(t) !== t) return;
	        f = !1;
	      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
	    } catch (r) {
	      o = true, n = r;
	    } finally {
	      try {
	        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
	      } finally {
	        if (o) throw n;
	      }
	    }
	    return a;
	  }
	}

	function _arrayLikeToArray(r, a) {
	  (null == a || a > r.length) && (a = r.length);
	  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	  return n;
	}

	function _unsupportedIterableToArray(r, a) {
	  if (r) {
	    if ("string" == typeof r) return _arrayLikeToArray(r, a);
	    var t = {}.toString.call(r).slice(8, -1);
	    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
	  }
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _slicedToArray(r, e) {
	  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
	}

	function _objectWithoutProperties(e, t) {
	  if (null == e) return {};
	  var o,
	    r,
	    i = _objectWithoutPropertiesLoose(e, t);
	  if (Object.getOwnPropertySymbols) {
	    var n = Object.getOwnPropertySymbols(e);
	    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	  }
	  return i;
	}

	var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
	function useStateManager(_ref) {
	  var _ref$defaultInputValu = _ref.defaultInputValue,
	    defaultInputValue = _ref$defaultInputValu === void 0 ? '' : _ref$defaultInputValu,
	    _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
	    defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
	    _ref$defaultValue = _ref.defaultValue,
	    defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
	    propsInputValue = _ref.inputValue,
	    propsMenuIsOpen = _ref.menuIsOpen,
	    propsOnChange = _ref.onChange,
	    propsOnInputChange = _ref.onInputChange,
	    propsOnMenuClose = _ref.onMenuClose,
	    propsOnMenuOpen = _ref.onMenuOpen,
	    propsValue = _ref.value,
	    restSelectProps = _objectWithoutProperties(_ref, _excluded$6);
	  var _useState = reactExports.useState(propsInputValue !== undefined ? propsInputValue : defaultInputValue),
	    _useState2 = _slicedToArray(_useState, 2),
	    stateInputValue = _useState2[0],
	    setStateInputValue = _useState2[1];
	  var _useState3 = reactExports.useState(propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen),
	    _useState4 = _slicedToArray(_useState3, 2),
	    stateMenuIsOpen = _useState4[0],
	    setStateMenuIsOpen = _useState4[1];
	  var _useState5 = reactExports.useState(propsValue !== undefined ? propsValue : defaultValue),
	    _useState6 = _slicedToArray(_useState5, 2),
	    stateValue = _useState6[0],
	    setStateValue = _useState6[1];
	  var onChange = reactExports.useCallback(function (value, actionMeta) {
	    if (typeof propsOnChange === 'function') {
	      propsOnChange(value, actionMeta);
	    }
	    setStateValue(value);
	  }, [propsOnChange]);
	  var onInputChange = reactExports.useCallback(function (value, actionMeta) {
	    var newValue;
	    if (typeof propsOnInputChange === 'function') {
	      newValue = propsOnInputChange(value, actionMeta);
	    }
	    setStateInputValue(newValue !== undefined ? newValue : value);
	  }, [propsOnInputChange]);
	  var onMenuOpen = reactExports.useCallback(function () {
	    if (typeof propsOnMenuOpen === 'function') {
	      propsOnMenuOpen();
	    }
	    setStateMenuIsOpen(true);
	  }, [propsOnMenuOpen]);
	  var onMenuClose = reactExports.useCallback(function () {
	    if (typeof propsOnMenuClose === 'function') {
	      propsOnMenuClose();
	    }
	    setStateMenuIsOpen(false);
	  }, [propsOnMenuClose]);
	  var inputValue = propsInputValue !== undefined ? propsInputValue : stateInputValue;
	  var menuIsOpen = propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
	  var value = propsValue !== undefined ? propsValue : stateValue;
	  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
	    inputValue: inputValue,
	    menuIsOpen: menuIsOpen,
	    onChange: onChange,
	    onInputChange: onInputChange,
	    onMenuClose: onMenuClose,
	    onMenuOpen: onMenuOpen,
	    value: value
	  });
	}

	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}

	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}

	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: true,
	      configurable: true
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: false
	  }), e && _setPrototypeOf(t, e);
	}

	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}

	function _isNativeReflectConstruct() {
	  try {
	    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	  } catch (t) {}
	  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
	    return !!t;
	  })();
	}

	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}

	function _createSuper(t) {
	  var r = _isNativeReflectConstruct();
	  return function () {
	    var e,
	      o = _getPrototypeOf(t);
	    if (r) {
	      var s = _getPrototypeOf(this).constructor;
	      e = Reflect.construct(o, arguments, s);
	    } else e = o.apply(this, arguments);
	    return _possibleConstructorReturn(this, e);
	  };
	}

	function _arrayWithoutHoles(r) {
	  if (Array.isArray(r)) return _arrayLikeToArray(r);
	}

	function _iterableToArray(r) {
	  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _toConsumableArray(r) {
	  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
	}

	function _taggedTemplateLiteral(e, t) {
	  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
	    raw: {
	      value: Object.freeze(t)
	    }
	  }));
	}

	/**
	 * Custom positioning reference element.
	 * @see https://floating-ui.com/docs/virtual-elements
	 */

	const min = Math.min;
	const max = Math.max;
	const round = Math.round;
	const floor = Math.floor;
	const createCoords = v => ({
	  x: v,
	  y: v
	});
	function rectToClientRect(rect) {
	  const {
	    x,
	    y,
	    width,
	    height
	  } = rect;
	  return {
	    width,
	    height,
	    top: y,
	    left: x,
	    right: x + width,
	    bottom: y + height,
	    x,
	    y
	  };
	}

	function hasWindow() {
	  return typeof window !== 'undefined';
	}
	function getNodeName(node) {
	  if (isNode(node)) {
	    return (node.nodeName || '').toLowerCase();
	  }
	  // Mocked nodes in testing environments may not be instances of Node. By
	  // returning `#document` an infinite loop won't occur.
	  // https://github.com/floating-ui/floating-ui/issues/2317
	  return '#document';
	}
	function getWindow(node) {
	  var _node$ownerDocument;
	  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
	}
	function getDocumentElement(node) {
	  var _ref;
	  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
	}
	function isNode(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof Node || value instanceof getWindow(value).Node;
	}
	function isElement(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof Element || value instanceof getWindow(value).Element;
	}
	function isHTMLElement(value) {
	  if (!hasWindow()) {
	    return false;
	  }
	  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
	}
	function isShadowRoot(value) {
	  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
	    return false;
	  }
	  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
	}
	function isOverflowElement(element) {
	  const {
	    overflow,
	    overflowX,
	    overflowY,
	    display
	  } = getComputedStyle$1(element);
	  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
	}
	function isWebKit() {
	  if (typeof CSS === 'undefined' || !CSS.supports) return false;
	  return CSS.supports('-webkit-backdrop-filter', 'none');
	}
	function isLastTraversableNode(node) {
	  return ['html', 'body', '#document'].includes(getNodeName(node));
	}
	function getComputedStyle$1(element) {
	  return getWindow(element).getComputedStyle(element);
	}
	function getParentNode(node) {
	  if (getNodeName(node) === 'html') {
	    return node;
	  }
	  const result =
	  // Step into the shadow DOM of the parent of a slotted node.
	  node.assignedSlot ||
	  // DOM Element detected.
	  node.parentNode ||
	  // ShadowRoot detected.
	  isShadowRoot(node) && node.host ||
	  // Fallback.
	  getDocumentElement(node);
	  return isShadowRoot(result) ? result.host : result;
	}
	function getNearestOverflowAncestor(node) {
	  const parentNode = getParentNode(node);
	  if (isLastTraversableNode(parentNode)) {
	    return node.ownerDocument ? node.ownerDocument.body : node.body;
	  }
	  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
	    return parentNode;
	  }
	  return getNearestOverflowAncestor(parentNode);
	}
	function getOverflowAncestors(node, list, traverseIframes) {
	  var _node$ownerDocument2;
	  if (list === void 0) {
	    list = [];
	  }
	  if (traverseIframes === void 0) {
	    traverseIframes = true;
	  }
	  const scrollableAncestor = getNearestOverflowAncestor(node);
	  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	  const win = getWindow(scrollableAncestor);
	  if (isBody) {
	    const frameElement = getFrameElement(win);
	    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	  }
	  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
	}
	function getFrameElement(win) {
	  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
	}

	function getCssDimensions(element) {
	  const css = getComputedStyle$1(element);
	  // In testing environments, the `width` and `height` properties are empty
	  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
	  let width = parseFloat(css.width) || 0;
	  let height = parseFloat(css.height) || 0;
	  const hasOffset = isHTMLElement(element);
	  const offsetWidth = hasOffset ? element.offsetWidth : width;
	  const offsetHeight = hasOffset ? element.offsetHeight : height;
	  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	  if (shouldFallback) {
	    width = offsetWidth;
	    height = offsetHeight;
	  }
	  return {
	    width,
	    height,
	    $: shouldFallback
	  };
	}

	function unwrapElement(element) {
	  return !isElement(element) ? element.contextElement : element;
	}

	function getScale(element) {
	  const domElement = unwrapElement(element);
	  if (!isHTMLElement(domElement)) {
	    return createCoords(1);
	  }
	  const rect = domElement.getBoundingClientRect();
	  const {
	    width,
	    height,
	    $
	  } = getCssDimensions(domElement);
	  let x = ($ ? round(rect.width) : rect.width) / width;
	  let y = ($ ? round(rect.height) : rect.height) / height;

	  // 0, NaN, or Infinity should always fallback to 1.

	  if (!x || !Number.isFinite(x)) {
	    x = 1;
	  }
	  if (!y || !Number.isFinite(y)) {
	    y = 1;
	  }
	  return {
	    x,
	    y
	  };
	}

	const noOffsets = /*#__PURE__*/createCoords(0);
	function getVisualOffsets(element) {
	  const win = getWindow(element);
	  if (!isWebKit() || !win.visualViewport) {
	    return noOffsets;
	  }
	  return {
	    x: win.visualViewport.offsetLeft,
	    y: win.visualViewport.offsetTop
	  };
	}
	function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	  {
	    return false;
	  }
	}

	function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	  if (includeScale === void 0) {
	    includeScale = false;
	  }
	  const clientRect = element.getBoundingClientRect();
	  const domElement = unwrapElement(element);
	  let scale = createCoords(1);
	  if (includeScale) {
	    {
	      scale = getScale(element);
	    }
	  }
	  const visualOffsets = shouldAddVisualOffsets() ? getVisualOffsets(domElement) : createCoords(0);
	  let x = (clientRect.left + visualOffsets.x) / scale.x;
	  let y = (clientRect.top + visualOffsets.y) / scale.y;
	  let width = clientRect.width / scale.x;
	  let height = clientRect.height / scale.y;
	  if (domElement) {
	    const win = getWindow(domElement);
	    const offsetWin = offsetParent;
	    let currentWin = win;
	    let currentIFrame = getFrameElement(currentWin);
	    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
	      const iframeScale = getScale(currentIFrame);
	      const iframeRect = currentIFrame.getBoundingClientRect();
	      const css = getComputedStyle$1(currentIFrame);
	      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
	      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
	      x *= iframeScale.x;
	      y *= iframeScale.y;
	      width *= iframeScale.x;
	      height *= iframeScale.y;
	      x += left;
	      y += top;
	      currentWin = getWindow(currentIFrame);
	      currentIFrame = getFrameElement(currentWin);
	    }
	  }
	  return rectToClientRect({
	    width,
	    height,
	    x,
	    y
	  });
	}

	function rectsAreEqual(a, b) {
	  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
	}

	// https://samthor.au/2021/observing-dom/
	function observeMove(element, onMove) {
	  let io = null;
	  let timeoutId;
	  const root = getDocumentElement(element);
	  function cleanup() {
	    var _io;
	    clearTimeout(timeoutId);
	    (_io = io) == null || _io.disconnect();
	    io = null;
	  }
	  function refresh(skip, threshold) {
	    if (skip === void 0) {
	      skip = false;
	    }
	    if (threshold === void 0) {
	      threshold = 1;
	    }
	    cleanup();
	    const elementRectForRootMargin = element.getBoundingClientRect();
	    const {
	      left,
	      top,
	      width,
	      height
	    } = elementRectForRootMargin;
	    if (!skip) {
	      onMove();
	    }
	    if (!width || !height) {
	      return;
	    }
	    const insetTop = floor(top);
	    const insetRight = floor(root.clientWidth - (left + width));
	    const insetBottom = floor(root.clientHeight - (top + height));
	    const insetLeft = floor(left);
	    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
	    const options = {
	      rootMargin,
	      threshold: max(0, min(1, threshold)) || 1
	    };
	    let isFirstUpdate = true;
	    function handleObserve(entries) {
	      const ratio = entries[0].intersectionRatio;
	      if (ratio !== threshold) {
	        if (!isFirstUpdate) {
	          return refresh();
	        }
	        if (!ratio) {
	          // If the reference is clipped, the ratio is 0. Throttle the refresh
	          // to prevent an infinite loop of updates.
	          timeoutId = setTimeout(() => {
	            refresh(false, 1e-7);
	          }, 1000);
	        } else {
	          refresh(false, ratio);
	        }
	      }
	      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
	        // It's possible that even though the ratio is reported as 1, the
	        // element is not actually fully within the IntersectionObserver's root
	        // area anymore. This can happen under performance constraints. This may
	        // be a bug in the browser's IntersectionObserver implementation. To
	        // work around this, we compare the element's bounding rect now with
	        // what it was at the time we created the IntersectionObserver. If they
	        // are not equal then the element moved, so we refresh.
	        refresh();
	      }
	      isFirstUpdate = false;
	    }

	    // Older browsers don't support a `document` as the root and will throw an
	    // error.
	    try {
	      io = new IntersectionObserver(handleObserve, {
	        ...options,
	        // Handle <iframe>s
	        root: root.ownerDocument
	      });
	    } catch (_e) {
	      io = new IntersectionObserver(handleObserve, options);
	    }
	    io.observe(element);
	  }
	  refresh(true);
	  return cleanup;
	}

	/**
	 * Automatically updates the position of the floating element when necessary.
	 * Should only be called when the floating element is mounted on the DOM or
	 * visible on the screen.
	 * @returns cleanup function that should be invoked when the floating element is
	 * removed from the DOM or hidden from the screen.
	 * @see https://floating-ui.com/docs/autoUpdate
	 */
	function autoUpdate(reference, floating, update, options) {
	  if (options === void 0) {
	    options = {};
	  }
	  const {
	    ancestorScroll = true,
	    ancestorResize = true,
	    elementResize = typeof ResizeObserver === 'function',
	    layoutShift = typeof IntersectionObserver === 'function',
	    animationFrame = false
	  } = options;
	  const referenceEl = unwrapElement(reference);
	  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
	  ancestors.forEach(ancestor => {
	    ancestorScroll && ancestor.addEventListener('scroll', update, {
	      passive: true
	    });
	    ancestorResize && ancestor.addEventListener('resize', update);
	  });
	  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	  let reobserveFrame = -1;
	  let resizeObserver = null;
	  if (elementResize) {
	    resizeObserver = new ResizeObserver(_ref => {
	      let [firstEntry] = _ref;
	      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
	        // Prevent update loops when using the `size` middleware.
	        // https://github.com/floating-ui/floating-ui/issues/1740
	        resizeObserver.unobserve(floating);
	        cancelAnimationFrame(reobserveFrame);
	        reobserveFrame = requestAnimationFrame(() => {
	          var _resizeObserver;
	          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
	        });
	      }
	      update();
	    });
	    if (referenceEl && !animationFrame) {
	      resizeObserver.observe(referenceEl);
	    }
	    resizeObserver.observe(floating);
	  }
	  let frameId;
	  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	  if (animationFrame) {
	    frameLoop();
	  }
	  function frameLoop() {
	    const nextRefRect = getBoundingClientRect(reference);
	    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
	      update();
	    }
	    prevRefRect = nextRefRect;
	    frameId = requestAnimationFrame(frameLoop);
	  }
	  update();
	  return () => {
	    var _resizeObserver2;
	    ancestors.forEach(ancestor => {
	      ancestorScroll && ancestor.removeEventListener('scroll', update);
	      ancestorResize && ancestor.removeEventListener('resize', update);
	    });
	    cleanupIo == null || cleanupIo();
	    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
	    resizeObserver = null;
	    if (animationFrame) {
	      cancelAnimationFrame(frameId);
	    }
	  };
	}

	var isClient = typeof document !== 'undefined';

	var noop$1 = function noop() {};
	var index = isClient ? reactExports.useLayoutEffect : noop$1;

	var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
	// ==============================
	// NO OP
	// ==============================

	var noop = function noop() {};

	// ==============================
	// Class Name Prefixer
	// ==============================

	/**
	 String representation of component state for styling with class names.

	 Expects an array of strings OR a string/object pair:
	 - className(['comp', 'comp-arg', 'comp-arg-2'])
	   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
	 - className('comp', { some: true, state: false })
	   @returns 'react-select__comp react-select__comp--some'
	*/
	function applyPrefixToName(prefix, name) {
	  if (!name) {
	    return prefix;
	  } else if (name[0] === '-') {
	    return prefix + name;
	  } else {
	    return prefix + '__' + name;
	  }
	}
	function classNames(prefix, state) {
	  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    classNameList[_key - 2] = arguments[_key];
	  }
	  var arr = [].concat(classNameList);
	  if (state && prefix) {
	    for (var key in state) {
	      if (state.hasOwnProperty(key) && state[key]) {
	        arr.push("".concat(applyPrefixToName(prefix, key)));
	      }
	    }
	  }
	  return arr.filter(function (i) {
	    return i;
	  }).map(function (i) {
	    return String(i).trim();
	  }).join(' ');
	}
	// ==============================
	// Clean Value
	// ==============================

	var cleanValue = function cleanValue(value) {
	  if (isArray(value)) return value.filter(Boolean);
	  if (_typeof(value) === 'object' && value !== null) return [value];
	  return [];
	};

	// ==============================
	// Clean Common Props
	// ==============================

	var cleanCommonProps = function cleanCommonProps(props) {
	  //className
	  props.className;
	    props.clearValue;
	    props.cx;
	    props.getStyles;
	    props.getClassNames;
	    props.getValue;
	    props.hasValue;
	    props.isMulti;
	    props.isRtl;
	    props.options;
	    props.selectOption;
	    props.selectProps;
	    props.setValue;
	    props.theme;
	    var innerProps = _objectWithoutProperties(props, _excluded$4);
	  return _objectSpread2({}, innerProps);
	};

	// ==============================
	// Get Style Props
	// ==============================

	var getStyleProps = function getStyleProps(props, name, classNamesState) {
	  var cx = props.cx,
	    getStyles = props.getStyles,
	    getClassNames = props.getClassNames,
	    className = props.className;
	  return {
	    css: getStyles(name, props),
	    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
	  };
	};

	// ==============================
	// Scroll Helpers
	// ==============================

	function isDocumentElement(el) {
	  return [document.documentElement, document.body, window].indexOf(el) > -1;
	}

	// Normalized Scroll Top
	// ------------------------------

	function normalizedHeight(el) {
	  if (isDocumentElement(el)) {
	    return window.innerHeight;
	  }
	  return el.clientHeight;
	}

	// Normalized scrollTo & scrollTop
	// ------------------------------

	function getScrollTop(el) {
	  if (isDocumentElement(el)) {
	    return window.pageYOffset;
	  }
	  return el.scrollTop;
	}
	function scrollTo(el, top) {
	  // with a scroll distance, we perform scroll on the element
	  if (isDocumentElement(el)) {
	    window.scrollTo(0, top);
	    return;
	  }
	  el.scrollTop = top;
	}

	// Get Scroll Parent
	// ------------------------------

	function getScrollParent(element) {
	  var style = getComputedStyle(element);
	  var excludeStaticParent = style.position === 'absolute';
	  var overflowRx = /(auto|scroll)/;
	  if (style.position === 'fixed') return document.documentElement;
	  for (var parent = element; parent = parent.parentElement;) {
	    style = getComputedStyle(parent);
	    if (excludeStaticParent && style.position === 'static') {
	      continue;
	    }
	    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
	      return parent;
	    }
	  }
	  return document.documentElement;
	}

	// Animated Scroll To
	// ------------------------------

	/**
	  @param t: time (elapsed)
	  @param b: initial value
	  @param c: amount of change
	  @param d: duration
	*/
	function easeOutCubic(t, b, c, d) {
	  return c * ((t = t / d - 1) * t * t + 1) + b;
	}
	function animatedScrollTo(element, to) {
	  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
	  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
	  var start = getScrollTop(element);
	  var change = to - start;
	  var increment = 10;
	  var currentTime = 0;
	  function animateScroll() {
	    currentTime += increment;
	    var val = easeOutCubic(currentTime, start, change, duration);
	    scrollTo(element, val);
	    if (currentTime < duration) {
	      window.requestAnimationFrame(animateScroll);
	    } else {
	      callback(element);
	    }
	  }
	  animateScroll();
	}

	// Scroll Into View
	// ------------------------------

	function scrollIntoView(menuEl, focusedEl) {
	  var menuRect = menuEl.getBoundingClientRect();
	  var focusedRect = focusedEl.getBoundingClientRect();
	  var overScroll = focusedEl.offsetHeight / 3;
	  if (focusedRect.bottom + overScroll > menuRect.bottom) {
	    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
	  } else if (focusedRect.top - overScroll < menuRect.top) {
	    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
	  }
	}

	// ==============================
	// Get bounding client object
	// ==============================

	// cannot get keys using array notation with DOMRect
	function getBoundingClientObj(element) {
	  var rect = element.getBoundingClientRect();
	  return {
	    bottom: rect.bottom,
	    height: rect.height,
	    left: rect.left,
	    right: rect.right,
	    top: rect.top,
	    width: rect.width
	  };
	}

	// ==============================
	// Touch Capability Detector
	// ==============================

	function isTouchCapable() {
	  try {
	    document.createEvent('TouchEvent');
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	// ==============================
	// Mobile Device Detector
	// ==============================

	function isMobileDevice() {
	  try {
	    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
	  } catch (e) {
	    return false;
	  }
	}

	// ==============================
	// Passive Event Detector
	// ==============================

	// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36
	var passiveOptionAccessed = false;
	var options = {
	  get passive() {
	    return passiveOptionAccessed = true;
	  }
	};
	// check for SSR
	var w = typeof window !== 'undefined' ? window : {};
	if (w.addEventListener && w.removeEventListener) {
	  w.addEventListener('p', noop, options);
	  w.removeEventListener('p', noop, false);
	}
	var supportsPassiveEvents = passiveOptionAccessed;
	function notNullish(item) {
	  return item != null;
	}
	function isArray(arg) {
	  return Array.isArray(arg);
	}
	function valueTernary(isMulti, multiValue, singleValue) {
	  return isMulti ? multiValue : singleValue;
	}
	function singleValueAsValue(singleValue) {
	  return singleValue;
	}
	function multiValueAsValue(multiValue) {
	  return multiValue;
	}
	var removeProps = function removeProps(propsObj) {
	  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    properties[_key2 - 1] = arguments[_key2];
	  }
	  var propsMap = Object.entries(propsObj).filter(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 1),
	      key = _ref2[0];
	    return !properties.includes(key);
	  });
	  return propsMap.reduce(function (newProps, _ref3) {
	    var _ref4 = _slicedToArray(_ref3, 2),
	      key = _ref4[0],
	      val = _ref4[1];
	    newProps[key] = val;
	    return newProps;
	  }, {});
	};

	var _excluded$3 = ["children", "innerProps"],
	  _excluded2$1 = ["children", "innerProps"];
	function getMenuPlacement(_ref) {
	  var preferredMaxHeight = _ref.maxHeight,
	    menuEl = _ref.menuEl,
	    minHeight = _ref.minHeight,
	    preferredPlacement = _ref.placement,
	    shouldScroll = _ref.shouldScroll,
	    isFixedPosition = _ref.isFixedPosition,
	    controlHeight = _ref.controlHeight;
	  var scrollParent = getScrollParent(menuEl);
	  var defaultState = {
	    placement: 'bottom',
	    maxHeight: preferredMaxHeight
	  };

	  // something went wrong, return default state
	  if (!menuEl || !menuEl.offsetParent) return defaultState;

	  // we can't trust `scrollParent.scrollHeight` --> it may increase when
	  // the menu is rendered
	  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
	    scrollHeight = _scrollParent$getBoun.height;
	  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
	    menuBottom = _menuEl$getBoundingCl.bottom,
	    menuHeight = _menuEl$getBoundingCl.height,
	    menuTop = _menuEl$getBoundingCl.top;
	  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
	    containerTop = _menuEl$offsetParent$.top;
	  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
	  var scrollTop = getScrollTop(scrollParent);
	  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
	  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
	  var viewSpaceAbove = containerTop - marginTop;
	  var viewSpaceBelow = viewHeight - menuTop;
	  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
	  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
	  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
	  var scrollUp = scrollTop + menuTop - marginTop;
	  var scrollDuration = 160;
	  switch (preferredPlacement) {
	    case 'auto':
	    case 'bottom':
	      // 1: the menu will fit, do nothing
	      if (viewSpaceBelow >= menuHeight) {
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 2: the menu will fit, if scrolled
	      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
	        }
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 3: the menu will fit, if constrained
	      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
	        }

	        // we want to provide as much of the menu as possible to the user,
	        // so give them whatever is available below rather than the minHeight.
	        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
	        return {
	          placement: 'bottom',
	          maxHeight: constrainedHeight
	        };
	      }

	      // 4. Forked beviour when there isn't enough space below

	      // AUTO: flip the menu, render above
	      if (preferredPlacement === 'auto' || isFixedPosition) {
	        // may need to be constrained after flipping
	        var _constrainedHeight = preferredMaxHeight;
	        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
	        if (spaceAbove >= minHeight) {
	          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight, preferredMaxHeight);
	        }
	        return {
	          placement: 'top',
	          maxHeight: _constrainedHeight
	        };
	      }

	      // BOTTOM: allow browser to increase scrollable area and immediately set scroll
	      if (preferredPlacement === 'bottom') {
	        if (shouldScroll) {
	          scrollTo(scrollParent, scrollDown);
	        }
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }
	      break;
	    case 'top':
	      // 1: the menu will fit, do nothing
	      if (viewSpaceAbove >= menuHeight) {
	        return {
	          placement: 'top',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 2: the menu will fit, if scrolled
	      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
	        }
	        return {
	          placement: 'top',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 3: the menu will fit, if constrained
	      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
	        var _constrainedHeight2 = preferredMaxHeight;

	        // we want to provide as much of the menu as possible to the user,
	        // so give them whatever is available below rather than the minHeight.
	        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
	          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
	        }
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
	        }
	        return {
	          placement: 'top',
	          maxHeight: _constrainedHeight2
	        };
	      }

	      // 4. not enough space, the browser WILL NOT increase scrollable area when
	      // absolutely positioned element rendered above the viewport (only below).
	      // Flip the menu, render below
	      return {
	        placement: 'bottom',
	        maxHeight: preferredMaxHeight
	      };
	    default:
	      throw new Error("Invalid placement provided \"".concat(preferredPlacement, "\"."));
	  }
	  return defaultState;
	}

	// Menu Component
	// ------------------------------

	function alignToControl(placement) {
	  var placementToCSSProp = {
	    bottom: 'top',
	    top: 'bottom'
	  };
	  return placement ? placementToCSSProp[placement] : 'bottom';
	}
	var coercePlacement = function coercePlacement(p) {
	  return p === 'auto' ? 'bottom' : p;
	};
	var menuCSS = function menuCSS(_ref2, unstyled) {
	  var _objectSpread2$1;
	  var placement = _ref2.placement,
	    _ref2$theme = _ref2.theme,
	    borderRadius = _ref2$theme.borderRadius,
	    spacing = _ref2$theme.spacing,
	    colors = _ref2$theme.colors;
	  return _objectSpread2((_objectSpread2$1 = {
	    label: 'menu'
	  }, _defineProperty(_objectSpread2$1, alignToControl(placement), '100%'), _defineProperty(_objectSpread2$1, "position", 'absolute'), _defineProperty(_objectSpread2$1, "width", '100%'), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
	    backgroundColor: colors.neutral0,
	    borderRadius: borderRadius,
	    boxShadow: '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)',
	    marginBottom: spacing.menuGutter,
	    marginTop: spacing.menuGutter
	  });
	};
	var PortalPlacementContext = /*#__PURE__*/reactExports.createContext(null);

	// NOTE: internal only
	var MenuPlacer = function MenuPlacer(props) {
	  var children = props.children,
	    minMenuHeight = props.minMenuHeight,
	    maxMenuHeight = props.maxMenuHeight,
	    menuPlacement = props.menuPlacement,
	    menuPosition = props.menuPosition,
	    menuShouldScrollIntoView = props.menuShouldScrollIntoView,
	    theme = props.theme;
	  var _ref3 = reactExports.useContext(PortalPlacementContext) || {},
	    setPortalPlacement = _ref3.setPortalPlacement;
	  var ref = reactExports.useRef(null);
	  var _useState = reactExports.useState(maxMenuHeight),
	    _useState2 = _slicedToArray(_useState, 2),
	    maxHeight = _useState2[0],
	    setMaxHeight = _useState2[1];
	  var _useState3 = reactExports.useState(null),
	    _useState4 = _slicedToArray(_useState3, 2),
	    placement = _useState4[0],
	    setPlacement = _useState4[1];
	  var controlHeight = theme.spacing.controlHeight;
	  index(function () {
	    var menuEl = ref.current;
	    if (!menuEl) return;

	    // DO NOT scroll if position is fixed
	    var isFixedPosition = menuPosition === 'fixed';
	    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
	    var state = getMenuPlacement({
	      maxHeight: maxMenuHeight,
	      menuEl: menuEl,
	      minHeight: minMenuHeight,
	      placement: menuPlacement,
	      shouldScroll: shouldScroll,
	      isFixedPosition: isFixedPosition,
	      controlHeight: controlHeight
	    });
	    setMaxHeight(state.maxHeight);
	    setPlacement(state.placement);
	    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
	  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight]);
	  return children({
	    ref: ref,
	    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
	      placement: placement || coercePlacement(menuPlacement),
	      maxHeight: maxHeight
	    })
	  });
	};
	var Menu = function Menu(props) {
	  var children = props.children,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'menu', {
	    menu: true
	  }), {
	    ref: innerRef
	  }, innerProps), children);
	};
	var Menu$1 = Menu;

	// ==============================
	// Menu List
	// ==============================

	var menuListCSS = function menuListCSS(_ref4, unstyled) {
	  var maxHeight = _ref4.maxHeight,
	    baseUnit = _ref4.theme.spacing.baseUnit;
	  return _objectSpread2({
	    maxHeight: maxHeight,
	    overflowY: 'auto',
	    position: 'relative',
	    // required for offset[Height, Top] > keyboard scroll
	    WebkitOverflowScrolling: 'touch'
	  }, unstyled ? {} : {
	    paddingBottom: baseUnit,
	    paddingTop: baseUnit
	  });
	};
	var MenuList = function MenuList(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    innerRef = props.innerRef,
	    isMulti = props.isMulti;
	  return jsx("div", _extends({}, getStyleProps(props, 'menuList', {
	    'menu-list': true,
	    'menu-list--is-multi': isMulti
	  }), {
	    ref: innerRef
	  }, innerProps), children);
	};

	// ==============================
	// Menu Notices
	// ==============================

	var noticeCSS = function noticeCSS(_ref5, unstyled) {
	  var _ref5$theme = _ref5.theme,
	    baseUnit = _ref5$theme.spacing.baseUnit,
	    colors = _ref5$theme.colors;
	  return _objectSpread2({
	    textAlign: 'center'
	  }, unstyled ? {} : {
	    color: colors.neutral40,
	    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px")
	  });
	};
	var noOptionsMessageCSS = noticeCSS;
	var loadingMessageCSS = noticeCSS;
	var NoOptionsMessage = function NoOptionsMessage(_ref6) {
	  var _ref6$children = _ref6.children,
	    children = _ref6$children === void 0 ? 'No options' : _ref6$children,
	    innerProps = _ref6.innerProps,
	    restProps = _objectWithoutProperties(_ref6, _excluded$3);
	  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
	    children: children,
	    innerProps: innerProps
	  }), 'noOptionsMessage', {
	    'menu-notice': true,
	    'menu-notice--no-options': true
	  }), innerProps), children);
	};
	var LoadingMessage = function LoadingMessage(_ref7) {
	  var _ref7$children = _ref7.children,
	    children = _ref7$children === void 0 ? 'Loading...' : _ref7$children,
	    innerProps = _ref7.innerProps,
	    restProps = _objectWithoutProperties(_ref7, _excluded2$1);
	  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
	    children: children,
	    innerProps: innerProps
	  }), 'loadingMessage', {
	    'menu-notice': true,
	    'menu-notice--loading': true
	  }), innerProps), children);
	};

	// ==============================
	// Menu Portal
	// ==============================

	var menuPortalCSS = function menuPortalCSS(_ref8) {
	  var rect = _ref8.rect,
	    offset = _ref8.offset,
	    position = _ref8.position;
	  return {
	    left: rect.left,
	    position: position,
	    top: offset,
	    width: rect.width,
	    zIndex: 1
	  };
	};
	var MenuPortal = function MenuPortal(props) {
	  var appendTo = props.appendTo,
	    children = props.children,
	    controlElement = props.controlElement,
	    innerProps = props.innerProps,
	    menuPlacement = props.menuPlacement,
	    menuPosition = props.menuPosition;
	  var menuPortalRef = reactExports.useRef(null);
	  var cleanupRef = reactExports.useRef(null);
	  var _useState5 = reactExports.useState(coercePlacement(menuPlacement)),
	    _useState6 = _slicedToArray(_useState5, 2),
	    placement = _useState6[0],
	    setPortalPlacement = _useState6[1];
	  var portalPlacementContext = reactExports.useMemo(function () {
	    return {
	      setPortalPlacement: setPortalPlacement
	    };
	  }, []);
	  var _useState7 = reactExports.useState(null),
	    _useState8 = _slicedToArray(_useState7, 2),
	    computedPosition = _useState8[0],
	    setComputedPosition = _useState8[1];
	  var updateComputedPosition = reactExports.useCallback(function () {
	    if (!controlElement) return;
	    var rect = getBoundingClientObj(controlElement);
	    var scrollDistance = menuPosition === 'fixed' ? 0 : window.pageYOffset;
	    var offset = rect[placement] + scrollDistance;
	    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
	      setComputedPosition({
	        offset: offset,
	        rect: rect
	      });
	    }
	  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
	  index(function () {
	    updateComputedPosition();
	  }, [updateComputedPosition]);
	  var runAutoUpdate = reactExports.useCallback(function () {
	    if (typeof cleanupRef.current === 'function') {
	      cleanupRef.current();
	      cleanupRef.current = null;
	    }
	    if (controlElement && menuPortalRef.current) {
	      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
	        elementResize: 'ResizeObserver' in window
	      });
	    }
	  }, [controlElement, updateComputedPosition]);
	  index(function () {
	    runAutoUpdate();
	  }, [runAutoUpdate]);
	  var setMenuPortalElement = reactExports.useCallback(function (menuPortalElement) {
	    menuPortalRef.current = menuPortalElement;
	    runAutoUpdate();
	  }, [runAutoUpdate]);

	  // bail early if required elements aren't present
	  if (!appendTo && menuPosition !== 'fixed' || !computedPosition) return null;

	  // same wrapper element whether fixed or portalled
	  var menuWrapper = jsx("div", _extends({
	    ref: setMenuPortalElement
	  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
	    offset: computedPosition.offset,
	    position: menuPosition,
	    rect: computedPosition.rect
	  }), 'menuPortal', {
	    'menu-portal': true
	  }), innerProps), children);
	  return jsx(PortalPlacementContext.Provider, {
	    value: portalPlacementContext
	  }, appendTo ? /*#__PURE__*/reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
	};

	// ==============================
	// Root Container
	// ==============================

	var containerCSS = function containerCSS(_ref) {
	  var isDisabled = _ref.isDisabled,
	    isRtl = _ref.isRtl;
	  return {
	    label: 'container',
	    direction: isRtl ? 'rtl' : undefined,
	    pointerEvents: isDisabled ? 'none' : undefined,
	    // cancel mouse events when disabled
	    position: 'relative'
	  };
	};
	var SelectContainer = function SelectContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    isDisabled = props.isDisabled,
	    isRtl = props.isRtl;
	  return jsx("div", _extends({}, getStyleProps(props, 'container', {
	    '--is-disabled': isDisabled,
	    '--is-rtl': isRtl
	  }), innerProps), children);
	};

	// ==============================
	// Value Container
	// ==============================

	var valueContainerCSS = function valueContainerCSS(_ref2, unstyled) {
	  var spacing = _ref2.theme.spacing,
	    isMulti = _ref2.isMulti,
	    hasValue = _ref2.hasValue,
	    controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
	  return _objectSpread2({
	    alignItems: 'center',
	    display: isMulti && hasValue && controlShouldRenderValue ? 'flex' : 'grid',
	    flex: 1,
	    flexWrap: 'wrap',
	    WebkitOverflowScrolling: 'touch',
	    position: 'relative',
	    overflow: 'hidden'
	  }, unstyled ? {} : {
	    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px")
	  });
	};
	var ValueContainer = function ValueContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    isMulti = props.isMulti,
	    hasValue = props.hasValue;
	  return jsx("div", _extends({}, getStyleProps(props, 'valueContainer', {
	    'value-container': true,
	    'value-container--is-multi': isMulti,
	    'value-container--has-value': hasValue
	  }), innerProps), children);
	};

	// ==============================
	// Indicator Container
	// ==============================

	var indicatorsContainerCSS = function indicatorsContainerCSS() {
	  return {
	    alignItems: 'center',
	    alignSelf: 'stretch',
	    display: 'flex',
	    flexShrink: 0
	  };
	};
	var IndicatorsContainer = function IndicatorsContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'indicatorsContainer', {
	    indicators: true
	  }), innerProps), children);
	};

	var _templateObject;
	var _excluded$2 = ["size"],
	  _excluded2 = ["innerProps", "isRtl", "size"];

	// ==============================
	// Dropdown & Clear Icons
	// ==============================
	var _ref2$2 = {
	  name: "8mmkcg",
	  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
	} ;
	var Svg = function Svg(_ref) {
	  var size = _ref.size,
	    props = _objectWithoutProperties(_ref, _excluded$2);
	  return jsx("svg", _extends({
	    height: size,
	    width: size,
	    viewBox: "0 0 20 20",
	    "aria-hidden": "true",
	    focusable: "false",
	    css: _ref2$2
	  }, props));
	};
	var CrossIcon = function CrossIcon(props) {
	  return jsx(Svg, _extends({
	    size: 20
	  }, props), jsx("path", {
	    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
	  }));
	};
	var DownChevron = function DownChevron(props) {
	  return jsx(Svg, _extends({
	    size: 20
	  }, props), jsx("path", {
	    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
	  }));
	};

	// ==============================
	// Dropdown & Clear Buttons
	// ==============================

	var baseCSS = function baseCSS(_ref3, unstyled) {
	  var isFocused = _ref3.isFocused,
	    _ref3$theme = _ref3.theme,
	    baseUnit = _ref3$theme.spacing.baseUnit,
	    colors = _ref3$theme.colors;
	  return _objectSpread2({
	    label: 'indicatorContainer',
	    display: 'flex',
	    transition: 'color 150ms'
	  }, unstyled ? {} : {
	    color: isFocused ? colors.neutral60 : colors.neutral20,
	    padding: baseUnit * 2,
	    ':hover': {
	      color: isFocused ? colors.neutral80 : colors.neutral40
	    }
	  });
	};
	var dropdownIndicatorCSS = baseCSS;
	var DropdownIndicator = function DropdownIndicator(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'dropdownIndicator', {
	    indicator: true,
	    'dropdown-indicator': true
	  }), innerProps), children || jsx(DownChevron, null));
	};
	var clearIndicatorCSS = baseCSS;
	var ClearIndicator = function ClearIndicator(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'clearIndicator', {
	    indicator: true,
	    'clear-indicator': true
	  }), innerProps), children || jsx(CrossIcon, null));
	};

	// ==============================
	// Separator
	// ==============================

	var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4, unstyled) {
	  var isDisabled = _ref4.isDisabled,
	    _ref4$theme = _ref4.theme,
	    baseUnit = _ref4$theme.spacing.baseUnit,
	    colors = _ref4$theme.colors;
	  return _objectSpread2({
	    label: 'indicatorSeparator',
	    alignSelf: 'stretch',
	    width: 1
	  }, unstyled ? {} : {
	    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
	    marginBottom: baseUnit * 2,
	    marginTop: baseUnit * 2
	  });
	};
	var IndicatorSeparator = function IndicatorSeparator(props) {
	  var innerProps = props.innerProps;
	  return jsx("span", _extends({}, innerProps, getStyleProps(props, 'indicatorSeparator', {
	    'indicator-separator': true
	  })));
	};

	// ==============================
	// Loading
	// ==============================

	var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
	var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5, unstyled) {
	  var isFocused = _ref5.isFocused,
	    size = _ref5.size,
	    _ref5$theme = _ref5.theme,
	    colors = _ref5$theme.colors,
	    baseUnit = _ref5$theme.spacing.baseUnit;
	  return _objectSpread2({
	    label: 'loadingIndicator',
	    display: 'flex',
	    transition: 'color 150ms',
	    alignSelf: 'center',
	    fontSize: size,
	    lineHeight: 1,
	    marginRight: size,
	    textAlign: 'center',
	    verticalAlign: 'middle'
	  }, unstyled ? {} : {
	    color: isFocused ? colors.neutral60 : colors.neutral20,
	    padding: baseUnit * 2
	  });
	};
	var LoadingDot = function LoadingDot(_ref6) {
	  var delay = _ref6.delay,
	    offset = _ref6.offset;
	  return jsx("span", {
	    css: /*#__PURE__*/css$2({
	      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
	      backgroundColor: 'currentColor',
	      borderRadius: '1em',
	      display: 'inline-block',
	      marginLeft: offset ? '1em' : undefined,
	      height: '1em',
	      verticalAlign: 'top',
	      width: '1em'
	    }, "" , "" )
	  });
	};
	var LoadingIndicator = function LoadingIndicator(_ref7) {
	  var innerProps = _ref7.innerProps,
	    isRtl = _ref7.isRtl,
	    _ref7$size = _ref7.size,
	    size = _ref7$size === void 0 ? 4 : _ref7$size,
	    restProps = _objectWithoutProperties(_ref7, _excluded2);
	  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
	    innerProps: innerProps,
	    isRtl: isRtl,
	    size: size
	  }), 'loadingIndicator', {
	    indicator: true,
	    'loading-indicator': true
	  }), innerProps), jsx(LoadingDot, {
	    delay: 0,
	    offset: isRtl
	  }), jsx(LoadingDot, {
	    delay: 160,
	    offset: true
	  }), jsx(LoadingDot, {
	    delay: 320,
	    offset: !isRtl
	  }));
	};

	var css$1 = function css(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    isFocused = _ref.isFocused,
	    _ref$theme = _ref.theme,
	    colors = _ref$theme.colors,
	    borderRadius = _ref$theme.borderRadius,
	    spacing = _ref$theme.spacing;
	  return _objectSpread2({
	    label: 'control',
	    alignItems: 'center',
	    cursor: 'default',
	    display: 'flex',
	    flexWrap: 'wrap',
	    justifyContent: 'space-between',
	    minHeight: spacing.controlHeight,
	    outline: '0 !important',
	    position: 'relative',
	    transition: 'all 100ms'
	  }, unstyled ? {} : {
	    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
	    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
	    borderRadius: borderRadius,
	    borderStyle: 'solid',
	    borderWidth: 1,
	    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : undefined,
	    '&:hover': {
	      borderColor: isFocused ? colors.primary : colors.neutral30
	    }
	  });
	};
	var Control = function Control(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    isFocused = props.isFocused,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps,
	    menuIsOpen = props.menuIsOpen;
	  return jsx("div", _extends({
	    ref: innerRef
	  }, getStyleProps(props, 'control', {
	    control: true,
	    'control--is-disabled': isDisabled,
	    'control--is-focused': isFocused,
	    'control--menu-is-open': menuIsOpen
	  }), innerProps, {
	    "aria-disabled": isDisabled || undefined
	  }), children);
	};
	var Control$1 = Control;

	var _excluded$1 = ["data"];
	var groupCSS = function groupCSS(_ref, unstyled) {
	  var spacing = _ref.theme.spacing;
	  return unstyled ? {} : {
	    paddingBottom: spacing.baseUnit * 2,
	    paddingTop: spacing.baseUnit * 2
	  };
	};
	var Group = function Group(props) {
	  var children = props.children,
	    cx = props.cx,
	    getStyles = props.getStyles,
	    getClassNames = props.getClassNames,
	    Heading = props.Heading,
	    headingProps = props.headingProps,
	    innerProps = props.innerProps,
	    label = props.label,
	    theme = props.theme,
	    selectProps = props.selectProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'group', {
	    group: true
	  }), innerProps), jsx(Heading, _extends({}, headingProps, {
	    selectProps: selectProps,
	    theme: theme,
	    getStyles: getStyles,
	    getClassNames: getClassNames,
	    cx: cx
	  }), label), jsx("div", null, children));
	};
	var groupHeadingCSS = function groupHeadingCSS(_ref2, unstyled) {
	  var _ref2$theme = _ref2.theme,
	    colors = _ref2$theme.colors,
	    spacing = _ref2$theme.spacing;
	  return _objectSpread2({
	    label: 'group',
	    cursor: 'default',
	    display: 'block'
	  }, unstyled ? {} : {
	    color: colors.neutral40,
	    fontSize: '75%',
	    fontWeight: 500,
	    marginBottom: '0.25em',
	    paddingLeft: spacing.baseUnit * 3,
	    paddingRight: spacing.baseUnit * 3,
	    textTransform: 'uppercase'
	  });
	};
	var GroupHeading = function GroupHeading(props) {
	  var _cleanCommonProps = cleanCommonProps(props);
	    _cleanCommonProps.data;
	    var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
	  return jsx("div", _extends({}, getStyleProps(props, 'groupHeading', {
	    'group-heading': true
	  }), innerProps));
	};
	var Group$1 = Group;

	var _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
	var inputCSS = function inputCSS(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    value = _ref.value,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2(_objectSpread2({
	    visibility: isDisabled ? 'hidden' : 'visible',
	    // force css to recompute when value change due to @emotion bug.
	    // We can remove it whenever the bug is fixed.
	    transform: value ? 'translateZ(0)' : ''
	  }, containerStyle), unstyled ? {} : {
	    margin: spacing.baseUnit / 2,
	    paddingBottom: spacing.baseUnit / 2,
	    paddingTop: spacing.baseUnit / 2,
	    color: colors.neutral80
	  });
	};
	var spacingStyle = {
	  gridArea: '1 / 2',
	  font: 'inherit',
	  minWidth: '2px',
	  border: 0,
	  margin: 0,
	  outline: 0,
	  padding: 0
	};
	var containerStyle = {
	  flex: '1 1 auto',
	  display: 'inline-grid',
	  gridArea: '1 / 1 / 2 / 3',
	  gridTemplateColumns: '0 min-content',
	  '&:after': _objectSpread2({
	    content: 'attr(data-value) " "',
	    visibility: 'hidden',
	    whiteSpace: 'pre'
	  }, spacingStyle)
	};
	var inputStyle = function inputStyle(isHidden) {
	  return _objectSpread2({
	    label: 'input',
	    color: 'inherit',
	    background: 0,
	    opacity: isHidden ? 0 : 1,
	    width: '100%'
	  }, spacingStyle);
	};
	var Input = function Input(props) {
	  var cx = props.cx,
	    value = props.value;
	  var _cleanCommonProps = cleanCommonProps(props),
	    innerRef = _cleanCommonProps.innerRef,
	    isDisabled = _cleanCommonProps.isDisabled,
	    isHidden = _cleanCommonProps.isHidden,
	    inputClassName = _cleanCommonProps.inputClassName,
	    innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
	  return jsx("div", _extends({}, getStyleProps(props, 'input', {
	    'input-container': true
	  }), {
	    "data-value": value || ''
	  }), jsx("input", _extends({
	    className: cx({
	      input: true
	    }, inputClassName),
	    ref: innerRef,
	    style: inputStyle(isHidden),
	    disabled: isDisabled
	  }, innerProps)));
	};
	var Input$1 = Input;

	var multiValueCSS = function multiValueCSS(_ref, unstyled) {
	  var _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    borderRadius = _ref$theme.borderRadius,
	    colors = _ref$theme.colors;
	  return _objectSpread2({
	    label: 'multiValue',
	    display: 'flex',
	    minWidth: 0
	  }, unstyled ? {} : {
	    backgroundColor: colors.neutral10,
	    borderRadius: borderRadius / 2,
	    margin: spacing.baseUnit / 2
	  });
	};
	var multiValueLabelCSS = function multiValueLabelCSS(_ref2, unstyled) {
	  var _ref2$theme = _ref2.theme,
	    borderRadius = _ref2$theme.borderRadius,
	    colors = _ref2$theme.colors,
	    cropWithEllipsis = _ref2.cropWithEllipsis;
	  return _objectSpread2({
	    overflow: 'hidden',
	    textOverflow: cropWithEllipsis || cropWithEllipsis === undefined ? 'ellipsis' : undefined,
	    whiteSpace: 'nowrap'
	  }, unstyled ? {} : {
	    borderRadius: borderRadius / 2,
	    color: colors.neutral80,
	    fontSize: '85%',
	    padding: 3,
	    paddingLeft: 6
	  });
	};
	var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3, unstyled) {
	  var _ref3$theme = _ref3.theme,
	    spacing = _ref3$theme.spacing,
	    borderRadius = _ref3$theme.borderRadius,
	    colors = _ref3$theme.colors,
	    isFocused = _ref3.isFocused;
	  return _objectSpread2({
	    alignItems: 'center',
	    display: 'flex'
	  }, unstyled ? {} : {
	    borderRadius: borderRadius / 2,
	    backgroundColor: isFocused ? colors.dangerLight : undefined,
	    paddingLeft: spacing.baseUnit,
	    paddingRight: spacing.baseUnit,
	    ':hover': {
	      backgroundColor: colors.dangerLight,
	      color: colors.danger
	    }
	  });
	};
	var MultiValueGeneric = function MultiValueGeneric(_ref4) {
	  var children = _ref4.children,
	    innerProps = _ref4.innerProps;
	  return jsx("div", innerProps, children);
	};
	var MultiValueContainer = MultiValueGeneric;
	var MultiValueLabel = MultiValueGeneric;
	function MultiValueRemove(_ref5) {
	  var children = _ref5.children,
	    innerProps = _ref5.innerProps;
	  return jsx("div", _extends({
	    role: "button"
	  }, innerProps), children || jsx(CrossIcon, {
	    size: 14
	  }));
	}
	var MultiValue = function MultiValue(props) {
	  var children = props.children,
	    components = props.components,
	    data = props.data,
	    innerProps = props.innerProps,
	    isDisabled = props.isDisabled,
	    removeProps = props.removeProps,
	    selectProps = props.selectProps;
	  var Container = components.Container,
	    Label = components.Label,
	    Remove = components.Remove;
	  return jsx(Container, {
	    data: data,
	    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, 'multiValue', {
	      'multi-value': true,
	      'multi-value--is-disabled': isDisabled
	    })), innerProps),
	    selectProps: selectProps
	  }, jsx(Label, {
	    data: data,
	    innerProps: _objectSpread2({}, getStyleProps(props, 'multiValueLabel', {
	      'multi-value__label': true
	    })),
	    selectProps: selectProps
	  }, children), jsx(Remove, {
	    data: data,
	    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, 'multiValueRemove', {
	      'multi-value__remove': true
	    })), {}, {
	      'aria-label': "Remove ".concat(children || 'option')
	    }, removeProps),
	    selectProps: selectProps
	  }));
	};
	var MultiValue$1 = MultiValue;

	var optionCSS = function optionCSS(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    isFocused = _ref.isFocused,
	    isSelected = _ref.isSelected,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2({
	    label: 'option',
	    cursor: 'default',
	    display: 'block',
	    fontSize: 'inherit',
	    width: '100%',
	    userSelect: 'none',
	    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)'
	  }, unstyled ? {} : {
	    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
	    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
	    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
	    // provide some affordance on touch devices
	    ':active': {
	      backgroundColor: !isDisabled ? isSelected ? colors.primary : colors.primary50 : undefined
	    }
	  });
	};
	var Option = function Option(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    isFocused = props.isFocused,
	    isSelected = props.isSelected,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'option', {
	    option: true,
	    'option--is-disabled': isDisabled,
	    'option--is-focused': isFocused,
	    'option--is-selected': isSelected
	  }), {
	    ref: innerRef,
	    "aria-disabled": isDisabled
	  }, innerProps), children);
	};
	var Option$1 = Option;

	var placeholderCSS = function placeholderCSS(_ref, unstyled) {
	  var _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2({
	    label: 'placeholder',
	    gridArea: '1 / 1 / 2 / 3'
	  }, unstyled ? {} : {
	    color: colors.neutral50,
	    marginLeft: spacing.baseUnit / 2,
	    marginRight: spacing.baseUnit / 2
	  });
	};
	var Placeholder = function Placeholder(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'placeholder', {
	    placeholder: true
	  }), innerProps), children);
	};
	var Placeholder$1 = Placeholder;

	var css = function css(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2({
	    label: 'singleValue',
	    gridArea: '1 / 1 / 2 / 3',
	    maxWidth: '100%',
	    overflow: 'hidden',
	    textOverflow: 'ellipsis',
	    whiteSpace: 'nowrap'
	  }, unstyled ? {} : {
	    color: isDisabled ? colors.neutral40 : colors.neutral80,
	    marginLeft: spacing.baseUnit / 2,
	    marginRight: spacing.baseUnit / 2
	  });
	};
	var SingleValue = function SingleValue(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    innerProps = props.innerProps;
	  return jsx("div", _extends({}, getStyleProps(props, 'singleValue', {
	    'single-value': true,
	    'single-value--is-disabled': isDisabled
	  }), innerProps), children);
	};
	var SingleValue$1 = SingleValue;

	var components = {
	  ClearIndicator: ClearIndicator,
	  Control: Control$1,
	  DropdownIndicator: DropdownIndicator,
	  DownChevron: DownChevron,
	  CrossIcon: CrossIcon,
	  Group: Group$1,
	  GroupHeading: GroupHeading,
	  IndicatorsContainer: IndicatorsContainer,
	  IndicatorSeparator: IndicatorSeparator,
	  Input: Input$1,
	  LoadingIndicator: LoadingIndicator,
	  Menu: Menu$1,
	  MenuList: MenuList,
	  MenuPortal: MenuPortal,
	  LoadingMessage: LoadingMessage,
	  NoOptionsMessage: NoOptionsMessage,
	  MultiValue: MultiValue$1,
	  MultiValueContainer: MultiValueContainer,
	  MultiValueLabel: MultiValueLabel,
	  MultiValueRemove: MultiValueRemove,
	  Option: Option$1,
	  Placeholder: Placeholder$1,
	  SelectContainer: SelectContainer,
	  SingleValue: SingleValue$1,
	  ValueContainer: ValueContainer
	};
	var defaultComponents = function defaultComponents(props) {
	  return _objectSpread2(_objectSpread2({}, components), props.components);
	};

	var safeIsNaN = Number.isNaN ||
	    function ponyfill(value) {
	        return typeof value === 'number' && value !== value;
	    };
	function isEqual(first, second) {
	    if (first === second) {
	        return true;
	    }
	    if (safeIsNaN(first) && safeIsNaN(second)) {
	        return true;
	    }
	    return false;
	}
	function areInputsEqual(newInputs, lastInputs) {
	    if (newInputs.length !== lastInputs.length) {
	        return false;
	    }
	    for (var i = 0; i < newInputs.length; i++) {
	        if (!isEqual(newInputs[i], lastInputs[i])) {
	            return false;
	        }
	    }
	    return true;
	}

	function memoizeOne(resultFn, isEqual) {
	    if (isEqual === void 0) { isEqual = areInputsEqual; }
	    var cache = null;
	    function memoized() {
	        var newArgs = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            newArgs[_i] = arguments[_i];
	        }
	        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
	            return cache.lastResult;
	        }
	        var lastResult = resultFn.apply(this, newArgs);
	        cache = {
	            lastResult: lastResult,
	            lastArgs: newArgs,
	            lastThis: this,
	        };
	        return lastResult;
	    }
	    memoized.clear = function clear() {
	        cache = null;
	    };
	    return memoized;
	}

	// Assistive text to describe visual elements. Hidden for sighted users.
	var _ref = {
	  name: "7pg0cj-a11yText",
	  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
	} ;
	var A11yText = function A11yText(props) {
	  return jsx("span", _extends({
	    css: _ref
	  }, props));
	};
	var A11yText$1 = A11yText;

	var defaultAriaLiveMessages = {
	  guidance: function guidance(props) {
	    var isSearchable = props.isSearchable,
	      isMulti = props.isMulti,
	      tabSelectsValue = props.tabSelectsValue,
	      context = props.context,
	      isInitialFocus = props.isInitialFocus;
	    switch (context) {
	      case 'menu':
	        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");
	      case 'input':
	        return isInitialFocus ? "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '') : '';
	      case 'value':
	        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';
	      default:
	        return '';
	    }
	  },
	  onChange: function onChange(props) {
	    var action = props.action,
	      _props$label = props.label,
	      label = _props$label === void 0 ? '' : _props$label,
	      labels = props.labels,
	      isDisabled = props.isDisabled;
	    switch (action) {
	      case 'deselect-option':
	      case 'pop-value':
	      case 'remove-value':
	        return "option ".concat(label, ", deselected.");
	      case 'clear':
	        return 'All selected options have been cleared.';
	      case 'initial-input-focus':
	        return "option".concat(labels.length > 1 ? 's' : '', " ").concat(labels.join(','), ", selected.");
	      case 'select-option':
	        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
	      default:
	        return '';
	    }
	  },
	  onFocus: function onFocus(props) {
	    var context = props.context,
	      focused = props.focused,
	      options = props.options,
	      _props$label2 = props.label,
	      label = _props$label2 === void 0 ? '' : _props$label2,
	      selectValue = props.selectValue,
	      isDisabled = props.isDisabled,
	      isSelected = props.isSelected,
	      isAppleDevice = props.isAppleDevice;
	    var getArrayIndex = function getArrayIndex(arr, item) {
	      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
	    };
	    if (context === 'value' && selectValue) {
	      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
	    }
	    if (context === 'menu' && isAppleDevice) {
	      var disabled = isDisabled ? ' disabled' : '';
	      var status = "".concat(isSelected ? ' selected' : '').concat(disabled);
	      return "".concat(label).concat(status, ", ").concat(getArrayIndex(options, focused), ".");
	    }
	    return '';
	  },
	  onFilter: function onFilter(props) {
	    var inputValue = props.inputValue,
	      resultsMessage = props.resultsMessage;
	    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
	  }
	};

	var LiveRegion = function LiveRegion(props) {
	  var ariaSelection = props.ariaSelection,
	    focusedOption = props.focusedOption,
	    focusedValue = props.focusedValue,
	    focusableOptions = props.focusableOptions,
	    isFocused = props.isFocused,
	    selectValue = props.selectValue,
	    selectProps = props.selectProps,
	    id = props.id,
	    isAppleDevice = props.isAppleDevice;
	  var ariaLiveMessages = selectProps.ariaLiveMessages,
	    getOptionLabel = selectProps.getOptionLabel,
	    inputValue = selectProps.inputValue,
	    isMulti = selectProps.isMulti,
	    isOptionDisabled = selectProps.isOptionDisabled,
	    isSearchable = selectProps.isSearchable,
	    menuIsOpen = selectProps.menuIsOpen,
	    options = selectProps.options,
	    screenReaderStatus = selectProps.screenReaderStatus,
	    tabSelectsValue = selectProps.tabSelectsValue,
	    isLoading = selectProps.isLoading;
	  var ariaLabel = selectProps['aria-label'];
	  var ariaLive = selectProps['aria-live'];

	  // Update aria live message configuration when prop changes
	  var messages = reactExports.useMemo(function () {
	    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
	  }, [ariaLiveMessages]);

	  // Update aria live selected option when prop changes
	  var ariaSelected = reactExports.useMemo(function () {
	    var message = '';
	    if (ariaSelection && messages.onChange) {
	      var option = ariaSelection.option,
	        selectedOptions = ariaSelection.options,
	        removedValue = ariaSelection.removedValue,
	        removedValues = ariaSelection.removedValues,
	        value = ariaSelection.value;
	      // select-option when !isMulti does not return option so we assume selected option is value
	      var asOption = function asOption(val) {
	        return !Array.isArray(val) ? val : null;
	      };

	      // If there is just one item from the action then get its label
	      var selected = removedValue || option || asOption(value);
	      var label = selected ? getOptionLabel(selected) : '';

	      // If there are multiple items from the action then return an array of labels
	      var multiSelected = selectedOptions || removedValues || undefined;
	      var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];
	      var onChangeProps = _objectSpread2({
	        // multiSelected items are usually items that have already been selected
	        // or set by the user as a default value so we assume they are not disabled
	        isDisabled: selected && isOptionDisabled(selected, selectValue),
	        label: label,
	        labels: labels
	      }, ariaSelection);
	      message = messages.onChange(onChangeProps);
	    }
	    return message;
	  }, [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel]);
	  var ariaFocused = reactExports.useMemo(function () {
	    var focusMsg = '';
	    var focused = focusedOption || focusedValue;
	    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
	    if (focused && messages.onFocus) {
	      var onFocusProps = {
	        focused: focused,
	        label: getOptionLabel(focused),
	        isDisabled: isOptionDisabled(focused, selectValue),
	        isSelected: isSelected,
	        options: focusableOptions,
	        context: focused === focusedOption ? 'menu' : 'value',
	        selectValue: selectValue,
	        isAppleDevice: isAppleDevice
	      };
	      focusMsg = messages.onFocus(onFocusProps);
	    }
	    return focusMsg;
	  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, focusableOptions, selectValue, isAppleDevice]);
	  var ariaResults = reactExports.useMemo(function () {
	    var resultsMsg = '';
	    if (menuIsOpen && options.length && !isLoading && messages.onFilter) {
	      var resultsMessage = screenReaderStatus({
	        count: focusableOptions.length
	      });
	      resultsMsg = messages.onFilter({
	        inputValue: inputValue,
	        resultsMessage: resultsMessage
	      });
	    }
	    return resultsMsg;
	  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus, isLoading]);
	  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus';
	  var ariaGuidance = reactExports.useMemo(function () {
	    var guidanceMsg = '';
	    if (messages.guidance) {
	      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
	      guidanceMsg = messages.guidance({
	        'aria-label': ariaLabel,
	        context: context,
	        isDisabled: focusedOption && isOptionDisabled(focusedOption, selectValue),
	        isMulti: isMulti,
	        isSearchable: isSearchable,
	        tabSelectsValue: tabSelectsValue,
	        isInitialFocus: isInitialFocus
	      });
	    }
	    return guidanceMsg;
	  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue, isInitialFocus]);
	  var ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
	    id: "aria-selection"
	  }, ariaSelected), jsx("span", {
	    id: "aria-focused"
	  }, ariaFocused), jsx("span", {
	    id: "aria-results"
	  }, ariaResults), jsx("span", {
	    id: "aria-guidance"
	  }, ariaGuidance));
	  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
	    id: id
	  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
	    "aria-live": ariaLive,
	    "aria-atomic": "false",
	    "aria-relevant": "additions text",
	    role: "log"
	  }, isFocused && !isInitialFocus && ScreenReaderText));
	};
	var LiveRegion$1 = LiveRegion;

	var diacritics = [{
	  base: 'A',
	  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
	}, {
	  base: 'AA',
	  letters: "\uA732"
	}, {
	  base: 'AE',
	  letters: "\xC6\u01FC\u01E2"
	}, {
	  base: 'AO',
	  letters: "\uA734"
	}, {
	  base: 'AU',
	  letters: "\uA736"
	}, {
	  base: 'AV',
	  letters: "\uA738\uA73A"
	}, {
	  base: 'AY',
	  letters: "\uA73C"
	}, {
	  base: 'B',
	  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
	}, {
	  base: 'C',
	  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
	}, {
	  base: 'D',
	  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
	}, {
	  base: 'DZ',
	  letters: "\u01F1\u01C4"
	}, {
	  base: 'Dz',
	  letters: "\u01F2\u01C5"
	}, {
	  base: 'E',
	  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
	}, {
	  base: 'F',
	  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
	}, {
	  base: 'G',
	  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
	}, {
	  base: 'H',
	  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
	}, {
	  base: 'I',
	  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
	}, {
	  base: 'J',
	  letters: "J\u24BF\uFF2A\u0134\u0248"
	}, {
	  base: 'K',
	  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
	}, {
	  base: 'L',
	  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
	}, {
	  base: 'LJ',
	  letters: "\u01C7"
	}, {
	  base: 'Lj',
	  letters: "\u01C8"
	}, {
	  base: 'M',
	  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
	}, {
	  base: 'N',
	  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
	}, {
	  base: 'NJ',
	  letters: "\u01CA"
	}, {
	  base: 'Nj',
	  letters: "\u01CB"
	}, {
	  base: 'O',
	  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
	}, {
	  base: 'OI',
	  letters: "\u01A2"
	}, {
	  base: 'OO',
	  letters: "\uA74E"
	}, {
	  base: 'OU',
	  letters: "\u0222"
	}, {
	  base: 'P',
	  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
	}, {
	  base: 'Q',
	  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
	}, {
	  base: 'R',
	  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
	}, {
	  base: 'S',
	  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
	}, {
	  base: 'T',
	  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
	}, {
	  base: 'TZ',
	  letters: "\uA728"
	}, {
	  base: 'U',
	  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
	}, {
	  base: 'V',
	  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
	}, {
	  base: 'VY',
	  letters: "\uA760"
	}, {
	  base: 'W',
	  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
	}, {
	  base: 'X',
	  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
	}, {
	  base: 'Y',
	  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
	}, {
	  base: 'Z',
	  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
	}, {
	  base: 'a',
	  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
	}, {
	  base: 'aa',
	  letters: "\uA733"
	}, {
	  base: 'ae',
	  letters: "\xE6\u01FD\u01E3"
	}, {
	  base: 'ao',
	  letters: "\uA735"
	}, {
	  base: 'au',
	  letters: "\uA737"
	}, {
	  base: 'av',
	  letters: "\uA739\uA73B"
	}, {
	  base: 'ay',
	  letters: "\uA73D"
	}, {
	  base: 'b',
	  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
	}, {
	  base: 'c',
	  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
	}, {
	  base: 'd',
	  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
	}, {
	  base: 'dz',
	  letters: "\u01F3\u01C6"
	}, {
	  base: 'e',
	  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
	}, {
	  base: 'f',
	  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
	}, {
	  base: 'g',
	  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
	}, {
	  base: 'h',
	  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
	}, {
	  base: 'hv',
	  letters: "\u0195"
	}, {
	  base: 'i',
	  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
	}, {
	  base: 'j',
	  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
	}, {
	  base: 'k',
	  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
	}, {
	  base: 'l',
	  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
	}, {
	  base: 'lj',
	  letters: "\u01C9"
	}, {
	  base: 'm',
	  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
	}, {
	  base: 'n',
	  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
	}, {
	  base: 'nj',
	  letters: "\u01CC"
	}, {
	  base: 'o',
	  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
	}, {
	  base: 'oi',
	  letters: "\u01A3"
	}, {
	  base: 'ou',
	  letters: "\u0223"
	}, {
	  base: 'oo',
	  letters: "\uA74F"
	}, {
	  base: 'p',
	  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
	}, {
	  base: 'q',
	  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
	}, {
	  base: 'r',
	  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
	}, {
	  base: 's',
	  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
	}, {
	  base: 't',
	  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
	}, {
	  base: 'tz',
	  letters: "\uA729"
	}, {
	  base: 'u',
	  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
	}, {
	  base: 'v',
	  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
	}, {
	  base: 'vy',
	  letters: "\uA761"
	}, {
	  base: 'w',
	  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
	}, {
	  base: 'x',
	  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
	}, {
	  base: 'y',
	  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
	}, {
	  base: 'z',
	  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
	}];
	var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
	  return d.letters;
	}).join('') + ']', 'g');
	var diacriticToBase = {};
	for (var i = 0; i < diacritics.length; i++) {
	  var diacritic = diacritics[i];
	  for (var j = 0; j < diacritic.letters.length; j++) {
	    diacriticToBase[diacritic.letters[j]] = diacritic.base;
	  }
	}
	var stripDiacritics = function stripDiacritics(str) {
	  return str.replace(anyDiacritic, function (match) {
	    return diacriticToBase[match];
	  });
	};

	var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
	var trimString = function trimString(str) {
	  return str.replace(/^\s+|\s+$/g, '');
	};
	var defaultStringify = function defaultStringify(option) {
	  return "".concat(option.label, " ").concat(option.value);
	};
	var createFilter = function createFilter(config) {
	  return function (option, rawInput) {
	    // eslint-disable-next-line no-underscore-dangle
	    if (option.data.__isNew__) return true;
	    var _ignoreCase$ignoreAcc = _objectSpread2({
	        ignoreCase: true,
	        ignoreAccents: true,
	        stringify: defaultStringify,
	        trim: true,
	        matchFrom: 'any'
	      }, config),
	      ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
	      ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
	      stringify = _ignoreCase$ignoreAcc.stringify,
	      trim = _ignoreCase$ignoreAcc.trim,
	      matchFrom = _ignoreCase$ignoreAcc.matchFrom;
	    var input = trim ? trimString(rawInput) : rawInput;
	    var candidate = trim ? trimString(stringify(option)) : stringify(option);
	    if (ignoreCase) {
	      input = input.toLowerCase();
	      candidate = candidate.toLowerCase();
	    }
	    if (ignoreAccents) {
	      input = memoizedStripDiacriticsForInput(input);
	      candidate = stripDiacritics(candidate);
	    }
	    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
	  };
	};

	var _excluded = ["innerRef"];
	function DummyInput(_ref) {
	  var innerRef = _ref.innerRef,
	    props = _objectWithoutProperties(_ref, _excluded);
	  // Remove animation props not meant for HTML elements
	  var filteredProps = removeProps(props, 'onExited', 'in', 'enter', 'exit', 'appear');
	  return jsx("input", _extends({
	    ref: innerRef
	  }, filteredProps, {
	    css: /*#__PURE__*/css$2({
	      label: 'dummyInput',
	      // get rid of any default styles
	      background: 0,
	      border: 0,
	      // important! this hides the flashing cursor
	      caretColor: 'transparent',
	      fontSize: 'inherit',
	      gridArea: '1 / 1 / 2 / 3',
	      outline: 0,
	      padding: 0,
	      // important! without `width` browsers won't allow focus
	      width: 1,
	      // remove cursor on desktop
	      color: 'transparent',
	      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
	      left: -100,
	      opacity: 0,
	      position: 'relative',
	      transform: 'scale(.01)'
	    }, "" , "" )
	  }));
	}

	var cancelScroll = function cancelScroll(event) {
	  if (event.cancelable) event.preventDefault();
	  event.stopPropagation();
	};
	function useScrollCapture(_ref) {
	  var isEnabled = _ref.isEnabled,
	    onBottomArrive = _ref.onBottomArrive,
	    onBottomLeave = _ref.onBottomLeave,
	    onTopArrive = _ref.onTopArrive,
	    onTopLeave = _ref.onTopLeave;
	  var isBottom = reactExports.useRef(false);
	  var isTop = reactExports.useRef(false);
	  var touchStart = reactExports.useRef(0);
	  var scrollTarget = reactExports.useRef(null);
	  var handleEventDelta = reactExports.useCallback(function (event, delta) {
	    if (scrollTarget.current === null) return;
	    var _scrollTarget$current = scrollTarget.current,
	      scrollTop = _scrollTarget$current.scrollTop,
	      scrollHeight = _scrollTarget$current.scrollHeight,
	      clientHeight = _scrollTarget$current.clientHeight;
	    var target = scrollTarget.current;
	    var isDeltaPositive = delta > 0;
	    var availableScroll = scrollHeight - clientHeight - scrollTop;
	    var shouldCancelScroll = false;

	    // reset bottom/top flags
	    if (availableScroll > delta && isBottom.current) {
	      if (onBottomLeave) onBottomLeave(event);
	      isBottom.current = false;
	    }
	    if (isDeltaPositive && isTop.current) {
	      if (onTopLeave) onTopLeave(event);
	      isTop.current = false;
	    }

	    // bottom limit
	    if (isDeltaPositive && delta > availableScroll) {
	      if (onBottomArrive && !isBottom.current) {
	        onBottomArrive(event);
	      }
	      target.scrollTop = scrollHeight;
	      shouldCancelScroll = true;
	      isBottom.current = true;

	      // top limit
	    } else if (!isDeltaPositive && -delta > scrollTop) {
	      if (onTopArrive && !isTop.current) {
	        onTopArrive(event);
	      }
	      target.scrollTop = 0;
	      shouldCancelScroll = true;
	      isTop.current = true;
	    }

	    // cancel scroll
	    if (shouldCancelScroll) {
	      cancelScroll(event);
	    }
	  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
	  var onWheel = reactExports.useCallback(function (event) {
	    handleEventDelta(event, event.deltaY);
	  }, [handleEventDelta]);
	  var onTouchStart = reactExports.useCallback(function (event) {
	    // set touch start so we can calculate touchmove delta
	    touchStart.current = event.changedTouches[0].clientY;
	  }, []);
	  var onTouchMove = reactExports.useCallback(function (event) {
	    var deltaY = touchStart.current - event.changedTouches[0].clientY;
	    handleEventDelta(event, deltaY);
	  }, [handleEventDelta]);
	  var startListening = reactExports.useCallback(function (el) {
	    // bail early if no element is available to attach to
	    if (!el) return;
	    var notPassive = supportsPassiveEvents ? {
	      passive: false
	    } : false;
	    el.addEventListener('wheel', onWheel, notPassive);
	    el.addEventListener('touchstart', onTouchStart, notPassive);
	    el.addEventListener('touchmove', onTouchMove, notPassive);
	  }, [onTouchMove, onTouchStart, onWheel]);
	  var stopListening = reactExports.useCallback(function (el) {
	    // bail early if no element is available to detach from
	    if (!el) return;
	    el.removeEventListener('wheel', onWheel, false);
	    el.removeEventListener('touchstart', onTouchStart, false);
	    el.removeEventListener('touchmove', onTouchMove, false);
	  }, [onTouchMove, onTouchStart, onWheel]);
	  reactExports.useEffect(function () {
	    if (!isEnabled) return;
	    var element = scrollTarget.current;
	    startListening(element);
	    return function () {
	      stopListening(element);
	    };
	  }, [isEnabled, startListening, stopListening]);
	  return function (element) {
	    scrollTarget.current = element;
	  };
	}

	var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
	var LOCK_STYLES = {
	  boxSizing: 'border-box',
	  // account for possible declaration `width: 100%;` on body
	  overflow: 'hidden',
	  position: 'relative',
	  height: '100%'
	};
	function preventTouchMove(e) {
	  if (e.cancelable) e.preventDefault();
	}
	function allowTouchMove(e) {
	  e.stopPropagation();
	}
	function preventInertiaScroll() {
	  var top = this.scrollTop;
	  var totalScroll = this.scrollHeight;
	  var currentScroll = top + this.offsetHeight;
	  if (top === 0) {
	    this.scrollTop = 1;
	  } else if (currentScroll === totalScroll) {
	    this.scrollTop = top - 1;
	  }
	}

	// `ontouchstart` check works on most browsers
	// `maxTouchPoints` works on IE10/11 and Surface
	function isTouchDevice() {
	  return 'ontouchstart' in window || navigator.maxTouchPoints;
	}
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	var activeScrollLocks = 0;
	var listenerOptions = {
	  capture: false,
	  passive: false
	};
	function useScrollLock(_ref) {
	  var isEnabled = _ref.isEnabled,
	    _ref$accountForScroll = _ref.accountForScrollbars,
	    accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
	  var originalStyles = reactExports.useRef({});
	  var scrollTarget = reactExports.useRef(null);
	  var addScrollLock = reactExports.useCallback(function (touchScrollTarget) {
	    if (!canUseDOM) return;
	    var target = document.body;
	    var targetStyle = target && target.style;
	    if (accountForScrollbars) {
	      // store any styles already applied to the body
	      STYLE_KEYS.forEach(function (key) {
	        var val = targetStyle && targetStyle[key];
	        originalStyles.current[key] = val;
	      });
	    }

	    // apply the lock styles and padding if this is the first scroll lock
	    if (accountForScrollbars && activeScrollLocks < 1) {
	      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
	      var clientWidth = document.body ? document.body.clientWidth : 0;
	      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
	      Object.keys(LOCK_STYLES).forEach(function (key) {
	        var val = LOCK_STYLES[key];
	        if (targetStyle) {
	          targetStyle[key] = val;
	        }
	      });
	      if (targetStyle) {
	        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
	      }
	    }

	    // account for touch devices
	    if (target && isTouchDevice()) {
	      // Mobile Safari ignores { overflow: hidden } declaration on the body.
	      target.addEventListener('touchmove', preventTouchMove, listenerOptions);

	      // Allow scroll on provided target
	      if (touchScrollTarget) {
	        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
	        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
	      }
	    }

	    // increment active scroll locks
	    activeScrollLocks += 1;
	  }, [accountForScrollbars]);
	  var removeScrollLock = reactExports.useCallback(function (touchScrollTarget) {
	    if (!canUseDOM) return;
	    var target = document.body;
	    var targetStyle = target && target.style;

	    // safely decrement active scroll locks
	    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);

	    // reapply original body styles, if any
	    if (accountForScrollbars && activeScrollLocks < 1) {
	      STYLE_KEYS.forEach(function (key) {
	        var val = originalStyles.current[key];
	        if (targetStyle) {
	          targetStyle[key] = val;
	        }
	      });
	    }

	    // remove touch listeners
	    if (target && isTouchDevice()) {
	      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);
	      if (touchScrollTarget) {
	        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
	        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
	      }
	    }
	  }, [accountForScrollbars]);
	  reactExports.useEffect(function () {
	    if (!isEnabled) return;
	    var element = scrollTarget.current;
	    addScrollLock(element);
	    return function () {
	      removeScrollLock(element);
	    };
	  }, [isEnabled, addScrollLock, removeScrollLock]);
	  return function (element) {
	    scrollTarget.current = element;
	  };
	}
	var blurSelectInput = function blurSelectInput(event) {
	  var element = event.target;
	  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
	};
	var _ref2$1 = {
	  name: "1kfdb0e",
	  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
	} ;
	function ScrollManager(_ref) {
	  var children = _ref.children,
	    lockEnabled = _ref.lockEnabled,
	    _ref$captureEnabled = _ref.captureEnabled,
	    captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
	    onBottomArrive = _ref.onBottomArrive,
	    onBottomLeave = _ref.onBottomLeave,
	    onTopArrive = _ref.onTopArrive,
	    onTopLeave = _ref.onTopLeave;
	  var setScrollCaptureTarget = useScrollCapture({
	    isEnabled: captureEnabled,
	    onBottomArrive: onBottomArrive,
	    onBottomLeave: onBottomLeave,
	    onTopArrive: onTopArrive,
	    onTopLeave: onTopLeave
	  });
	  var setScrollLockTarget = useScrollLock({
	    isEnabled: lockEnabled
	  });
	  var targetRef = function targetRef(element) {
	    setScrollCaptureTarget(element);
	    setScrollLockTarget(element);
	  };
	  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
	    onClick: blurSelectInput,
	    css: _ref2$1
	  }), children(targetRef));
	}
	var _ref2 = {
	  name: "1a0ro4n-requiredInput",
	  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
	} ;
	var RequiredInput = function RequiredInput(_ref) {
	  var name = _ref.name,
	    onFocus = _ref.onFocus;
	  return jsx("input", {
	    required: true,
	    name: name,
	    tabIndex: -1,
	    "aria-hidden": "true",
	    onFocus: onFocus,
	    css: _ref2
	    // Prevent `Switching from uncontrolled to controlled` error
	    ,
	    value: "",
	    onChange: function onChange() {}
	  });
	};
	var RequiredInput$1 = RequiredInput;

	/// <reference types="user-agent-data-types" />

	function testPlatform(re) {
	  var _window$navigator$use;
	  return typeof window !== 'undefined' && window.navigator != null ? re.test(((_window$navigator$use = window.navigator['userAgentData']) === null || _window$navigator$use === void 0 ? void 0 : _window$navigator$use.platform) || window.navigator.platform) : false;
	}
	function isIPhone() {
	  return testPlatform(/^iPhone/i);
	}
	function isMac() {
	  return testPlatform(/^Mac/i);
	}
	function isIPad() {
	  return testPlatform(/^iPad/i) ||
	  // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
	  isMac() && navigator.maxTouchPoints > 1;
	}
	function isIOS() {
	  return isIPhone() || isIPad();
	}
	function isAppleDevice() {
	  return isMac() || isIOS();
	}

	var formatGroupLabel = function formatGroupLabel(group) {
	  return group.label;
	};
	var getOptionLabel$1 = function getOptionLabel(option) {
	  return option.label;
	};
	var getOptionValue$1 = function getOptionValue(option) {
	  return option.value;
	};
	var isOptionDisabled = function isOptionDisabled(option) {
	  return !!option.isDisabled;
	};

	var defaultStyles = {
	  clearIndicator: clearIndicatorCSS,
	  container: containerCSS,
	  control: css$1,
	  dropdownIndicator: dropdownIndicatorCSS,
	  group: groupCSS,
	  groupHeading: groupHeadingCSS,
	  indicatorsContainer: indicatorsContainerCSS,
	  indicatorSeparator: indicatorSeparatorCSS,
	  input: inputCSS,
	  loadingIndicator: loadingIndicatorCSS,
	  loadingMessage: loadingMessageCSS,
	  menu: menuCSS,
	  menuList: menuListCSS,
	  menuPortal: menuPortalCSS,
	  multiValue: multiValueCSS,
	  multiValueLabel: multiValueLabelCSS,
	  multiValueRemove: multiValueRemoveCSS,
	  noOptionsMessage: noOptionsMessageCSS,
	  option: optionCSS,
	  placeholder: placeholderCSS,
	  singleValue: css,
	  valueContainer: valueContainerCSS
	};

	var colors = {
	  primary: '#2684FF',
	  primary75: '#4C9AFF',
	  primary50: '#B2D4FF',
	  primary25: '#DEEBFF',
	  danger: '#DE350B',
	  dangerLight: '#FFBDAD',
	  neutral0: 'hsl(0, 0%, 100%)',
	  neutral5: 'hsl(0, 0%, 95%)',
	  neutral10: 'hsl(0, 0%, 90%)',
	  neutral20: 'hsl(0, 0%, 80%)',
	  neutral30: 'hsl(0, 0%, 70%)',
	  neutral40: 'hsl(0, 0%, 60%)',
	  neutral50: 'hsl(0, 0%, 50%)',
	  neutral60: 'hsl(0, 0%, 40%)',
	  neutral70: 'hsl(0, 0%, 30%)',
	  neutral80: 'hsl(0, 0%, 20%)',
	  neutral90: 'hsl(0, 0%, 10%)'
	};
	var borderRadius = 4;
	// Used to calculate consistent margin/padding on elements
	var baseUnit = 4;
	// The minimum height of the control
	var controlHeight = 38;
	// The amount of space between the control and menu */
	var menuGutter = baseUnit * 2;
	var spacing = {
	  baseUnit: baseUnit,
	  controlHeight: controlHeight,
	  menuGutter: menuGutter
	};
	var defaultTheme = {
	  borderRadius: borderRadius,
	  colors: colors,
	  spacing: spacing
	};

	var defaultProps = {
	  'aria-live': 'polite',
	  backspaceRemovesValue: true,
	  blurInputOnSelect: isTouchCapable(),
	  captureMenuScroll: !isTouchCapable(),
	  classNames: {},
	  closeMenuOnSelect: true,
	  closeMenuOnScroll: false,
	  components: {},
	  controlShouldRenderValue: true,
	  escapeClearsValue: false,
	  filterOption: createFilter(),
	  formatGroupLabel: formatGroupLabel,
	  getOptionLabel: getOptionLabel$1,
	  getOptionValue: getOptionValue$1,
	  isDisabled: false,
	  isLoading: false,
	  isMulti: false,
	  isRtl: false,
	  isSearchable: true,
	  isOptionDisabled: isOptionDisabled,
	  loadingMessage: function loadingMessage() {
	    return 'Loading...';
	  },
	  maxMenuHeight: 300,
	  minMenuHeight: 140,
	  menuIsOpen: false,
	  menuPlacement: 'bottom',
	  menuPosition: 'absolute',
	  menuShouldBlockScroll: false,
	  menuShouldScrollIntoView: !isMobileDevice(),
	  noOptionsMessage: function noOptionsMessage() {
	    return 'No options';
	  },
	  openMenuOnFocus: false,
	  openMenuOnClick: true,
	  options: [],
	  pageSize: 5,
	  placeholder: 'Select...',
	  screenReaderStatus: function screenReaderStatus(_ref) {
	    var count = _ref.count;
	    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
	  },
	  styles: {},
	  tabIndex: 0,
	  tabSelectsValue: true,
	  unstyled: false
	};
	function toCategorizedOption(props, option, selectValue, index) {
	  var isDisabled = _isOptionDisabled(props, option, selectValue);
	  var isSelected = _isOptionSelected(props, option, selectValue);
	  var label = getOptionLabel(props, option);
	  var value = getOptionValue(props, option);
	  return {
	    type: 'option',
	    data: option,
	    isDisabled: isDisabled,
	    isSelected: isSelected,
	    label: label,
	    value: value,
	    index: index
	  };
	}
	function buildCategorizedOptions(props, selectValue) {
	  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
	    if ('options' in groupOrOption) {
	      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
	        return toCategorizedOption(props, option, selectValue, optionIndex);
	      }).filter(function (categorizedOption) {
	        return isFocusable(props, categorizedOption);
	      });
	      return categorizedOptions.length > 0 ? {
	        type: 'group',
	        data: groupOrOption,
	        options: categorizedOptions,
	        index: groupOrOptionIndex
	      } : undefined;
	    }
	    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
	    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
	  }).filter(notNullish);
	}
	function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
	  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
	    if (categorizedOption.type === 'group') {
	      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
	        return option.data;
	      })));
	    } else {
	      optionsAccumulator.push(categorizedOption.data);
	    }
	    return optionsAccumulator;
	  }, []);
	}
	function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
	  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
	    if (categorizedOption.type === 'group') {
	      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
	        return {
	          data: option.data,
	          id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
	        };
	      })));
	    } else {
	      optionsAccumulator.push({
	        data: categorizedOption.data,
	        id: "".concat(optionId, "-").concat(categorizedOption.index)
	      });
	    }
	    return optionsAccumulator;
	  }, []);
	}
	function buildFocusableOptions(props, selectValue) {
	  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
	}
	function isFocusable(props, categorizedOption) {
	  var _props$inputValue = props.inputValue,
	    inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
	  var data = categorizedOption.data,
	    isSelected = categorizedOption.isSelected,
	    label = categorizedOption.label,
	    value = categorizedOption.value;
	  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
	    label: label,
	    value: value,
	    data: data
	  }, inputValue);
	}
	function getNextFocusedValue(state, nextSelectValue) {
	  var focusedValue = state.focusedValue,
	    lastSelectValue = state.selectValue;
	  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
	  if (lastFocusedIndex > -1) {
	    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
	    if (nextFocusedIndex > -1) {
	      // the focused value is still in the selectValue, return it
	      return focusedValue;
	    } else if (lastFocusedIndex < nextSelectValue.length) {
	      // the focusedValue is not present in the next selectValue array by
	      // reference, so return the new value at the same index
	      return nextSelectValue[lastFocusedIndex];
	    }
	  }
	  return null;
	}
	function getNextFocusedOption(state, options) {
	  var lastFocusedOption = state.focusedOption;
	  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
	}
	var getFocusedOptionId = function getFocusedOptionId(focusableOptionsWithIds, focusedOption) {
	  var _focusableOptionsWith;
	  var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function (option) {
	    return option.data === focusedOption;
	  })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
	  return focusedOptionId || null;
	};
	var getOptionLabel = function getOptionLabel(props, data) {
	  return props.getOptionLabel(data);
	};
	var getOptionValue = function getOptionValue(props, data) {
	  return props.getOptionValue(data);
	};
	function _isOptionDisabled(props, option, selectValue) {
	  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
	}
	function _isOptionSelected(props, option, selectValue) {
	  if (selectValue.indexOf(option) > -1) return true;
	  if (typeof props.isOptionSelected === 'function') {
	    return props.isOptionSelected(option, selectValue);
	  }
	  var candidate = getOptionValue(props, option);
	  return selectValue.some(function (i) {
	    return getOptionValue(props, i) === candidate;
	  });
	}
	function _filterOption(props, option, inputValue) {
	  return props.filterOption ? props.filterOption(option, inputValue) : true;
	}
	var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
	  var hideSelectedOptions = props.hideSelectedOptions,
	    isMulti = props.isMulti;
	  if (hideSelectedOptions === undefined) return isMulti;
	  return hideSelectedOptions;
	};
	var instanceId = 1;
	var Select = /*#__PURE__*/function (_Component) {
	  _inherits(Select, _Component);
	  var _super = _createSuper(Select);
	  // Misc. Instance Properties
	  // ------------------------------

	  // TODO

	  // Refs
	  // ------------------------------

	  // Lifecycle
	  // ------------------------------

	  function Select(_props) {
	    var _this;
	    _classCallCheck(this, Select);
	    _this = _super.call(this, _props);
	    _this.state = {
	      ariaSelection: null,
	      focusedOption: null,
	      focusedOptionId: null,
	      focusableOptionsWithIds: [],
	      focusedValue: null,
	      inputIsHidden: false,
	      isFocused: false,
	      selectValue: [],
	      clearFocusValueOnUpdate: false,
	      prevWasFocused: false,
	      inputIsHiddenAfterUpdate: undefined,
	      prevProps: undefined,
	      instancePrefix: ''
	    };
	    _this.blockOptionHover = false;
	    _this.isComposing = false;
	    _this.commonProps = void 0;
	    _this.initialTouchX = 0;
	    _this.initialTouchY = 0;
	    _this.openAfterFocus = false;
	    _this.scrollToFocusedOptionOnUpdate = false;
	    _this.userIsDragging = void 0;
	    _this.isAppleDevice = isAppleDevice();
	    _this.controlRef = null;
	    _this.getControlRef = function (ref) {
	      _this.controlRef = ref;
	    };
	    _this.focusedOptionRef = null;
	    _this.getFocusedOptionRef = function (ref) {
	      _this.focusedOptionRef = ref;
	    };
	    _this.menuListRef = null;
	    _this.getMenuListRef = function (ref) {
	      _this.menuListRef = ref;
	    };
	    _this.inputRef = null;
	    _this.getInputRef = function (ref) {
	      _this.inputRef = ref;
	    };
	    _this.focus = _this.focusInput;
	    _this.blur = _this.blurInput;
	    _this.onChange = function (newValue, actionMeta) {
	      var _this$props = _this.props,
	        onChange = _this$props.onChange,
	        name = _this$props.name;
	      actionMeta.name = name;
	      _this.ariaOnChange(newValue, actionMeta);
	      onChange(newValue, actionMeta);
	    };
	    _this.setValue = function (newValue, action, option) {
	      var _this$props2 = _this.props,
	        closeMenuOnSelect = _this$props2.closeMenuOnSelect,
	        isMulti = _this$props2.isMulti,
	        inputValue = _this$props2.inputValue;
	      _this.onInputChange('', {
	        action: 'set-value',
	        prevInputValue: inputValue
	      });
	      if (closeMenuOnSelect) {
	        _this.setState({
	          inputIsHiddenAfterUpdate: !isMulti
	        });
	        _this.onMenuClose();
	      }
	      // when the select value should change, we should reset focusedValue
	      _this.setState({
	        clearFocusValueOnUpdate: true
	      });
	      _this.onChange(newValue, {
	        action: action,
	        option: option
	      });
	    };
	    _this.selectOption = function (newValue) {
	      var _this$props3 = _this.props,
	        blurInputOnSelect = _this$props3.blurInputOnSelect,
	        isMulti = _this$props3.isMulti,
	        name = _this$props3.name;
	      var selectValue = _this.state.selectValue;
	      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
	      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
	      if (deselected) {
	        var candidate = _this.getOptionValue(newValue);
	        _this.setValue(multiValueAsValue(selectValue.filter(function (i) {
	          return _this.getOptionValue(i) !== candidate;
	        })), 'deselect-option', newValue);
	      } else if (!isDisabled) {
	        // Select option if option is not disabled
	        if (isMulti) {
	          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), 'select-option', newValue);
	        } else {
	          _this.setValue(singleValueAsValue(newValue), 'select-option');
	        }
	      } else {
	        _this.ariaOnChange(singleValueAsValue(newValue), {
	          action: 'select-option',
	          option: newValue,
	          name: name
	        });
	        return;
	      }
	      if (blurInputOnSelect) {
	        _this.blurInput();
	      }
	    };
	    _this.removeValue = function (removedValue) {
	      var isMulti = _this.props.isMulti;
	      var selectValue = _this.state.selectValue;
	      var candidate = _this.getOptionValue(removedValue);
	      var newValueArray = selectValue.filter(function (i) {
	        return _this.getOptionValue(i) !== candidate;
	      });
	      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
	      _this.onChange(newValue, {
	        action: 'remove-value',
	        removedValue: removedValue
	      });
	      _this.focusInput();
	    };
	    _this.clearValue = function () {
	      var selectValue = _this.state.selectValue;
	      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
	        action: 'clear',
	        removedValues: selectValue
	      });
	    };
	    _this.popValue = function () {
	      var isMulti = _this.props.isMulti;
	      var selectValue = _this.state.selectValue;
	      var lastSelectedValue = selectValue[selectValue.length - 1];
	      var newValueArray = selectValue.slice(0, selectValue.length - 1);
	      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
	      if (lastSelectedValue) {
	        _this.onChange(newValue, {
	          action: 'pop-value',
	          removedValue: lastSelectedValue
	        });
	      }
	    };
	    _this.getFocusedOptionId = function (focusedOption) {
	      return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
	    };
	    _this.getFocusableOptionsWithIds = function () {
	      return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId('option'));
	    };
	    _this.getValue = function () {
	      return _this.state.selectValue;
	    };
	    _this.cx = function () {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
	    };
	    _this.getOptionLabel = function (data) {
	      return getOptionLabel(_this.props, data);
	    };
	    _this.getOptionValue = function (data) {
	      return getOptionValue(_this.props, data);
	    };
	    _this.getStyles = function (key, props) {
	      var unstyled = _this.props.unstyled;
	      var base = defaultStyles[key](props, unstyled);
	      base.boxSizing = 'border-box';
	      var custom = _this.props.styles[key];
	      return custom ? custom(base, props) : base;
	    };
	    _this.getClassNames = function (key, props) {
	      var _this$props$className, _this$props$className2;
	      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
	    };
	    _this.getElementId = function (element) {
	      return "".concat(_this.state.instancePrefix, "-").concat(element);
	    };
	    _this.getComponents = function () {
	      return defaultComponents(_this.props);
	    };
	    _this.buildCategorizedOptions = function () {
	      return buildCategorizedOptions(_this.props, _this.state.selectValue);
	    };
	    _this.getCategorizedOptions = function () {
	      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
	    };
	    _this.buildFocusableOptions = function () {
	      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
	    };
	    _this.getFocusableOptions = function () {
	      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
	    };
	    _this.ariaOnChange = function (value, actionMeta) {
	      _this.setState({
	        ariaSelection: _objectSpread2({
	          value: value
	        }, actionMeta)
	      });
	    };
	    _this.onMenuMouseDown = function (event) {
	      if (event.button !== 0) {
	        return;
	      }
	      event.stopPropagation();
	      event.preventDefault();
	      _this.focusInput();
	    };
	    _this.onMenuMouseMove = function (event) {
	      _this.blockOptionHover = false;
	    };
	    _this.onControlMouseDown = function (event) {
	      // Event captured by dropdown indicator
	      if (event.defaultPrevented) {
	        return;
	      }
	      var openMenuOnClick = _this.props.openMenuOnClick;
	      if (!_this.state.isFocused) {
	        if (openMenuOnClick) {
	          _this.openAfterFocus = true;
	        }
	        _this.focusInput();
	      } else if (!_this.props.menuIsOpen) {
	        if (openMenuOnClick) {
	          _this.openMenu('first');
	        }
	      } else {
	        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
	          _this.onMenuClose();
	        }
	      }
	      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
	        event.preventDefault();
	      }
	    };
	    _this.onDropdownIndicatorMouseDown = function (event) {
	      // ignore mouse events that weren't triggered by the primary button
	      if (event && event.type === 'mousedown' && event.button !== 0) {
	        return;
	      }
	      if (_this.props.isDisabled) return;
	      var _this$props4 = _this.props,
	        isMulti = _this$props4.isMulti,
	        menuIsOpen = _this$props4.menuIsOpen;
	      _this.focusInput();
	      if (menuIsOpen) {
	        _this.setState({
	          inputIsHiddenAfterUpdate: !isMulti
	        });
	        _this.onMenuClose();
	      } else {
	        _this.openMenu('first');
	      }
	      event.preventDefault();
	    };
	    _this.onClearIndicatorMouseDown = function (event) {
	      // ignore mouse events that weren't triggered by the primary button
	      if (event && event.type === 'mousedown' && event.button !== 0) {
	        return;
	      }
	      _this.clearValue();
	      event.preventDefault();
	      _this.openAfterFocus = false;
	      if (event.type === 'touchend') {
	        _this.focusInput();
	      } else {
	        setTimeout(function () {
	          return _this.focusInput();
	        });
	      }
	    };
	    _this.onScroll = function (event) {
	      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
	        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
	          _this.props.onMenuClose();
	        }
	      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
	        if (_this.props.closeMenuOnScroll(event)) {
	          _this.props.onMenuClose();
	        }
	      }
	    };
	    _this.onCompositionStart = function () {
	      _this.isComposing = true;
	    };
	    _this.onCompositionEnd = function () {
	      _this.isComposing = false;
	    };
	    _this.onTouchStart = function (_ref2) {
	      var touches = _ref2.touches;
	      var touch = touches && touches.item(0);
	      if (!touch) {
	        return;
	      }
	      _this.initialTouchX = touch.clientX;
	      _this.initialTouchY = touch.clientY;
	      _this.userIsDragging = false;
	    };
	    _this.onTouchMove = function (_ref3) {
	      var touches = _ref3.touches;
	      var touch = touches && touches.item(0);
	      if (!touch) {
	        return;
	      }
	      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
	      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
	      var moveThreshold = 5;
	      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
	    };
	    _this.onTouchEnd = function (event) {
	      if (_this.userIsDragging) return;

	      // close the menu if the user taps outside
	      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
	      // on events on child elements, not the document (which we've attached this handler to).
	      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
	        _this.blurInput();
	      }

	      // reset move vars
	      _this.initialTouchX = 0;
	      _this.initialTouchY = 0;
	    };
	    _this.onControlTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onControlMouseDown(event);
	    };
	    _this.onClearIndicatorTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onClearIndicatorMouseDown(event);
	    };
	    _this.onDropdownIndicatorTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onDropdownIndicatorMouseDown(event);
	    };
	    _this.handleInputChange = function (event) {
	      var prevInputValue = _this.props.inputValue;
	      var inputValue = event.currentTarget.value;
	      _this.setState({
	        inputIsHiddenAfterUpdate: false
	      });
	      _this.onInputChange(inputValue, {
	        action: 'input-change',
	        prevInputValue: prevInputValue
	      });
	      if (!_this.props.menuIsOpen) {
	        _this.onMenuOpen();
	      }
	    };
	    _this.onInputFocus = function (event) {
	      if (_this.props.onFocus) {
	        _this.props.onFocus(event);
	      }
	      _this.setState({
	        inputIsHiddenAfterUpdate: false,
	        isFocused: true
	      });
	      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
	        _this.openMenu('first');
	      }
	      _this.openAfterFocus = false;
	    };
	    _this.onInputBlur = function (event) {
	      var prevInputValue = _this.props.inputValue;
	      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
	        _this.inputRef.focus();
	        return;
	      }
	      if (_this.props.onBlur) {
	        _this.props.onBlur(event);
	      }
	      _this.onInputChange('', {
	        action: 'input-blur',
	        prevInputValue: prevInputValue
	      });
	      _this.onMenuClose();
	      _this.setState({
	        focusedValue: null,
	        isFocused: false
	      });
	    };
	    _this.onOptionHover = function (focusedOption) {
	      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
	        return;
	      }
	      var options = _this.getFocusableOptions();
	      var focusedOptionIndex = options.indexOf(focusedOption);
	      _this.setState({
	        focusedOption: focusedOption,
	        focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
	      });
	    };
	    _this.shouldHideSelectedOptions = function () {
	      return shouldHideSelectedOptions(_this.props);
	    };
	    _this.onValueInputFocus = function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      _this.focus();
	    };
	    _this.onKeyDown = function (event) {
	      var _this$props5 = _this.props,
	        isMulti = _this$props5.isMulti,
	        backspaceRemovesValue = _this$props5.backspaceRemovesValue,
	        escapeClearsValue = _this$props5.escapeClearsValue,
	        inputValue = _this$props5.inputValue,
	        isClearable = _this$props5.isClearable,
	        isDisabled = _this$props5.isDisabled,
	        menuIsOpen = _this$props5.menuIsOpen,
	        onKeyDown = _this$props5.onKeyDown,
	        tabSelectsValue = _this$props5.tabSelectsValue,
	        openMenuOnFocus = _this$props5.openMenuOnFocus;
	      var _this$state = _this.state,
	        focusedOption = _this$state.focusedOption,
	        focusedValue = _this$state.focusedValue,
	        selectValue = _this$state.selectValue;
	      if (isDisabled) return;
	      if (typeof onKeyDown === 'function') {
	        onKeyDown(event);
	        if (event.defaultPrevented) {
	          return;
	        }
	      }

	      // Block option hover events when the user has just pressed a key
	      _this.blockOptionHover = true;
	      switch (event.key) {
	        case 'ArrowLeft':
	          if (!isMulti || inputValue) return;
	          _this.focusValue('previous');
	          break;
	        case 'ArrowRight':
	          if (!isMulti || inputValue) return;
	          _this.focusValue('next');
	          break;
	        case 'Delete':
	        case 'Backspace':
	          if (inputValue) return;
	          if (focusedValue) {
	            _this.removeValue(focusedValue);
	          } else {
	            if (!backspaceRemovesValue) return;
	            if (isMulti) {
	              _this.popValue();
	            } else if (isClearable) {
	              _this.clearValue();
	            }
	          }
	          break;
	        case 'Tab':
	          if (_this.isComposing) return;
	          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption ||
	          // don't capture the event if the menu opens on focus and the focused
	          // option is already selected; it breaks the flow of navigation
	          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
	            return;
	          }
	          _this.selectOption(focusedOption);
	          break;
	        case 'Enter':
	          if (event.keyCode === 229) {
	            // ignore the keydown event from an Input Method Editor(IME)
	            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
	            break;
	          }
	          if (menuIsOpen) {
	            if (!focusedOption) return;
	            if (_this.isComposing) return;
	            _this.selectOption(focusedOption);
	            break;
	          }
	          return;
	        case 'Escape':
	          if (menuIsOpen) {
	            _this.setState({
	              inputIsHiddenAfterUpdate: false
	            });
	            _this.onInputChange('', {
	              action: 'menu-close',
	              prevInputValue: inputValue
	            });
	            _this.onMenuClose();
	          } else if (isClearable && escapeClearsValue) {
	            _this.clearValue();
	          }
	          break;
	        case ' ':
	          // space
	          if (inputValue) {
	            return;
	          }
	          if (!menuIsOpen) {
	            _this.openMenu('first');
	            break;
	          }
	          if (!focusedOption) return;
	          _this.selectOption(focusedOption);
	          break;
	        case 'ArrowUp':
	          if (menuIsOpen) {
	            _this.focusOption('up');
	          } else {
	            _this.openMenu('last');
	          }
	          break;
	        case 'ArrowDown':
	          if (menuIsOpen) {
	            _this.focusOption('down');
	          } else {
	            _this.openMenu('first');
	          }
	          break;
	        case 'PageUp':
	          if (!menuIsOpen) return;
	          _this.focusOption('pageup');
	          break;
	        case 'PageDown':
	          if (!menuIsOpen) return;
	          _this.focusOption('pagedown');
	          break;
	        case 'Home':
	          if (!menuIsOpen) return;
	          _this.focusOption('first');
	          break;
	        case 'End':
	          if (!menuIsOpen) return;
	          _this.focusOption('last');
	          break;
	        default:
	          return;
	      }
	      event.preventDefault();
	    };
	    _this.state.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
	    _this.state.selectValue = cleanValue(_props.value);
	    // Set focusedOption if menuIsOpen is set on init (e.g. defaultMenuIsOpen)
	    if (_props.menuIsOpen && _this.state.selectValue.length) {
	      var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
	      var focusableOptions = _this.buildFocusableOptions();
	      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
	      _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
	      _this.state.focusedOption = focusableOptions[optionIndex];
	      _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
	    }
	    return _this;
	  }
	  _createClass(Select, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.startListeningComposition();
	      this.startListeningToTouch();
	      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
	        // Listen to all scroll events, and filter them out inside of 'onScroll'
	        document.addEventListener('scroll', this.onScroll, true);
	      }
	      if (this.props.autoFocus) {
	        this.focusInput();
	      }

	      // Scroll focusedOption into view if menuIsOpen is set on mount (e.g. defaultMenuIsOpen)
	      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
	        scrollIntoView(this.menuListRef, this.focusedOptionRef);
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps) {
	      var _this$props6 = this.props,
	        isDisabled = _this$props6.isDisabled,
	        menuIsOpen = _this$props6.menuIsOpen;
	      var isFocused = this.state.isFocused;
	      if (
	      // ensure focus is restored correctly when the control becomes enabled
	      isFocused && !isDisabled && prevProps.isDisabled ||
	      // ensure focus is on the Input when the menu opens
	      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
	        this.focusInput();
	      }
	      if (isFocused && isDisabled && !prevProps.isDisabled) {
	        // ensure select state gets blurred in case Select is programmatically disabled while focused
	        // eslint-disable-next-line react/no-did-update-set-state
	        this.setState({
	          isFocused: false
	        }, this.onMenuClose);
	      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
	        // ensure select state gets focused in case Select is programatically re-enabled while focused (Firefox)
	        // eslint-disable-next-line react/no-did-update-set-state
	        this.setState({
	          isFocused: true
	        });
	      }

	      // scroll the focused option into view if necessary
	      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
	        scrollIntoView(this.menuListRef, this.focusedOptionRef);
	        this.scrollToFocusedOptionOnUpdate = false;
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this.stopListeningComposition();
	      this.stopListeningToTouch();
	      document.removeEventListener('scroll', this.onScroll, true);
	    }

	    // ==============================
	    // Consumer Handlers
	    // ==============================
	  }, {
	    key: "onMenuOpen",
	    value: function onMenuOpen() {
	      this.props.onMenuOpen();
	    }
	  }, {
	    key: "onMenuClose",
	    value: function onMenuClose() {
	      this.onInputChange('', {
	        action: 'menu-close',
	        prevInputValue: this.props.inputValue
	      });
	      this.props.onMenuClose();
	    }
	  }, {
	    key: "onInputChange",
	    value: function onInputChange(newValue, actionMeta) {
	      this.props.onInputChange(newValue, actionMeta);
	    }

	    // ==============================
	    // Methods
	    // ==============================
	  }, {
	    key: "focusInput",
	    value: function focusInput() {
	      if (!this.inputRef) return;
	      this.inputRef.focus();
	    }
	  }, {
	    key: "blurInput",
	    value: function blurInput() {
	      if (!this.inputRef) return;
	      this.inputRef.blur();
	    }

	    // aliased for consumers
	  }, {
	    key: "openMenu",
	    value: function openMenu(focusOption) {
	      var _this2 = this;
	      var _this$state2 = this.state,
	        selectValue = _this$state2.selectValue,
	        isFocused = _this$state2.isFocused;
	      var focusableOptions = this.buildFocusableOptions();
	      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;
	      if (!this.props.isMulti) {
	        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
	        if (selectedIndex > -1) {
	          openAtIndex = selectedIndex;
	        }
	      }

	      // only scroll if the menu isn't already open
	      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
	      this.setState({
	        inputIsHiddenAfterUpdate: false,
	        focusedValue: null,
	        focusedOption: focusableOptions[openAtIndex],
	        focusedOptionId: this.getFocusedOptionId(focusableOptions[openAtIndex])
	      }, function () {
	        return _this2.onMenuOpen();
	      });
	    }
	  }, {
	    key: "focusValue",
	    value: function focusValue(direction) {
	      var _this$state3 = this.state,
	        selectValue = _this$state3.selectValue,
	        focusedValue = _this$state3.focusedValue;

	      // Only multiselects support value focusing
	      if (!this.props.isMulti) return;
	      this.setState({
	        focusedOption: null
	      });
	      var focusedIndex = selectValue.indexOf(focusedValue);
	      if (!focusedValue) {
	        focusedIndex = -1;
	      }
	      var lastIndex = selectValue.length - 1;
	      var nextFocus = -1;
	      if (!selectValue.length) return;
	      switch (direction) {
	        case 'previous':
	          if (focusedIndex === 0) {
	            // don't cycle from the start to the end
	            nextFocus = 0;
	          } else if (focusedIndex === -1) {
	            // if nothing is focused, focus the last value first
	            nextFocus = lastIndex;
	          } else {
	            nextFocus = focusedIndex - 1;
	          }
	          break;
	        case 'next':
	          if (focusedIndex > -1 && focusedIndex < lastIndex) {
	            nextFocus = focusedIndex + 1;
	          }
	          break;
	      }
	      this.setState({
	        inputIsHidden: nextFocus !== -1,
	        focusedValue: selectValue[nextFocus]
	      });
	    }
	  }, {
	    key: "focusOption",
	    value: function focusOption() {
	      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
	      var pageSize = this.props.pageSize;
	      var focusedOption = this.state.focusedOption;
	      var options = this.getFocusableOptions();
	      if (!options.length) return;
	      var nextFocus = 0; // handles 'first'
	      var focusedIndex = options.indexOf(focusedOption);
	      if (!focusedOption) {
	        focusedIndex = -1;
	      }
	      if (direction === 'up') {
	        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
	      } else if (direction === 'down') {
	        nextFocus = (focusedIndex + 1) % options.length;
	      } else if (direction === 'pageup') {
	        nextFocus = focusedIndex - pageSize;
	        if (nextFocus < 0) nextFocus = 0;
	      } else if (direction === 'pagedown') {
	        nextFocus = focusedIndex + pageSize;
	        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
	      } else if (direction === 'last') {
	        nextFocus = options.length - 1;
	      }
	      this.scrollToFocusedOptionOnUpdate = true;
	      this.setState({
	        focusedOption: options[nextFocus],
	        focusedValue: null,
	        focusedOptionId: this.getFocusedOptionId(options[nextFocus])
	      });
	    }
	  }, {
	    key: "getTheme",
	    value:
	    // ==============================
	    // Getters
	    // ==============================

	    function getTheme() {
	      // Use the default theme if there are no customisations.
	      if (!this.props.theme) {
	        return defaultTheme;
	      }
	      // If the theme prop is a function, assume the function
	      // knows how to merge the passed-in default theme with
	      // its own modifications.
	      if (typeof this.props.theme === 'function') {
	        return this.props.theme(defaultTheme);
	      }
	      // Otherwise, if a plain theme object was passed in,
	      // overlay it with the default theme.
	      return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
	    }
	  }, {
	    key: "getCommonProps",
	    value: function getCommonProps() {
	      var clearValue = this.clearValue,
	        cx = this.cx,
	        getStyles = this.getStyles,
	        getClassNames = this.getClassNames,
	        getValue = this.getValue,
	        selectOption = this.selectOption,
	        setValue = this.setValue,
	        props = this.props;
	      var isMulti = props.isMulti,
	        isRtl = props.isRtl,
	        options = props.options;
	      var hasValue = this.hasValue();
	      return {
	        clearValue: clearValue,
	        cx: cx,
	        getStyles: getStyles,
	        getClassNames: getClassNames,
	        getValue: getValue,
	        hasValue: hasValue,
	        isMulti: isMulti,
	        isRtl: isRtl,
	        options: options,
	        selectOption: selectOption,
	        selectProps: props,
	        setValue: setValue,
	        theme: this.getTheme()
	      };
	    }
	  }, {
	    key: "hasValue",
	    value: function hasValue() {
	      var selectValue = this.state.selectValue;
	      return selectValue.length > 0;
	    }
	  }, {
	    key: "hasOptions",
	    value: function hasOptions() {
	      return !!this.getFocusableOptions().length;
	    }
	  }, {
	    key: "isClearable",
	    value: function isClearable() {
	      var _this$props7 = this.props,
	        isClearable = _this$props7.isClearable,
	        isMulti = _this$props7.isMulti;

	      // single select, by default, IS NOT clearable
	      // multi select, by default, IS clearable
	      if (isClearable === undefined) return isMulti;
	      return isClearable;
	    }
	  }, {
	    key: "isOptionDisabled",
	    value: function isOptionDisabled(option, selectValue) {
	      return _isOptionDisabled(this.props, option, selectValue);
	    }
	  }, {
	    key: "isOptionSelected",
	    value: function isOptionSelected(option, selectValue) {
	      return _isOptionSelected(this.props, option, selectValue);
	    }
	  }, {
	    key: "filterOption",
	    value: function filterOption(option, inputValue) {
	      return _filterOption(this.props, option, inputValue);
	    }
	  }, {
	    key: "formatOptionLabel",
	    value: function formatOptionLabel(data, context) {
	      if (typeof this.props.formatOptionLabel === 'function') {
	        var _inputValue = this.props.inputValue;
	        var _selectValue = this.state.selectValue;
	        return this.props.formatOptionLabel(data, {
	          context: context,
	          inputValue: _inputValue,
	          selectValue: _selectValue
	        });
	      } else {
	        return this.getOptionLabel(data);
	      }
	    }
	  }, {
	    key: "formatGroupLabel",
	    value: function formatGroupLabel(data) {
	      return this.props.formatGroupLabel(data);
	    }

	    // ==============================
	    // Mouse Handlers
	    // ==============================
	  }, {
	    key: "startListeningComposition",
	    value:
	    // ==============================
	    // Composition Handlers
	    // ==============================

	    function startListeningComposition() {
	      if (document && document.addEventListener) {
	        document.addEventListener('compositionstart', this.onCompositionStart, false);
	        document.addEventListener('compositionend', this.onCompositionEnd, false);
	      }
	    }
	  }, {
	    key: "stopListeningComposition",
	    value: function stopListeningComposition() {
	      if (document && document.removeEventListener) {
	        document.removeEventListener('compositionstart', this.onCompositionStart);
	        document.removeEventListener('compositionend', this.onCompositionEnd);
	      }
	    }
	  }, {
	    key: "startListeningToTouch",
	    value:
	    // ==============================
	    // Touch Handlers
	    // ==============================

	    function startListeningToTouch() {
	      if (document && document.addEventListener) {
	        document.addEventListener('touchstart', this.onTouchStart, false);
	        document.addEventListener('touchmove', this.onTouchMove, false);
	        document.addEventListener('touchend', this.onTouchEnd, false);
	      }
	    }
	  }, {
	    key: "stopListeningToTouch",
	    value: function stopListeningToTouch() {
	      if (document && document.removeEventListener) {
	        document.removeEventListener('touchstart', this.onTouchStart);
	        document.removeEventListener('touchmove', this.onTouchMove);
	        document.removeEventListener('touchend', this.onTouchEnd);
	      }
	    }
	  }, {
	    key: "renderInput",
	    value:
	    // ==============================
	    // Renderers
	    // ==============================
	    function renderInput() {
	      var _this$props8 = this.props,
	        isDisabled = _this$props8.isDisabled,
	        isSearchable = _this$props8.isSearchable,
	        inputId = _this$props8.inputId,
	        inputValue = _this$props8.inputValue,
	        tabIndex = _this$props8.tabIndex,
	        form = _this$props8.form,
	        menuIsOpen = _this$props8.menuIsOpen,
	        required = _this$props8.required;
	      var _this$getComponents = this.getComponents(),
	        Input = _this$getComponents.Input;
	      var _this$state4 = this.state,
	        inputIsHidden = _this$state4.inputIsHidden,
	        ariaSelection = _this$state4.ariaSelection;
	      var commonProps = this.commonProps;
	      var id = inputId || this.getElementId('input');

	      // aria attributes makes the JSX "noisy", separated for clarity
	      var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
	        'aria-autocomplete': 'list',
	        'aria-expanded': menuIsOpen,
	        'aria-haspopup': true,
	        'aria-errormessage': this.props['aria-errormessage'],
	        'aria-invalid': this.props['aria-invalid'],
	        'aria-label': this.props['aria-label'],
	        'aria-labelledby': this.props['aria-labelledby'],
	        'aria-required': required,
	        role: 'combobox',
	        'aria-activedescendant': this.isAppleDevice ? undefined : this.state.focusedOptionId || ''
	      }, menuIsOpen && {
	        'aria-controls': this.getElementId('listbox')
	      }), !isSearchable && {
	        'aria-readonly': true
	      }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus' && {
	        'aria-describedby': this.getElementId('live-region')
	      } : {
	        'aria-describedby': this.getElementId('placeholder')
	      });
	      if (!isSearchable) {
	        // use a dummy input to maintain focus/blur functionality
	        return /*#__PURE__*/reactExports.createElement(DummyInput, _extends({
	          id: id,
	          innerRef: this.getInputRef,
	          onBlur: this.onInputBlur,
	          onChange: noop,
	          onFocus: this.onInputFocus,
	          disabled: isDisabled,
	          tabIndex: tabIndex,
	          inputMode: "none",
	          form: form,
	          value: ""
	        }, ariaAttributes));
	      }
	      return /*#__PURE__*/reactExports.createElement(Input, _extends({}, commonProps, {
	        autoCapitalize: "none",
	        autoComplete: "off",
	        autoCorrect: "off",
	        id: id,
	        innerRef: this.getInputRef,
	        isDisabled: isDisabled,
	        isHidden: inputIsHidden,
	        onBlur: this.onInputBlur,
	        onChange: this.handleInputChange,
	        onFocus: this.onInputFocus,
	        spellCheck: "false",
	        tabIndex: tabIndex,
	        form: form,
	        type: "text",
	        value: inputValue
	      }, ariaAttributes));
	    }
	  }, {
	    key: "renderPlaceholderOrValue",
	    value: function renderPlaceholderOrValue() {
	      var _this3 = this;
	      var _this$getComponents2 = this.getComponents(),
	        MultiValue = _this$getComponents2.MultiValue,
	        MultiValueContainer = _this$getComponents2.MultiValueContainer,
	        MultiValueLabel = _this$getComponents2.MultiValueLabel,
	        MultiValueRemove = _this$getComponents2.MultiValueRemove,
	        SingleValue = _this$getComponents2.SingleValue,
	        Placeholder = _this$getComponents2.Placeholder;
	      var commonProps = this.commonProps;
	      var _this$props9 = this.props,
	        controlShouldRenderValue = _this$props9.controlShouldRenderValue,
	        isDisabled = _this$props9.isDisabled,
	        isMulti = _this$props9.isMulti,
	        inputValue = _this$props9.inputValue,
	        placeholder = _this$props9.placeholder;
	      var _this$state5 = this.state,
	        selectValue = _this$state5.selectValue,
	        focusedValue = _this$state5.focusedValue,
	        isFocused = _this$state5.isFocused;
	      if (!this.hasValue() || !controlShouldRenderValue) {
	        return inputValue ? null : /*#__PURE__*/reactExports.createElement(Placeholder, _extends({}, commonProps, {
	          key: "placeholder",
	          isDisabled: isDisabled,
	          isFocused: isFocused,
	          innerProps: {
	            id: this.getElementId('placeholder')
	          }
	        }), placeholder);
	      }
	      if (isMulti) {
	        return selectValue.map(function (opt, index) {
	          var isOptionFocused = opt === focusedValue;
	          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
	          return /*#__PURE__*/reactExports.createElement(MultiValue, _extends({}, commonProps, {
	            components: {
	              Container: MultiValueContainer,
	              Label: MultiValueLabel,
	              Remove: MultiValueRemove
	            },
	            isFocused: isOptionFocused,
	            isDisabled: isDisabled,
	            key: key,
	            index: index,
	            removeProps: {
	              onClick: function onClick() {
	                return _this3.removeValue(opt);
	              },
	              onTouchEnd: function onTouchEnd() {
	                return _this3.removeValue(opt);
	              },
	              onMouseDown: function onMouseDown(e) {
	                e.preventDefault();
	              }
	            },
	            data: opt
	          }), _this3.formatOptionLabel(opt, 'value'));
	        });
	      }
	      if (inputValue) {
	        return null;
	      }
	      var singleValue = selectValue[0];
	      return /*#__PURE__*/reactExports.createElement(SingleValue, _extends({}, commonProps, {
	        data: singleValue,
	        isDisabled: isDisabled
	      }), this.formatOptionLabel(singleValue, 'value'));
	    }
	  }, {
	    key: "renderClearIndicator",
	    value: function renderClearIndicator() {
	      var _this$getComponents3 = this.getComponents(),
	        ClearIndicator = _this$getComponents3.ClearIndicator;
	      var commonProps = this.commonProps;
	      var _this$props10 = this.props,
	        isDisabled = _this$props10.isDisabled,
	        isLoading = _this$props10.isLoading;
	      var isFocused = this.state.isFocused;
	      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
	        return null;
	      }
	      var innerProps = {
	        onMouseDown: this.onClearIndicatorMouseDown,
	        onTouchEnd: this.onClearIndicatorTouchEnd,
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/reactExports.createElement(ClearIndicator, _extends({}, commonProps, {
	        innerProps: innerProps,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderLoadingIndicator",
	    value: function renderLoadingIndicator() {
	      var _this$getComponents4 = this.getComponents(),
	        LoadingIndicator = _this$getComponents4.LoadingIndicator;
	      var commonProps = this.commonProps;
	      var _this$props11 = this.props,
	        isDisabled = _this$props11.isDisabled,
	        isLoading = _this$props11.isLoading;
	      var isFocused = this.state.isFocused;
	      if (!LoadingIndicator || !isLoading) return null;
	      var innerProps = {
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/reactExports.createElement(LoadingIndicator, _extends({}, commonProps, {
	        innerProps: innerProps,
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderIndicatorSeparator",
	    value: function renderIndicatorSeparator() {
	      var _this$getComponents5 = this.getComponents(),
	        DropdownIndicator = _this$getComponents5.DropdownIndicator,
	        IndicatorSeparator = _this$getComponents5.IndicatorSeparator;

	      // separator doesn't make sense without the dropdown indicator
	      if (!DropdownIndicator || !IndicatorSeparator) return null;
	      var commonProps = this.commonProps;
	      var isDisabled = this.props.isDisabled;
	      var isFocused = this.state.isFocused;
	      return /*#__PURE__*/reactExports.createElement(IndicatorSeparator, _extends({}, commonProps, {
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderDropdownIndicator",
	    value: function renderDropdownIndicator() {
	      var _this$getComponents6 = this.getComponents(),
	        DropdownIndicator = _this$getComponents6.DropdownIndicator;
	      if (!DropdownIndicator) return null;
	      var commonProps = this.commonProps;
	      var isDisabled = this.props.isDisabled;
	      var isFocused = this.state.isFocused;
	      var innerProps = {
	        onMouseDown: this.onDropdownIndicatorMouseDown,
	        onTouchEnd: this.onDropdownIndicatorTouchEnd,
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/reactExports.createElement(DropdownIndicator, _extends({}, commonProps, {
	        innerProps: innerProps,
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderMenu",
	    value: function renderMenu() {
	      var _this4 = this;
	      var _this$getComponents7 = this.getComponents(),
	        Group = _this$getComponents7.Group,
	        GroupHeading = _this$getComponents7.GroupHeading,
	        Menu = _this$getComponents7.Menu,
	        MenuList = _this$getComponents7.MenuList,
	        MenuPortal = _this$getComponents7.MenuPortal,
	        LoadingMessage = _this$getComponents7.LoadingMessage,
	        NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
	        Option = _this$getComponents7.Option;
	      var commonProps = this.commonProps;
	      var focusedOption = this.state.focusedOption;
	      var _this$props12 = this.props,
	        captureMenuScroll = _this$props12.captureMenuScroll,
	        inputValue = _this$props12.inputValue,
	        isLoading = _this$props12.isLoading,
	        loadingMessage = _this$props12.loadingMessage,
	        minMenuHeight = _this$props12.minMenuHeight,
	        maxMenuHeight = _this$props12.maxMenuHeight,
	        menuIsOpen = _this$props12.menuIsOpen,
	        menuPlacement = _this$props12.menuPlacement,
	        menuPosition = _this$props12.menuPosition,
	        menuPortalTarget = _this$props12.menuPortalTarget,
	        menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
	        menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
	        noOptionsMessage = _this$props12.noOptionsMessage,
	        onMenuScrollToTop = _this$props12.onMenuScrollToTop,
	        onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
	      if (!menuIsOpen) return null;

	      // TODO: Internal Option Type here
	      var render = function render(props, id) {
	        var type = props.type,
	          data = props.data,
	          isDisabled = props.isDisabled,
	          isSelected = props.isSelected,
	          label = props.label,
	          value = props.value;
	        var isFocused = focusedOption === data;
	        var onHover = isDisabled ? undefined : function () {
	          return _this4.onOptionHover(data);
	        };
	        var onSelect = isDisabled ? undefined : function () {
	          return _this4.selectOption(data);
	        };
	        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
	        var innerProps = {
	          id: optionId,
	          onClick: onSelect,
	          onMouseMove: onHover,
	          onMouseOver: onHover,
	          tabIndex: -1,
	          role: 'option',
	          'aria-selected': _this4.isAppleDevice ? undefined : isSelected // is not supported on Apple devices
	        };

	        return /*#__PURE__*/reactExports.createElement(Option, _extends({}, commonProps, {
	          innerProps: innerProps,
	          data: data,
	          isDisabled: isDisabled,
	          isSelected: isSelected,
	          key: optionId,
	          label: label,
	          type: type,
	          value: value,
	          isFocused: isFocused,
	          innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
	        }), _this4.formatOptionLabel(props.data, 'menu'));
	      };
	      var menuUI;
	      if (this.hasOptions()) {
	        menuUI = this.getCategorizedOptions().map(function (item) {
	          if (item.type === 'group') {
	            var _data = item.data,
	              options = item.options,
	              groupIndex = item.index;
	            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
	            var headingId = "".concat(groupId, "-heading");
	            return /*#__PURE__*/reactExports.createElement(Group, _extends({}, commonProps, {
	              key: groupId,
	              data: _data,
	              options: options,
	              Heading: GroupHeading,
	              headingProps: {
	                id: headingId,
	                data: item.data
	              },
	              label: _this4.formatGroupLabel(item.data)
	            }), item.options.map(function (option) {
	              return render(option, "".concat(groupIndex, "-").concat(option.index));
	            }));
	          } else if (item.type === 'option') {
	            return render(item, "".concat(item.index));
	          }
	        });
	      } else if (isLoading) {
	        var message = loadingMessage({
	          inputValue: inputValue
	        });
	        if (message === null) return null;
	        menuUI = /*#__PURE__*/reactExports.createElement(LoadingMessage, commonProps, message);
	      } else {
	        var _message = noOptionsMessage({
	          inputValue: inputValue
	        });
	        if (_message === null) return null;
	        menuUI = /*#__PURE__*/reactExports.createElement(NoOptionsMessage, commonProps, _message);
	      }
	      var menuPlacementProps = {
	        minMenuHeight: minMenuHeight,
	        maxMenuHeight: maxMenuHeight,
	        menuPlacement: menuPlacement,
	        menuPosition: menuPosition,
	        menuShouldScrollIntoView: menuShouldScrollIntoView
	      };
	      var menuElement = /*#__PURE__*/reactExports.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function (_ref4) {
	        var ref = _ref4.ref,
	          _ref4$placerProps = _ref4.placerProps,
	          placement = _ref4$placerProps.placement,
	          maxHeight = _ref4$placerProps.maxHeight;
	        return /*#__PURE__*/reactExports.createElement(Menu, _extends({}, commonProps, menuPlacementProps, {
	          innerRef: ref,
	          innerProps: {
	            onMouseDown: _this4.onMenuMouseDown,
	            onMouseMove: _this4.onMenuMouseMove
	          },
	          isLoading: isLoading,
	          placement: placement
	        }), /*#__PURE__*/reactExports.createElement(ScrollManager, {
	          captureEnabled: captureMenuScroll,
	          onTopArrive: onMenuScrollToTop,
	          onBottomArrive: onMenuScrollToBottom,
	          lockEnabled: menuShouldBlockScroll
	        }, function (scrollTargetRef) {
	          return /*#__PURE__*/reactExports.createElement(MenuList, _extends({}, commonProps, {
	            innerRef: function innerRef(instance) {
	              _this4.getMenuListRef(instance);
	              scrollTargetRef(instance);
	            },
	            innerProps: {
	              role: 'listbox',
	              'aria-multiselectable': commonProps.isMulti,
	              id: _this4.getElementId('listbox')
	            },
	            isLoading: isLoading,
	            maxHeight: maxHeight,
	            focusedOption: focusedOption
	          }), menuUI);
	        }));
	      });

	      // positioning behaviour is almost identical for portalled and fixed,
	      // so we use the same component. the actual portalling logic is forked
	      // within the component based on `menuPosition`
	      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/reactExports.createElement(MenuPortal, _extends({}, commonProps, {
	        appendTo: menuPortalTarget,
	        controlElement: this.controlRef,
	        menuPlacement: menuPlacement,
	        menuPosition: menuPosition
	      }), menuElement) : menuElement;
	    }
	  }, {
	    key: "renderFormField",
	    value: function renderFormField() {
	      var _this5 = this;
	      var _this$props13 = this.props,
	        delimiter = _this$props13.delimiter,
	        isDisabled = _this$props13.isDisabled,
	        isMulti = _this$props13.isMulti,
	        name = _this$props13.name,
	        required = _this$props13.required;
	      var selectValue = this.state.selectValue;
	      if (required && !this.hasValue() && !isDisabled) {
	        return /*#__PURE__*/reactExports.createElement(RequiredInput$1, {
	          name: name,
	          onFocus: this.onValueInputFocus
	        });
	      }
	      if (!name || isDisabled) return;
	      if (isMulti) {
	        if (delimiter) {
	          var value = selectValue.map(function (opt) {
	            return _this5.getOptionValue(opt);
	          }).join(delimiter);
	          return /*#__PURE__*/reactExports.createElement("input", {
	            name: name,
	            type: "hidden",
	            value: value
	          });
	        } else {
	          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
	            return /*#__PURE__*/reactExports.createElement("input", {
	              key: "i-".concat(i),
	              name: name,
	              type: "hidden",
	              value: _this5.getOptionValue(opt)
	            });
	          }) : /*#__PURE__*/reactExports.createElement("input", {
	            name: name,
	            type: "hidden",
	            value: ""
	          });
	          return /*#__PURE__*/reactExports.createElement("div", null, input);
	        }
	      } else {
	        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';
	        return /*#__PURE__*/reactExports.createElement("input", {
	          name: name,
	          type: "hidden",
	          value: _value
	        });
	      }
	    }
	  }, {
	    key: "renderLiveRegion",
	    value: function renderLiveRegion() {
	      var commonProps = this.commonProps;
	      var _this$state6 = this.state,
	        ariaSelection = _this$state6.ariaSelection,
	        focusedOption = _this$state6.focusedOption,
	        focusedValue = _this$state6.focusedValue,
	        isFocused = _this$state6.isFocused,
	        selectValue = _this$state6.selectValue;
	      var focusableOptions = this.getFocusableOptions();
	      return /*#__PURE__*/reactExports.createElement(LiveRegion$1, _extends({}, commonProps, {
	        id: this.getElementId('live-region'),
	        ariaSelection: ariaSelection,
	        focusedOption: focusedOption,
	        focusedValue: focusedValue,
	        isFocused: isFocused,
	        selectValue: selectValue,
	        focusableOptions: focusableOptions,
	        isAppleDevice: this.isAppleDevice
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$getComponents8 = this.getComponents(),
	        Control = _this$getComponents8.Control,
	        IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
	        SelectContainer = _this$getComponents8.SelectContainer,
	        ValueContainer = _this$getComponents8.ValueContainer;
	      var _this$props14 = this.props,
	        className = _this$props14.className,
	        id = _this$props14.id,
	        isDisabled = _this$props14.isDisabled,
	        menuIsOpen = _this$props14.menuIsOpen;
	      var isFocused = this.state.isFocused;
	      var commonProps = this.commonProps = this.getCommonProps();
	      return /*#__PURE__*/reactExports.createElement(SelectContainer, _extends({}, commonProps, {
	        className: className,
	        innerProps: {
	          id: id,
	          onKeyDown: this.onKeyDown
	        },
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }), this.renderLiveRegion(), /*#__PURE__*/reactExports.createElement(Control, _extends({}, commonProps, {
	        innerRef: this.getControlRef,
	        innerProps: {
	          onMouseDown: this.onControlMouseDown,
	          onTouchEnd: this.onControlTouchEnd
	        },
	        isDisabled: isDisabled,
	        isFocused: isFocused,
	        menuIsOpen: menuIsOpen
	      }), /*#__PURE__*/reactExports.createElement(ValueContainer, _extends({}, commonProps, {
	        isDisabled: isDisabled
	      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/reactExports.createElement(IndicatorsContainer, _extends({}, commonProps, {
	        isDisabled: isDisabled
	      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
	    }
	  }], [{
	    key: "getDerivedStateFromProps",
	    value: function getDerivedStateFromProps(props, state) {
	      var prevProps = state.prevProps,
	        clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
	        inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
	        ariaSelection = state.ariaSelection,
	        isFocused = state.isFocused,
	        prevWasFocused = state.prevWasFocused,
	        instancePrefix = state.instancePrefix;
	      var options = props.options,
	        value = props.value,
	        menuIsOpen = props.menuIsOpen,
	        inputValue = props.inputValue,
	        isMulti = props.isMulti;
	      var selectValue = cleanValue(value);
	      var newMenuOptionsState = {};
	      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
	        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
	        var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
	        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
	        var focusedOption = getNextFocusedOption(state, focusableOptions);
	        var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
	        newMenuOptionsState = {
	          selectValue: selectValue,
	          focusedOption: focusedOption,
	          focusedOptionId: focusedOptionId,
	          focusableOptionsWithIds: focusableOptionsWithIds,
	          focusedValue: focusedValue,
	          clearFocusValueOnUpdate: false
	        };
	      }
	      // some updates should toggle the state of the input visibility
	      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
	        inputIsHidden: inputIsHiddenAfterUpdate,
	        inputIsHiddenAfterUpdate: undefined
	      } : {};
	      var newAriaSelection = ariaSelection;
	      var hasKeptFocus = isFocused && prevWasFocused;
	      if (isFocused && !hasKeptFocus) {
	        // If `value` or `defaultValue` props are not empty then announce them
	        // when the Select is initially focused
	        newAriaSelection = {
	          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
	          options: selectValue,
	          action: 'initial-input-focus'
	        };
	        hasKeptFocus = !prevWasFocused;
	      }

	      // If the 'initial-input-focus' action has been set already
	      // then reset the ariaSelection to null
	      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
	        newAriaSelection = null;
	      }
	      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
	        prevProps: props,
	        ariaSelection: newAriaSelection,
	        prevWasFocused: hasKeptFocus
	      });
	    }
	  }]);
	  return Select;
	}(reactExports.Component);
	Select.defaultProps = defaultProps;

	var StateManagedSelect = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
	  var baseSelectProps = useStateManager(props);
	  return /*#__PURE__*/reactExports.createElement(Select, _extends({
	    ref: ref
	  }, baseSelectProps));
	});
	var StateManagedSelect$1 = StateManagedSelect;

	const handleSpecificSelectChange = () => selectedOption => {
	  let elem = document.getElementById('magicitem1-specificType');
	  if (elem) {
	    if (selectedOption) {
	      elem.value = selectedOption.value;
	    } else {
	      elem.value = '';
	    }
	  }
	};
	const SpecificSelect = () => {
	  let options = [];
	  options.push({
	    value: 'armor',
	    label: 'Armor'
	  });
	  options.push({
	    value: 'bag_bottle',
	    label: 'Bags & Bottles'
	  });
	  options.push({
	    value: 'book',
	    label: 'Books'
	  });
	  options.push({
	    value: 'boot_glove',
	    label: 'Boots & Gloves'
	  });
	  options.push({
	    value: 'clothing',
	    label: 'Clothing'
	  });
	  options.push({
	    value: 'dust_stone',
	    label: 'Dusts & Stones'
	  });
	  options.push({
	    value: 'gem_jewelry',
	    label: 'Gems & Jewelry'
	  });
	  options.push({
	    value: 'girdle_helm',
	    label: 'Girdles & Helms'
	  });
	  options.push({
	    value: 'household',
	    label: 'Household Items'
	  });
	  options.push({
	    value: 'humorous',
	    label: 'Humorous'
	  });
	  options.push({
	    value: 'musical_instrument',
	    label: 'Musical Instruments'
	  });
	  options.push({
	    value: 'potion',
	    label: 'Potions'
	  });
	  options.push({
	    value: 'ring',
	    label: 'Rings'
	  });
	  options.push({
	    value: 'rod',
	    label: 'Rods'
	  });
	  options.push({
	    value: 'scroll',
	    label: 'Scrolls'
	  });
	  options.push({
	    value: 'staff',
	    label: 'Staves'
	  });
	  options.push({
	    value: 'wand',
	    label: 'Wands'
	  });
	  options.push({
	    value: 'weapon',
	    label: 'Weapons'
	  });
	  options.push({
	    value: 'weird',
	    label: 'Weird Items'
	  });
	  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(StateManagedSelect$1, {
	    onChange: handleSpecificSelectChange(),
	    options: options,
	    isClearable: true,
	    placeholder: "Pick Category Type",
	    sx: {
	      width: "30%",
	      height: "12pt"
	    }
	  }), /*#__PURE__*/React.createElement("input", {
	    id: "magicitem1-specificType",
	    type: "hidden",
	    value: ""
	  }));
	};
	class MagicItems1 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "1st/2nd Edition AD&D Magic Items"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Typography, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      }
	    }, "Source: Encyclopedia Magica (the 4 volume set)"), /*#__PURE__*/React.createElement(Grid, {
	      container: true
	    }, /*#__PURE__*/React.createElement(Grid, {
	      size: 12,
	      sx: {
	        textAlign: "center",
	        paddingRight: "2px"
	      }
	    }, "Specific Magic Category:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 12,
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(SpecificSelect, null)), /*#__PURE__*/React.createElement(Grid, {
	      size: 12,
	      sx: {
	        textAlign: "center"
	      }
	    }, "(1-50) ", /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-Specific",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 12,
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement("hr", null)), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Any Magic Item:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-Any",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Weapon or Armor:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-WeaponOrArmor",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Potion:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-Potion",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Scroll"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-Scroll",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Any, Except Weapon:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-AnyExceptWeapon",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "1 Each, No Potion or Scroll:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-AllExceptPotionScroll",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "right",
	        paddingRight: "2px"
	      }
	    }, "Misc. Magic Item:"), /*#__PURE__*/React.createElement(Grid, {
	      size: 6,
	      sx: {
	        textAlign: "left"
	      }
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "magicitem1-MiscMagic",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }))), /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(GenMagicItems1, {
	      source: "magicitem1"
	    }))));
	  }
	}

	const style$3 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenGems1$1(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getGems(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setGems(null);
	  };
	  const [gems, setGems] = reactExports.useState(null);
	  const getGems = async source => {
	    const gemsData = await callAPI(source);
	    setGems(gemsData);
	    setOpen(true);
	  };
	  const updateGem = async (indexToUpdate, newValue) => {
	    setGems(gems.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/gems1.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceGem(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newGem = await callAPI(source, 1);
	    updateGem(idx, newGem[0]);
	  }
	  function GemsList(_ref2) {
	    let {
	      source,
	      gems
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, gems.map((gem, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", null, gem), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceGem({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Gems"), gems && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$3
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Gems", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getGems(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(GemsList, {
	    source: source,
	    gems: gems
	  })))));
	}

	const style$2 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenJewelry1(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getJewelry(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setJewlery(null);
	  };
	  const [jewlery, setJewlery] = reactExports.useState(null);
	  const getJewelry = async source => {
	    const jewleryData = await callAPI(source);
	    setJewlery(jewleryData);
	    setOpen(true);
	  };
	  const updateJewelry = async (indexToUpdate, newValue) => {
	    setJewlery(jewlery.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/jewelry.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceJewelry(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newJewelry = await callAPI(source, 1);
	    updateJewelry(idx, newJewelry[0]);
	  }
	  function JewelryList(_ref2) {
	    let {
	      source,
	      jewlery
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, jewlery.map((jewleryText, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", null, jewleryText), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceJewelry({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Jewlery"), jewlery && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$2
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Jewlery", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getJewelry(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(JewelryList, {
	    source: source,
	    jewlery: jewlery
	  })))));
	}

	class Baubles1 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined",
	      sx: {
	        height: 'fit-content'
	      }
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "1st Edition AD&D Baubles"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "Gems1",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenGems1$1, {
	      source: "Gems1"
	    })), /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "Jewelry1",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenJewelry1, {
	      source: "Jewelry1"
	    }))));
	  }
	}

	const style$1 = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	async function callAPI() {
	  const treasure1_0 = document.getElementById('treasure1_0').value;
	  const treasure1_1 = document.getElementById('treasure1_1').value;
	  const treasure1_2 = document.getElementById('treasure1_2').value;
	  const treasure1_3 = document.getElementById('treasure1_3').value;
	  const treasure1_4 = document.getElementById('treasure1_4').value;
	  const treasure1_5 = document.getElementById('treasure1_5').value;
	  const treasure1_6 = document.getElementById('treasure1_6').value;
	  const treasure1_7 = document.getElementById('treasure1_7').value;
	  const treasure1_8 = document.getElementById('treasure1_8').value;
	  const treasure1_9 = document.getElementById('treasure1_9').value;
	  const treasure1_q0 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q0').value)));
	  const treasure1_q1 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q1').value)));
	  const treasure1_q2 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q2').value)));
	  const treasure1_q3 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q3').value)));
	  const treasure1_q4 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q4').value)));
	  const treasure1_q5 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q5').value)));
	  const treasure1_q6 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q6').value)));
	  const treasure1_q7 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q7').value)));
	  const treasure1_q8 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q8').value)));
	  const treasure1_q9 = Math.max(0, Math.min(200, parseInt(document.getElementById('treasure1_q9').value)));
	  let args = '';
	  if (treasure1_0 !== '' && treasure1_q0 !== 0) {
	    args += `&type0=${treasure1_0}&q0=${treasure1_q0}`;
	  }
	  if (treasure1_1 !== '' && treasure1_q1 !== 0) {
	    args += `&type1=${treasure1_1}&q1=${treasure1_q1}`;
	  }
	  if (treasure1_2 !== '' && treasure1_q2 !== 0) {
	    args += `&type2=${treasure1_2}&q2=${treasure1_q2}`;
	  }
	  if (treasure1_3 !== '' && treasure1_q3 !== 0) {
	    args += `&type3=${treasure1_3}&q3=${treasure1_q3}`;
	  }
	  if (treasure1_4 !== '' && treasure1_q4 !== 0) {
	    args += `&type4=${treasure1_4}&q4=${treasure1_q4}`;
	  }
	  if (treasure1_5 !== '' && treasure1_q5 !== 0) {
	    args += `&type5=${treasure1_5}&q5=${treasure1_q5}`;
	  }
	  if (treasure1_6 !== '' && treasure1_q6 !== 0) {
	    args += `&type6=${treasure1_6}&q6=${treasure1_q6}`;
	  }
	  if (treasure1_7 !== '' && treasure1_q7 !== 0) {
	    args += `&type7=${treasure1_7}&q7=${treasure1_q7}`;
	  }
	  if (treasure1_8 !== '' && treasure1_q8 !== 0) {
	    args += `&type8=${treasure1_8}&q8=${treasure1_q8}`;
	  }
	  if (treasure1_9 !== '' && treasure1_q9 !== 0) {
	    args += `&type9=${treasure1_9}&q9=${treasure1_q9}`;
	  }
	  if (args === '') {
	    return '[]';
	  }
	  args = args.slice(1);
	  let response = await fetch(`http://localhost:8080/tools2/api/treasure1.php?${args}`);
	  return await response.json();
	}
	async function replaceTreasure(_ref) {
	  let {
	    source,
	    key
	  } = _ref;
	  let newTreasure = await callAPI();
	  let display = key;
	  if (key === 'Any') {
	    display = 'Any Magic Item';
	  }
	  if (key === 'WeaponOrArmor') {
	    display = 'Weapon or Armor';
	  }
	  if (key === 'Potion') {
	    display = 'Potions';
	  }
	  if (key === 'Scroll') {
	    display = 'Scrolls';
	  }
	  if (key === 'AnyExceptWeapon') {
	    display = 'Any Magic Item, Except Weapons';
	  }
	  if (key === 'AllExceptPotionScroll') {
	    display = 'All Except Potions and Scrolls';
	  }
	  if (key === 'MiscMagic') {
	    display = 'Misc. Magic Items';
	  }
	  document.getElementById(`span-treasure1-${key}`).innerHTML = `${display}: ${newTreasure[key]}`;
	  if (source !== '') {
	    document.getElementById(`${source}`).value = newTreasure[key];
	  }
	}
	function TreasureList(_ref2) {
	  let {
	    treasure
	  } = _ref2;
	  let totalTreasure = 0;
	  Object.keys(treasure).forEach(function (key) {
	    totalTreasure += treasure[key];
	  });
	  return /*#__PURE__*/reactExports.createElement("div", null, totalTreasure === 0 ? 'No Treasure' : Object.keys(treasure).map(function (key) {
	    let addButton = /*#__PURE__*/reactExports.createElement("span", null);
	    let addForm = /*#__PURE__*/reactExports.createElement("input", {
	      type: "hidden",
	      id: `treasure1-${key}`,
	      value: treasure[key]
	    });
	    let source = '';
	    let display = key;
	    if (key === 'Gems' && treasure[key] > 0) {
	      source = 'treasure1-Gems';
	      addButton = /*#__PURE__*/reactExports.createElement(GenGems1$1, {
	        source: `${source}`
	      });
	    }
	    if (key === 'Jewelry' && treasure[key] > 0) {
	      source = 'treasure1-Jewelry';
	      addButton = /*#__PURE__*/reactExports.createElement(GenJewelry1, {
	        source: `${source}`
	      });
	    }
	    if (key === 'Any') {
	      source = 'treasure1-Any';
	      display = 'Any Magic Item';
	    }
	    if (key === 'WeaponOrArmor') {
	      source = 'treasure1-WeaponOrArmor';
	      display = 'Weapon or Armor';
	    }
	    if (key === 'Potion') {
	      source = 'treasure1-Potion';
	      display = 'Potions';
	    }
	    if (key === 'Scroll') {
	      source = 'treasure1-Scroll';
	      display = 'Scrolls';
	    }
	    if (key === 'AnyExceptWeapon') {
	      source = 'treasure1-AnyExceptWeapon';
	      display = 'Any Magic Item, Except Weapons';
	    }
	    if (key === 'AllExceptPotionScroll') {
	      source = 'treasure1-AllExceptPotionScroll';
	      display = 'All Except Potions and Scrolls';
	    }
	    if (key === 'MiscMagic') {
	      source = 'treasure1-MiscMagic';
	      display = 'Misc. Magic Items';
	    }
	    return /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", {
	      id: `span-treasure1-${key}`
	    }, display, ": ", treasure[key]), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceTreasure({
	        source,
	        key
	      })
	    }), /*#__PURE__*/reactExports.createElement("div", {
	      id: `addButton-${key}`
	    }, addButton, addForm));
	  }));
	}
	function GenTreasure1() {
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getTreasure();
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setTreasure(null);
	  };
	  const [treasure, setTreasure] = reactExports.useState(null);
	  const getTreasure = async () => {
	    const treasureData = await callAPI();
	    setTreasure(treasureData);
	    setOpen(true);
	  };
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Treasure"), treasure && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style$1
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Treasure", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getTreasure()
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(TreasureList, {
	    treasure: treasure
	  }), treasure['Any'] + treasure['WeaponOrArmor'] + treasure['Potion'] + treasure['Scroll'] + treasure['AnyExceptWeapon'] + +treasure['AllExceptPotionScroll'] + +treasure['MiscMagic'] > 0 ? /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement(GenMagicItems1, {
	    source: "treasure1"
	  })) : /*#__PURE__*/reactExports.createElement("div", null)))));
	}

	const handleAlphaSelectChange = id => selectedOption => {
	  let elem = document.getElementById(id);
	  if (elem) {
	    if (selectedOption) {
	      elem.value = selectedOption.value;
	    } else {
	      elem.value = '';
	    }
	  }
	};
	const AlphaSelect = targetID => {
	  const id = targetID.id;
	  let options = [];
	  for (let i = 65; i <= 90; i++) {
	    const char = String.fromCharCode(i);
	    const obj = {
	      value: char,
	      label: char
	    };
	    options.push(obj);
	  }
	  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(StateManagedSelect$1, {
	    onChange: handleAlphaSelectChange(id),
	    options: options,
	    isClearable: true,
	    placeholder: "Pick Treasure Type",
	    sx: {
	      width: "30%",
	      height: "16pt"
	    }
	  }), /*#__PURE__*/React.createElement("input", {
	    id: `${id}`,
	    type: "hidden",
	    value: ""
	  }));
	};
	class Treasure1 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined"
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "1st Edition AD&D Treasure"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Grid, {
	      container: true,
	      spacing: 2
	    }, /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(Typography, {
	      sx: {
	        textAlign: "center"
	      },
	      variant: "h6",
	      component: "h2"
	    }, "Treasure Type")), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(Typography, {
	      sx: {
	        textAlign: "center"
	      },
	      variant: "h6",
	      component: "h2"
	    }, "Quantity (1-200)")), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_0"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q0",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_1"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q1",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_2"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q2",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_3"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q3",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_4"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q4",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_5"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q5",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_6"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q6",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_7"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q7",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_8"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q8",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(AlphaSelect, {
	      id: "treasure1_9"
	    })), /*#__PURE__*/React.createElement(Grid, {
	      size: 6
	    }, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "treasure1_q9",
	      size: "small",
	      sx: {
	        width: "30%"
	      }
	    }))), /*#__PURE__*/React.createElement(GenTreasure1, null)));
	  }
	}

	const style = {
	  position: 'absolute',
	  top: '50%',
	  left: '50%',
	  transform: 'translate(-50%, -50%)',
	  width: '75%',
	  bgcolor: 'background.paper',
	  border: '2px solid #000',
	  boxShadow: 24,
	  p: 4,
	  overflow: 'auto',
	  maxHeight: '80%'
	};
	function GenGems1(props) {
	  const {
	    source
	  } = props;
	  const [open, setOpen] = reactExports.useState(false);
	  const handleOpen = () => {
	    getGems(source);
	  };
	  const handleClose = () => {
	    setOpen(false);
	    setGems(null);
	  };
	  const [gems, setGems] = reactExports.useState(null);
	  const getGems = async source => {
	    const gemsData = await callAPI(source);
	    setGems(gemsData);
	    setOpen(true);
	  };
	  const updateGem = async (indexToUpdate, newValue) => {
	    setGems(gems.map((item, index) => index === indexToUpdate ? newValue : item));
	  };
	  async function callAPI(source) {
	    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    const elem = document.getElementById(source);
	    if (elem.value) {
	      const newAmount = parseInt(elem.value);
	      if (amount === 0) {
	        amount = newAmount;
	      }
	    }
	    let response = await fetch(`http://localhost:8080/tools2/api/gems1.php?amount=${amount}`);
	    return await response.json();
	  }
	  async function replaceGem(_ref) {
	    let {
	      source,
	      idx
	    } = _ref;
	    let newGem = await callAPI(source, 1);
	    updateGem(idx, newGem[0]);
	  }
	  function GemsList(_ref2) {
	    let {
	      source,
	      gems
	    } = _ref2;
	    return /*#__PURE__*/reactExports.createElement("div", null, gems.map((gem, idx) => /*#__PURE__*/reactExports.createElement("div", null, /*#__PURE__*/reactExports.createElement("span", null, gem), /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	      sx: {
	        paddingLeft: "5px",
	        fontSize: "9pt"
	      },
	      onClick: () => replaceGem({
	        source,
	        idx
	      })
	    }))));
	  }
	  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Button, {
	    onClick: handleOpen
	  }, "Generate Gems"), gems && /*#__PURE__*/reactExports.createElement(Modal, {
	    open: open,
	    onClose: (event, reason) => {
	    },
	    disableEscapeKeyDown: true,
	    disableBackdropClick: true,
	    sx: {
	      maxHeight: "80%"
	    }
	  }, /*#__PURE__*/reactExports.createElement(Box, {
	    sx: style
	  }, /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "right"
	    }
	  }, /*#__PURE__*/reactExports.createElement(CloseIcon, {
	    onClick: handleClose
	  })), /*#__PURE__*/reactExports.createElement(Typography, {
	    sx: {
	      textAlign: "center"
	    },
	    variant: "h5",
	    component: "h2"
	  }, "Gems", /*#__PURE__*/reactExports.createElement(ReplayIcon, {
	    sx: {
	      paddingLeft: "5px",
	      fontSize: "10pt"
	    },
	    onClick: () => getGems(source)
	  })), /*#__PURE__*/reactExports.createElement(Typography, null, /*#__PURE__*/reactExports.createElement(GemsList, {
	    source: source,
	    gems: gems
	  })))));
	}

	class SpellBooks3 extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement(Card, {
	      variant: "outlined",
	      sx: {
	        height: 'fit-content'
	      }
	    }, /*#__PURE__*/React.createElement(CardHeader, {
	      sx: {
	        textAlign: "center",
	        fontWeight: "bold"
	      },
	      title: "3rd Edition AD&D Wizard Spellbooks"
	    }), /*#__PURE__*/React.createElement(CardContent, {
	      sx: {
	        textAlign: "center"
	      }
	    }, /*#__PURE__*/React.createElement(Typography, null, /*#__PURE__*/React.createElement(OutlinedInput, {
	      id: "SpellBooks3",
	      size: "small",
	      sx: {
	        width: "30%",
	        height: "16pt"
	      }
	    }), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(GenGems1, null))));
	  }
	}

	class Test extends React.Component {
	  render() {
	    return /*#__PURE__*/React.createElement("span", null);
	  }
	}

	const rootElement = document.getElementById('root');
	const root = clientExports.createRoot(rootElement);
	root.render(/*#__PURE__*/React.createElement(React.StrictMode, null, /*#__PURE__*/React.createElement(CssBaseline, null), /*#__PURE__*/React.createElement(Grid, {
	  container: true,
	  spacing: 2
	}, /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(NameGenerators, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(DungeonDressing, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(Traps, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(Treasure3, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(Baubles3, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(MagicItems3, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(Treasure1, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(Baubles1, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 4
	}, /*#__PURE__*/React.createElement(MagicItems1, null), /*#__PURE__*/React.createElement(Typography, {
	  sx: {
	    textAlign: "center"
	  }
	}, /*#__PURE__*/React.createElement(IntelligentWeapon, {
	  label: "Generic Intelligent Weapon"
	}))), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(SpellBooks3, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)), /*#__PURE__*/React.createElement(Grid, {
	  size: 6
	}, /*#__PURE__*/React.createElement(Test, null)))));

})();
